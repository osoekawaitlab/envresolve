{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to envresolve","text":"<p>Resolve environment variables from secret stores like Azure Key Vault.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Variable expansion: Expand <code>${VAR}</code> and <code>$VAR</code> syntax in strings</li> <li>Secret resolution: Fetch secrets from Azure Key Vault (more providers coming)</li> <li>.env support: Load variables from <code>.env</code> files and automatically resolve secrets</li> <li>Circular reference detection: Prevents infinite loops in variable chains</li> <li>Type-safe: Full mypy type checking support</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#load-from-env-file","title":"Load from .env File","text":"<p>The easiest way to use <code>envresolve</code> is by loading a <code>.env</code> file.</p> <pre><code>import envresolve\n\n# .env file content:\n# VAULT_NAME=my-vault\n# DATABASE_URL=akv://${VAULT_NAME}/db-url\n# API_KEY=akv://${VAULT_NAME}/api-key\n\n# Requires: pip install envresolve[azure]\n# Requires: Azure authentication (az login, Managed Identity, etc.)\nenvresolve.register_azure_kv_provider()\n\n# Load .env and resolve all secret URIs\n# By default, exports to os.environ\nresolved_vars = envresolve.load_env(\".env\")\n\n# Or load without exporting\nresolved_vars = envresolve.load_env(\".env\", export=False)\n</code></pre>"},{"location":"#direct-secret-resolution","title":"Direct Secret Resolution","text":"<p>You can also fetch individual secrets directly:</p> <pre><code>import envresolve\n\n# Requires: pip install envresolve[azure]\ntry:\n    envresolve.register_azure_kv_provider()\n    secret_value = envresolve.resolve_secret(\"akv://corp-vault/db-password\")\n    print(secret_value)\nexcept envresolve.ProviderRegistrationError as e:\n    print(f\"Azure SDK not available: {e}\")\nexcept envresolve.SecretResolutionError as e:\n    print(f\"Failed to fetch secret: {e}\")\n</code></pre>"},{"location":"#simple-variable-expansion","title":"Simple Variable Expansion","text":"<p>Expand variables without connecting to external services:</p> <pre><code>from envresolve import expand_variables\n\nenv = {\"VAULT\": \"corp-kv\", \"SECRET\": \"db-password\"}\nresult = expand_variables(\"akv://${VAULT}/${SECRET}\", env)\nprint(result)  # akv://corp-kv/db-password\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code># Basic installation (variable expansion only)\npip install envresolve\n\n# With Azure Key Vault support\npip install envresolve[azure]\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#current-version-010","title":"Current Version: 0.1.0","text":""},{"location":"roadmap/#completed-features","title":"Completed Features","text":"<ul> <li>\u2705 Variable expansion with <code>${VAR}</code> and <code>$VAR</code> syntax</li> <li>\u2705 Circular reference detection</li> <li>\u2705 Nested variable expansion</li> <li>\u2705 Support for <code>os.environ</code>, <code>.env</code> files, and custom dictionaries</li> <li>\u2705 Secret URI resolution with Azure Key Vault provider (<code>resolve_secret</code>, <code>load_env</code>)</li> </ul>"},{"location":"roadmap/#planned-features","title":"Planned Features","text":""},{"location":"roadmap/#v01x-in-progress","title":"v0.1.x (In Progress)","text":"<ul> <li>Validation helpers for string-based API (<code>is_resolved</code>, <code>needs_expansion</code>, <code>is_secret_uri</code>)</li> <li>Optional metadata/query helpers for resolved values</li> <li>Structured logging hooks for resolution diagnostics</li> </ul>"},{"location":"roadmap/#v02x","title":"v0.2.x","text":"<ul> <li>CLI tool (<code>envresolve render</code>)</li> <li>pydantic-settings integration</li> <li>Secret caching with TTL</li> </ul>"},{"location":"roadmap/#v03x","title":"v0.3.x+","text":"<ul> <li>Additional secret providers:</li> <li>AWS Secrets Manager / SSM Parameter Store</li> <li>Google Secret Manager</li> <li>HashiCorp Vault</li> <li>Local: 1Password, Bitwarden, pass, sops</li> <li>Async support for concurrent secret resolution</li> </ul>"},{"location":"adr/0000-adr-template/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0000-adr-template/#title","title":"Title","text":"<p>Short title of the architectural decision</p>"},{"location":"adr/0000-adr-template/#status","title":"Status","text":"<p>[Proposed | Accepted | Deprecated | Superseded]</p>"},{"location":"adr/0000-adr-template/#date","title":"Date","text":"<p>YYYY-MM-DD</p>"},{"location":"adr/0000-adr-template/#context","title":"Context","text":"<p>Describe the context and problem statement. What is the architectural challenge that needs to be addressed? Include any relevant constraints or requirements that influenced the decision.</p>"},{"location":"adr/0000-adr-template/#decision","title":"Decision","text":"<p>State the architectural decision clearly and concisely. What specific approach, technology, pattern, or solution was chosen?</p>"},{"location":"adr/0000-adr-template/#rationale","title":"Rationale","text":"<p>Explain the reasoning that led to this decision. Why was this particular option selected among the alternatives? Include relevant factors such as:</p> <ul> <li>Technical considerations</li> <li>Business requirements</li> <li>Team capabilities</li> <li>Time constraints</li> <li>Cost implications</li> </ul>"},{"location":"adr/0000-adr-template/#implications","title":"Implications","text":""},{"location":"adr/0000-adr-template/#positive-implications","title":"Positive Implications","text":"<p>List the benefits and positive outcomes expected from this decision.</p>"},{"location":"adr/0000-adr-template/#concerns","title":"Concerns","text":"<p>List potential challenges, risks, or negative consequences along with possible mitigation strategies.</p>"},{"location":"adr/0000-adr-template/#alternatives","title":"Alternatives","text":"<p>Describe other options that were considered and why they were not selected. For each alternative, briefly explain:</p> <ul> <li>Key characteristics</li> <li>Pros and cons relative to the chosen solution</li> <li>Reasons for rejection</li> </ul>"},{"location":"adr/0000-adr-template/#future-direction","title":"Future Direction","text":"<p>Outline any follow-up actions, future considerations, or potential changes that might be necessary as a result of this decision. Include potential triggers for revisiting this decision.</p>"},{"location":"adr/0000-adr-template/#references","title":"References","text":"<p>List any relevant documents, articles, books, or other resources that supported this decision:</p> <ul> <li>Links to relevant documentation</li> <li>Research materials</li> <li>Benchmarks or performance data</li> <li>Team discussions or meeting notes</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0001-variable-expansion-with-regex/#title","title":"Title","text":"<p>Use Regular Expressions for Variable Expansion</p>"},{"location":"adr/0001-variable-expansion-with-regex/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0001-variable-expansion-with-regex/#date","title":"Date","text":"<p>2025-10-10</p>"},{"location":"adr/0001-variable-expansion-with-regex/#context","title":"Context","text":"<p>The envresolve library needs to expand environment variable references in strings using <code>${VAR}</code> and <code>$VAR</code> syntax. The expansion must:</p> <ul> <li>Support both <code>${VAR}</code> and <code>$VAR</code> formats</li> <li>Handle multiple variables in a single string</li> <li>Enable future support for nested variable expansion</li> <li>Detect circular references</li> <li>Provide clear error messages when variables are missing</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#decision","title":"Decision","text":"<p>Use Python's <code>re</code> module with regex pattern matching (<code>\\$\\{([^}]+)\\}</code> for <code>${VAR}</code>) to implement variable expansion.</p>"},{"location":"adr/0001-variable-expansion-with-regex/#rationale","title":"Rationale","text":"<ul> <li>Simplicity: Regex provides a concise way to match variable patterns</li> <li>Standard library: No additional dependencies required</li> <li>Flexibility: Easy to extend patterns for <code>$VAR</code> syntax and more complex cases</li> <li>Performance: Regex is efficient for this use case</li> <li>Maintainability: Pattern is clear and well-understood by Python developers</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#implications","title":"Implications","text":""},{"location":"adr/0001-variable-expansion-with-regex/#positive-implications","title":"Positive Implications","text":"<ul> <li>Minimal code required for basic expansion</li> <li>Easy to test with unit tests</li> <li>Fast execution for typical use cases</li> <li>Clear separation between pattern matching and value substitution</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#concerns","title":"Concerns","text":"<ul> <li>Regex may become complex if we add many features (escaping, default values, etc.)</li> <li>Performance could degrade with very large strings or many variables</li> <li>Error messages from regex failures can be cryptic</li> </ul> <p>Mitigation: Keep patterns simple and add custom validation/error handling as needed.</p>"},{"location":"adr/0001-variable-expansion-with-regex/#alternatives","title":"Alternatives","text":""},{"location":"adr/0001-variable-expansion-with-regex/#string-template-stdlib","title":"String Template (stdlib)","text":"<p>Python's <code>string.Template</code> class provides variable substitution.</p> <ul> <li>Pros: Built-in, simple API, safer than format strings</li> <li>Cons: Limited to <code>$VAR</code> and <code>${VAR}</code> only, less flexible for custom extensions</li> <li>Rejection reason: We need more control over expansion behavior (cycle detection, nested expansion)</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#manual-string-parsing","title":"Manual String Parsing","text":"<p>Iterate through characters to find and replace variables.</p> <ul> <li>Pros: Complete control, potentially better error messages</li> <li>Cons: More complex to implement correctly, prone to edge case bugs, harder to maintain</li> <li>Rejection reason: Regex provides sufficient control with less complexity</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#ast-based-parsing","title":"AST-based Parsing","text":"<p>Build an abstract syntax tree for variable references.</p> <ul> <li>Pros: Very flexible, excellent error handling</li> <li>Cons: Overkill for this use case, significant complexity overhead</li> <li>Rejection reason: Not justified for simple variable expansion</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#future-direction","title":"Future Direction","text":"<ul> <li>If complexity grows (escaping, default values, filters), consider migrating to a dedicated template engine</li> <li>Monitor performance with profiling; optimize regex patterns if needed</li> <li>Add support for <code>$VAR</code> syntax using additional regex pattern</li> <li>Implement nested expansion through recursive calls with cycle detection</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#references","title":"References","text":"<ul> <li>Python <code>re</code> module documentation: https://docs.python.org/3/library/re.html</li> <li>Issue #1: Variable expansion in environment variables</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0002-custom-exception-hierarchy/#title","title":"Title","text":"<p>Use Custom Exception Hierarchy Instead of Built-in Exceptions</p>"},{"location":"adr/0002-custom-exception-hierarchy/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0002-custom-exception-hierarchy/#date","title":"Date","text":"<p>2025-10-11</p>"},{"location":"adr/0002-custom-exception-hierarchy/#context","title":"Context","text":"<p>The envresolve library needs to handle various error conditions during variable expansion (e.g., missing variables, circular references). We must decide whether to:</p> <ol> <li>Use Python's built-in exceptions (KeyError, ValueError, RuntimeError)</li> <li>Create custom exception classes specific to envresolve</li> </ol>"},{"location":"adr/0002-custom-exception-hierarchy/#decision","title":"Decision","text":"<p>Create a custom exception hierarchy with a base exception class (<code>EnvResolveError</code>) and specific exception types for each error condition (e.g., <code>VariableNotFoundError</code>, <code>CircularReferenceError</code>).</p>"},{"location":"adr/0002-custom-exception-hierarchy/#rationale","title":"Rationale","text":"<ul> <li>Selective error handling: Clients can catch <code>EnvResolveError</code> to handle all library errors or catch specific exceptions for fine-grained control</li> <li>Clear API contract: Custom exceptions document what errors the library can raise</li> <li>Namespace isolation: Prevents accidental catching of unrelated KeyError/ValueError from other code</li> <li>Domain semantics: Exception names reflect domain concepts (<code>VariableNotFoundError</code> is clearer than <code>KeyError</code>)</li> <li>Future extensibility: Easy to add new exception types as features are added</li> <li>Prevents leakage: Internal implementation details (like using dict for env) don't leak into the API</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/#implications","title":"Implications","text":""},{"location":"adr/0002-custom-exception-hierarchy/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clients can write <code>except EnvResolveError</code> to catch all library errors</li> <li>Clear separation between library errors and other Python errors</li> <li>Better IDE support with domain-specific exception names</li> <li>Exception hierarchy can evolve independently from implementation</li> <li>Easier to add exception-specific attributes and methods</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/#concerns","title":"Concerns","text":"<ul> <li>Slightly more boilerplate code (exception class definitions)</li> <li>Developers must remember to use custom exceptions instead of built-ins</li> </ul> <p>Mitigation: Exception classes are stable and infrequently modified. The benefits far outweigh the minimal overhead.</p>"},{"location":"adr/0002-custom-exception-hierarchy/#alternatives","title":"Alternatives","text":""},{"location":"adr/0002-custom-exception-hierarchy/#use-built-in-exceptions","title":"Use Built-in Exceptions","text":"<p>Raise <code>KeyError</code> for missing variables, <code>RuntimeError</code> for circular references.</p> <pre><code>if var_name not in env:\n    raise KeyError(var_name)\n</code></pre> <ul> <li>Pros: No extra code, familiar to Python developers</li> <li>Cons:</li> <li>Cannot distinguish library errors from other KeyError in client code</li> <li>Poor semantic clarity (KeyError doesn't convey \"variable not found in expansion\")</li> <li>Tight coupling to implementation (exposes that we use dict internally)</li> <li>Cannot catch \"all envresolve errors\" without catching unrelated errors</li> <li>Rejection reason: Lack of namespace isolation and poor API clarity</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/#exception-wrapper-pattern","title":"Exception Wrapper Pattern","text":"<p>Catch built-in exceptions and wrap them.</p> <pre><code>try:\n    value = env[var_name]\nexcept KeyError as e:\n    raise VariableNotFoundError(...) from e\n</code></pre> <ul> <li>Pros: Clear API boundary, custom exceptions for clients</li> <li>Cons: Still need to define custom exceptions (same as our decision)</li> <li>Note: This pattern is actually used in our implementation for internal error handling, but the key decision is to expose custom exceptions in the public API</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding exception base class methods for common operations (e.g., <code>to_dict()</code> for structured logging)</li> <li>Add exception hierarchy documentation to API reference</li> <li>Evaluate if recovery/retry strategies should be exception attributes</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/#references","title":"References","text":"<ul> <li>Python Exception Hierarchy: https://docs.python.org/3/library/exceptions.html#exception-hierarchy</li> <li>PEP 3151: Reworking the OS and IO exception hierarchy</li> <li>Issue #1: Variable expansion feature implementation</li> </ul>"},{"location":"adr/0003-structured-exception-design/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0003-structured-exception-design/#title","title":"Title","text":"<p>Use Structured Exceptions with Data Attributes</p>"},{"location":"adr/0003-structured-exception-design/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0003-structured-exception-design/#date","title":"Date","text":"<p>2025-10-11</p>"},{"location":"adr/0003-structured-exception-design/#context","title":"Context","text":"<p>Following ADR 0002 (Custom Exception Hierarchy), we have decided to use custom exceptions. This ADR addresses how to design those exception classes.</p> <p>When designing custom exceptions, we can choose between:</p> <ol> <li>Message-based: Pass error messages directly to exception constructors</li> <li>Structured: Pass structured data (variable names, values) and construct messages within the exception class</li> </ol>"},{"location":"adr/0003-structured-exception-design/#decision","title":"Decision","text":"<p>Use structured exceptions that accept specific data attributes (e.g., <code>variable_name</code>) and construct error messages internally within the exception class.</p>"},{"location":"adr/0003-structured-exception-design/#rationale","title":"Rationale","text":"<ul> <li>Consistency: Error message format is standardized across the codebase</li> <li>Programmatic access: Callers can access structured data (e.g., <code>e.variable_name</code>) for logging, debugging, or recovery</li> <li>Testability: Tests can validate specific error conditions by checking attributes rather than fragile string matching</li> <li>Internationalization: Message templates can be changed without modifying call sites</li> <li>Type safety: IDE and type checkers can validate that correct parameters are passed</li> </ul>"},{"location":"adr/0003-structured-exception-design/#implications","title":"Implications","text":""},{"location":"adr/0003-structured-exception-design/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clear separation between error data and error presentation</li> <li>Easier to extend exceptions with additional context (e.g., resolution suggestions)</li> <li>Better error handling in client code (can extract variable names programmatically)</li> <li>Consistent error message format across the library</li> </ul>"},{"location":"adr/0003-structured-exception-design/#concerns","title":"Concerns","text":"<ul> <li>Slightly more code in exception class definitions</li> <li>Need to maintain message templates when adding new exception types</li> </ul> <p>Mitigation: Exception classes are relatively stable; the benefits outweigh the minimal maintenance cost.</p>"},{"location":"adr/0003-structured-exception-design/#alternatives","title":"Alternatives","text":""},{"location":"adr/0003-structured-exception-design/#message-based-exceptions","title":"Message-based Exceptions","text":"<p>Pass complete error messages to exception constructors.</p> <pre><code>raise VariableNotFoundError(f\"Variable not found: {var_name}\")\n</code></pre> <ul> <li>Pros: Simple, minimal code, flexible message format</li> <li>Cons: Inconsistent messages, no programmatic access to error details, harder to test</li> <li>Rejection reason: Sacrifices structure and testability for minimal code savings</li> </ul>"},{"location":"adr/0003-structured-exception-design/#exception-with-optional-message-override","title":"Exception with Optional Message Override","text":"<p>Accept structured data but allow message override.</p> <pre><code>class VariableNotFoundError(EnvResolveError):\n    def __init__(self, variable_name: str, message: str | None = None):\n        self.variable_name = variable_name\n        msg = message or f\"Variable not found: {variable_name}\"\n        super().__init__(msg)\n</code></pre> <ul> <li>Pros: Flexibility for special cases</li> <li>Cons: Inconsistency risk if developers override messages arbitrarily</li> <li>Rejection reason: Flexibility not needed for this use case; consistency is more valuable</li> </ul>"},{"location":"adr/0003-structured-exception-design/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding helper methods for common error message patterns (e.g., <code>with_suggestion()</code>)</li> <li>If internationalization is needed, replace f-strings with message templates and localization framework</li> <li>Add structured logging integration that automatically logs exception attributes</li> </ul>"},{"location":"adr/0003-structured-exception-design/#references","title":"References","text":"<ul> <li>ADR 0002: Custom Exception Hierarchy</li> <li>Python Exception Best Practices: https://docs.python.org/3/tutorial/errors.html</li> <li>Issue #1: Variable expansion feature implementation</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0004-stateless-function-based-variable-expansion/#title","title":"Title","text":"<p>Use Stateless Function for Variable Expansion Core Logic</p>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#date","title":"Date","text":"<p>2025-10-11</p>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#context","title":"Context","text":"<p>The variable expansion service needs to provide a simple API for expanding <code>${VAR}</code> and <code>$VAR</code> references in strings. We must decide on the interface design:</p> <ol> <li>Stateless function: <code>expand_variables(text, env)</code> - takes both text and environment dict as parameters</li> <li>Stateful class: <code>VariableExpander(env)</code> with <code>expand(text)</code> method - environment configured at initialization</li> <li>Hybrid: Stateless function as core, with convenience wrapper class for os.environ integration</li> </ol> <p>Key considerations:</p> <ul> <li>Simplicity and ease of use</li> <li>Testability</li> <li>Flexibility for different use cases (.env files, os.environ, custom dicts)</li> <li>Performance (avoiding unnecessary object creation)</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#decision","title":"Decision","text":"<p>Use a stateless function (<code>expand_variables(text, env)</code>) as the core API, with an <code>EnvExpander</code> convenience class for os.environ integration.</p> <pre><code># Core API: stateless function\ndef expand_variables(text: str, env: dict[str, str]) -&gt; str:\n    \"\"\"Expand ${VAR} and $VAR in text using provided environment dictionary.\"\"\"\n\n# Convenience wrapper for os.environ\nclass EnvExpander:\n    def expand(self, text: str) -&gt; str:\n        return expand_variables(text, dict(os.environ))\n</code></pre>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#rationale","title":"Rationale","text":"<ul> <li>Simplicity: Functions are simpler than classes for stateless operations</li> <li>Explicit dependencies: <code>env</code> parameter makes it clear what data is being used</li> <li>Testability: Easy to test with different env dicts without object creation</li> <li>No unnecessary state: No need to store <code>env</code> when it's only used during expansion</li> <li>Performance: Avoids object allocation for one-time expansions</li> <li>Flexibility: Callers can easily switch env dicts between calls</li> <li>Pythonic: Aligns with Python's preference for functions over classes when state is not needed</li> <li>Convenience when needed: <code>EnvExpander</code> provides a clean API for the common os.environ use case</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#implications","title":"Implications","text":""},{"location":"adr/0004-stateless-function-based-variable-expansion/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clear, simple API that's easy to understand and use</li> <li>No hidden state or side effects</li> <li>Easier to reason about in tests (no setup required)</li> <li>Can be used as a building block for higher-level abstractions</li> <li>Flexibility to use with any dict (os.environ, .env files, custom configs)</li> <li>Better performance for one-off expansions</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#concerns","title":"Concerns","text":"<ul> <li>Slightly more verbose when repeatedly expanding with the same env dict</li> <li>Need to maintain consistency between function and class API</li> </ul> <p>Mitigation: The <code>EnvExpander</code> class addresses the verbosity concern for the os.environ use case. For other repeated use cases, callers can use <code>functools.partial</code> if needed.</p>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#alternatives","title":"Alternatives","text":""},{"location":"adr/0004-stateless-function-based-variable-expansion/#stateful-class-only","title":"Stateful Class Only","text":"<p>Use a class with env configured at initialization:</p> <pre><code>expander = VariableExpander(env)\nresult = expander.expand(text)\n</code></pre> <ul> <li>Pros: Less repetition when using the same env multiple times</li> <li>Cons:</li> <li>Unnecessary object creation for one-time use</li> <li>Hidden state makes testing more complex</li> <li>Need to create new objects to switch env dicts</li> <li>Violates \"functions over classes\" principle when state is not needed</li> <li>Rejection reason: Adds complexity without sufficient benefit. State is not needed for this operation.</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#factory-functions","title":"Factory Functions","text":"<p>Provide factory functions for common cases:</p> <pre><code>def create_expander(env: dict[str, str]) -&gt; Callable[[str], str]:\n    return lambda text: expand_variables(text, env)\n\ndef create_env_expander() -&gt; Callable[[str], str]:\n    return lambda text: expand_variables(text, dict(os.environ))\n</code></pre> <ul> <li>Pros: Functional style, flexible</li> <li>Cons: Less discoverable than a class, lambda functions harder to debug</li> <li>Rejection reason: Class provides better IDE support and clearer intent than lambda</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#global-state","title":"Global State","text":"<p>Store environment in module-level variable:</p> <pre><code>_env = {}\n\ndef set_environment(env: dict[str, str]) -&gt; None:\n    global _env\n    _env = env\n\ndef expand(text: str) -&gt; str:\n    return expand_variables(text, _env)\n</code></pre> <ul> <li>Pros: Very concise API</li> <li>Cons: Global mutable state, not thread-safe, makes testing difficult</li> <li>Rejection reason: Anti-pattern that causes numerous testing and concurrency issues</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding <code>functools.lru_cache</code> decorator if profiling shows repeated parsing overhead</li> <li>If more configuration options are needed (e.g., custom patterns, escaping), consider a configuration object</li> <li>Monitor usage patterns; if most calls use os.environ, consider making it the default parameter</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#references","title":"References","text":"<ul> <li>ADR 0001: Regular expressions for variable expansion</li> <li>Python Design Philosophy: \"Simple is better than complex\" (PEP 20)</li> <li>Issue #1: Variable expansion feature implementation</li> <li>Discussion: Function vs. Class API design</li> </ul>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#title","title":"Title","text":"<p>Use String-Based API with Idempotent Resolution Instead of Data Models</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#date","title":"Date","text":"<p>2025-10-12</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#context","title":"Context","text":"<p>As a library for resolving environment variables and secret URIs, envresolve must decide how to represent resolved values in its public API. There are two main approaches:</p> <ol> <li>Model-based API: Return structured data models (e.g., Pydantic models) with metadata</li> <li>String-based API: Return plain strings with utility functions for validation</li> </ol> <p>Key considerations:</p> <ul> <li>End users ultimately need string values to set as environment variables</li> <li>Library should integrate seamlessly with existing code</li> <li>Users should not be forced to perform type conversions</li> <li>Resolution should be safe to call multiple times (idempotent)</li> </ul> <p>The library's positioning as an infrastructure utility (not a domain framework) heavily influences this decision.</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#decision","title":"Decision","text":"<p>Use a string-based API with idempotent resolution, and plan for companion validation utilities in a later iteration.</p> <p>Current implementation:</p> <ol> <li>Public expansion helpers return <code>str</code></li> <li>Expanding an already resolved string is a no-op (idempotent)</li> <li>Internal helpers may use data structures, but the public surface stays string-based</li> </ol> <p>Planned follow-up (tracked for a future release):</p> <ol> <li>Expose validation utilities (<code>is_resolved()</code>, <code>needs_expansion()</code>, <code>is_secret_uri()</code>)</li> <li>Keep those helpers optional enhancements rather than mandatory steps before calling <code>resolve()</code></li> </ol>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#rationale","title":"Rationale","text":"<p>Why string-based API:</p> <ul> <li>Zero friction: Users get exactly what they need (strings for <code>os.environ</code>)</li> <li>No conversion overhead: No need to extract <code>.value</code> or call conversion methods</li> <li>Easy integration: Works with existing code that expects strings</li> <li>Library positioning: Infrastructure utilities should be transparent, not opinionated</li> </ul> <p>Why idempotent resolution:</p> <ul> <li>Safety: Can safely apply <code>resolve()</code> to already-resolved values</li> <li>Composability: Easy to chain or apply conditionally without checks</li> <li>Simplicity: User doesn't need to track resolution state manually</li> </ul> <p>Why validation utilities:</p> <ul> <li>Explicit control: Users can check state before resolution if needed</li> <li>Debugging: Easy to verify if a value is resolved or needs processing</li> <li>Flexibility: Enables conditional logic based on value state</li> </ul>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#implications","title":"Implications","text":""},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#positive-implications","title":"Positive Implications","text":"<ul> <li>Superior user experience: Minimal API surface, intuitive usage</li> <li>Easy adoption: No learning curve for basic usage</li> <li>Type safety internally: Can still use Pydantic models for internal validation</li> <li>Flexible integration: Works with any code expecting strings</li> <li>Performance: No object allocation overhead in hot paths</li> </ul>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#concerns","title":"Concerns","text":"<ul> <li>Less metadata: Cannot return source location, resolution timestamp, etc.</li> <li>String validation: Determining if a string is \"resolved\" requires heuristics</li> </ul> <p>Mitigation:</p> <ul> <li>Metadata can be provided through separate functions if needed (e.g., <code>get_resolution_info()</code>)</li> <li>Validation functions use well-defined rules (e.g., \"no URI schemes, no variable references\")</li> </ul>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#alternatives","title":"Alternatives","text":""},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#model-based-api-with-metadata","title":"Model-Based API with Metadata","text":"<p>Return structured results with metadata:</p> <pre><code>result = resolve(\"akv://vault/secret\")  # \u2192 ResolutionResult\nsecret = result.value  # \u2192 str\nsource = result.source  # \u2192 \"akv://vault/secret\"\n</code></pre> <p>Pros:</p> <ul> <li>Rich metadata (source, timestamp, cache status, etc.)</li> <li>Type-safe error handling</li> <li>Explicit success/failure state</li> </ul> <p>Cons:</p> <ul> <li>Friction: Users must extract <code>.value</code> every time</li> <li>Type conversion overhead: Extra step for the common case</li> <li>Complex API: More to learn, more verbose code</li> <li>Poor fit: Environment variables are fundamentally strings</li> </ul> <p>Rejection reason: The overhead of type conversion outweighs metadata benefits. Users prioritize simplicity for infrastructure code.</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#non-idempotent-resolution-with-strict-validation","title":"Non-Idempotent Resolution with Strict Validation","text":"<p>Raise errors when resolving already-resolved values:</p> <pre><code>resolve(\"akv://vault/secret\")  # \u2192 str\nresolve(\"actual-secret-value\")  # \u2192 Error: not a URI\n</code></pre> <p>Pros:</p> <ul> <li>Explicit error on misuse</li> <li>Forces user awareness</li> </ul> <p>Cons:</p> <ul> <li>Not composable: Cannot safely chain operations</li> <li>User burden: Must track resolution state manually</li> <li>Fragile: Breaks if applied twice by accident</li> </ul> <p>Rejection reason: Idempotency is more valuable than strict validation in infrastructure code.</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#hybrid-approach-with-optional-metadata","title":"Hybrid Approach with Optional Metadata","text":"<p>Provide both simple and rich APIs:</p> <pre><code># Simple (returns str)\nsecret = resolve(\"akv://...\")\n\n# Rich (returns model)\nresult = resolve_with_metadata(\"akv://...\")\n</code></pre> <p>Pros:</p> <ul> <li>Best of both worlds</li> <li>User chooses complexity level</li> </ul> <p>Cons:</p> <ul> <li>API bloat: Two APIs to maintain</li> <li>Confusion: Which one to use?</li> <li>Maintenance burden: Keep both in sync</li> </ul> <p>Rejection reason: Adds complexity without clear benefit. Simple API with separate utility functions is cleaner.</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding optional logging/tracing for debugging (e.g., via context manager)</li> <li>Implement the planned validation helpers (<code>is_resolved()</code>, <code>needs_expansion()</code>, <code>is_secret_uri()</code>) as the next iterative step</li> <li>If metadata needs emerge, provide separate query functions: <code>get_source()</code>, <code>get_resolution_time()</code></li> <li>Monitor usage patterns; if metadata is frequently needed, reconsider hybrid approach in v2.x</li> </ul>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#references","title":"References","text":"<ul> <li>ADR 0004: Stateless Function-Based Variable Expansion (established pattern of simple APIs)</li> <li>Discussion: Data models vs. string-based API for environment variable library</li> <li>Python stdlib <code>os.environ</code> - exclusively string-based, established pattern</li> <li>Issue #1: Variable expansion feature (informed by user needs)</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0006-nested-variable-expansion-implementation/#title","title":"Title","text":"<p>Two-Phase Iterative Algorithm for Nested Variable Expansion</p>"},{"location":"adr/0006-nested-variable-expansion-implementation/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0006-nested-variable-expansion-implementation/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0006-nested-variable-expansion-implementation/#context","title":"Context","text":"<p>The variable expansion service needs to support nested variable references like <code>${VAR_${NESTED}}</code>, where variable names themselves contain variable references that must be resolved first. This enables dynamic construction of variable names based on runtime values.</p> <p>Example use case:</p> <pre><code>ENV=prod\nDB_HOST=${DB_HOST_${ENV}}  # Should resolve to ${DB_HOST_prod}\nDB_HOST_prod=prod-server.example.com\n</code></pre> <p>Key requirements:</p> <ul> <li>Support arbitrary nesting depth (<code>${A_${B_${C}}}</code>)</li> <li>Maintain backward compatibility with simple expansion</li> <li>Detect circular references at any nesting level</li> <li>Provide clear error messages</li> <li>Acceptable performance for typical use cases</li> </ul> <p>Algorithm choices:</p> <ol> <li>Single-pass recursive regex: Replace variables recursively until no matches remain</li> <li>Two-phase iterative: Expand innermost curly braces first, then simple variables</li> <li>AST-based parser: Build syntax tree, evaluate bottom-up</li> <li>Multi-pass until stable: Keep expanding until output stops changing</li> </ol>"},{"location":"adr/0006-nested-variable-expansion-implementation/#decision","title":"Decision","text":"<p>Use a two-phase iterative algorithm that processes variables in phases:</p> <p>Phase 1: Innermost Curly Braces</p> <ul> <li>Pattern: <code>\\$\\{([^{}]+)\\}</code> (no nested braces)</li> <li>Expand innermost <code>${VAR}</code> references first</li> <li>Repeat until no more innermost curly braces match</li> </ul> <p>Phase 2: Simple Variables</p> <ul> <li>Pattern: <code>\\$([A-Za-z_][A-Za-z0-9_]*)\\b</code></li> <li>Expand <code>$VAR</code> syntax</li> <li>Repeat until no more simple variables match</li> </ul> <p>Algorithm:</p> <pre><code>def _expand_text(value: str, env: dict[str, str], stack: list[str]) -&gt; str:\n    current = value\n    while True:\n        # Phase 1: Expand innermost curly braces\n        if INNER_CURLY_PATTERN matches:\n            current = expand matches with _resolve()\n            continue\n\n        # Phase 2: Expand simple variables\n        if SIMPLE_VAR_PATTERN matches:\n            current = expand matches with _resolve()\n            continue\n\n        # No more matches - done or error\n        if unresolved patterns remain:\n            raise VariableNotFoundError\n        return current\n</code></pre>"},{"location":"adr/0006-nested-variable-expansion-implementation/#rationale","title":"Rationale","text":"<p>Why two-phase?</p> <ul> <li>Correctness: Innermost-first ensures nested references resolve correctly</li> <li>Predictability: Clear evaluation order (inside-out, left-to-right within phase)</li> <li>Error detection: Unresolved patterns after both phases indicate missing variables</li> </ul> <p>Why iterative over recursive?</p> <ul> <li>Stack safety: No recursion depth limits for deeply nested expressions</li> <li>Debuggability: Easier to trace expansion steps</li> <li>Performance: Avoids function call overhead for simple cases</li> </ul> <p>Why separate phases?</p> <ul> <li>Ambiguity resolution: <code>$VAR_${NESTED}</code> - which part expands first?</li> <li>Backward compatibility: Simple <code>${VAR}</code> and <code>$VAR</code> work as before</li> <li>Error clarity: Can distinguish between syntax errors and missing variables</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#implications","title":"Implications","text":""},{"location":"adr/0006-nested-variable-expansion-implementation/#positive-implications","title":"Positive Implications","text":"<ul> <li>Enables dynamic variable names: Powerful pattern for environment-specific configuration</li> <li>Maintains simplicity: Core algorithm remains understandable</li> <li>Preserves performance: Only iterates when variables are actually present</li> <li>Clear semantics: Inside-out evaluation matches user intuition</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#concerns","title":"Concerns","text":"<ul> <li>Performance: Deeply nested variables require multiple passes</li> <li>Mitigation: Most real-world usage is 1-2 levels deep; still O(n*m) where m is nesting depth</li> <li>Pattern ambiguity: <code>${VAR${NESTED}}</code> (missing underscore) is syntactically valid but confusing</li> <li>Mitigation: Document best practices; users should use <code>${VAR_${NESTED}}</code></li> <li>Infinite loop risk: Pattern must make progress each iteration</li> <li>Mitigation: Iteration only continues if pattern matched; unresolved patterns raise errors</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#alternatives","title":"Alternatives","text":""},{"location":"adr/0006-nested-variable-expansion-implementation/#single-pass-recursive-regex","title":"Single-Pass Recursive Regex","text":"<p>Recursively expand all variables in one pass:</p> <pre><code>pattern = r\"\\$\\{([^}]+)\\}|\\$([A-Za-z_][A-Za-z0-9_]*)\"\nre.sub(pattern, replace_func, text)\n</code></pre> <ul> <li>Pros: Simple implementation, single pass</li> <li>Cons:</li> <li>Cannot handle nested braces correctly</li> <li><code>${VAR_${NESTED}}</code> - inner <code>${NESTED}</code> not matched by <code>[^}]+</code></li> <li>Would need complex lookahead/lookbehind patterns</li> <li>Rejection reason: Regex cannot elegantly handle nested structures</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#ast-based-parser","title":"AST-Based Parser","text":"<p>Build abstract syntax tree, evaluate bottom-up:</p> <pre><code>ast = parse(\"${VAR_${NESTED}}\")\n# \u2192 BraceExpansion(\n#     name=Concat([Literal(\"VAR_\"), BraceExpansion(name=\"NESTED\")])\n#   )\nresult = evaluate(ast, env)\n</code></pre> <ul> <li>Pros:</li> <li>Very explicit structure</li> <li>Easy to add features (filters, default values)</li> <li>Excellent error reporting with positions</li> <li>Cons:</li> <li>Significant complexity overhead</li> <li>Requires lexer, parser, evaluator</li> <li>Overkill for current feature set</li> <li>Rejection reason: Complexity not justified for variable expansion use case</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#multi-pass-until-stable","title":"Multi-Pass Until Stable","text":"<p>Keep expanding until output stops changing:</p> <pre><code>while True:\n    new_value = expand_once(current, env)\n    if new_value == current:\n        break\n    current = new_value\n</code></pre> <ul> <li>Pros: Handles any nesting depth automatically</li> <li>Cons:</li> <li>Risk of infinite loops if pattern produces itself</li> <li>Harder to detect true errors vs. stability</li> <li>No clear phase ordering for mixed syntax</li> <li>Rejection reason: Less predictable behavior, harder error handling</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#greedy-regex-with-backtracking","title":"Greedy Regex with Backtracking","text":"<p>Use greedy matching with backtracking for nested patterns:</p> <pre><code>pattern = r\"\\$\\{([^{}]|\\{[^{}]*\\})*\\}\"\n</code></pre> <ul> <li>Pros: Single regex pattern</li> <li>Cons:</li> <li>Regex complexity explodes with nesting depth</li> <li>Poor error messages on mismatch</li> <li>Performance degrades with deep nesting (catastrophic backtracking risk)</li> <li>Rejection reason: Regex is wrong tool for nested structures</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#future-direction","title":"Future Direction","text":"<ul> <li>Performance optimization: If profiling shows issues, consider:</li> <li>Compile patterns once (already done with module-level <code>re.compile</code>)</li> <li>Add depth limit to prevent pathological cases</li> <li> <p>Cache expansion results for repeated patterns</p> </li> <li> <p>Enhanced error messages: Show partial expansion state when errors occur:</p> </li> </ul> <pre><code>VariableNotFoundError: MISSING\nDuring expansion of: \"${DB_${ENV}}\" \u2192 \"${DB_prod}\" \u2192 \"${DB_prod_MISSING}\"\n</code></pre> <ul> <li>Syntax extensions: If needed, two-phase algorithm can be extended:</li> <li>Default values: <code>${VAR:-default}</code></li> <li>Filters: <code>${VAR|lowercase}</code></li> <li> <p>Escape sequences: <code>\\${NOT_A_VAR}</code></p> </li> <li> <p>Migration to AST: If feature set grows significantly (10+ syntax features), consider AST-based approach for maintainability</p> </li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#references","title":"References","text":"<ul> <li>ADR 0001: Regular expressions for variable expansion</li> <li>ADR 0004: Stateless function-based variable expansion</li> <li>Implementation: <code>src/envresolve/services/expansion.py</code></li> <li>Test cases: <code>tests/unit/test_expansion.py::test_expand_nested_curly_braces</code></li> <li>Bash variable expansion: https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0007-layer-separation-services-vs-application/#title","title":"Title","text":"<p>Separate Services Layer (Pure Logic) from Application Layer (Environment Integration)</p>"},{"location":"adr/0007-layer-separation-services-vs-application/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0007-layer-separation-services-vs-application/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0007-layer-separation-services-vs-application/#context","title":"Context","text":"<p>As envresolve evolved, the <code>services/expansion.py</code> module contained both:</p> <ul> <li>Pure logic: <code>expand_variables(text, env)</code> - stateless string transformation</li> <li>Environment integration: <code>EnvExpander</code>, <code>DotEnvExpander</code> - classes that access <code>os.environ</code> and read <code>.env</code> files</li> </ul> <p>This mixing of concerns violated clean architecture principles:</p> <ul> <li>Services layer should contain pure business logic (testable without I/O)</li> <li>Environment/file I/O are infrastructure concerns</li> <li>Clear dependency direction ensures maintainability</li> </ul> <p>The question: Where should <code>EnvExpander</code> and <code>DotEnvExpander</code> reside?</p> <p>Options:</p> <ol> <li>Keep everything in services layer (current state before this ADR)</li> <li>Move expanders to a new application layer</li> <li>Move expanders to an infrastructure layer</li> <li>Create separate modules for each concern (services, io, etc.)</li> </ol>"},{"location":"adr/0007-layer-separation-services-vs-application/#decision","title":"Decision","text":"<p>Introduce an application layer and move <code>EnvExpander</code> and <code>DotEnvExpander</code> to <code>application/expanders.py</code>, while keeping <code>expand_variables</code> in <code>services/expansion.py</code>.</p> <p>Layer structure:</p> <pre><code>application/expanders.py    # EnvExpander, DotEnvExpander (environment integration)\n    \u2193 depends on\nservices/expansion.py       # expand_variables (pure logic)\n    \u2193 depends on\nexceptions.py              # Domain exceptions\n</code></pre> <p>Responsibility assignment:</p> <p>Services layer (<code>services/expansion.py</code>):</p> <ul> <li>Pure string transformation logic</li> <li><code>expand_variables(text: str, env: dict[str, str]) -&gt; str</code></li> <li>No I/O, no external dependencies beyond stdlib</li> <li>Easily testable with any dictionary</li> </ul> <p>Application layer (<code>application/expanders.py</code>):</p> <ul> <li>Integration with operating system and file system</li> <li><code>EnvExpander</code> - reads from <code>os.environ</code></li> <li><code>DotEnvExpander</code> - reads from <code>.env</code> files</li> <li>Coordinates services layer with external systems</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#rationale","title":"Rationale","text":"<p>Why separate layers?</p> <ul> <li>Single Responsibility Principle: Each layer has one reason to change</li> <li>Services: Change when expansion logic needs modification</li> <li>Application: Change when integration with environment/files changes</li> <li>Testability: Pure logic can be tested without mocking <code>os.environ</code> or file system</li> <li>Reusability: <code>expand_variables</code> can be used in any context, not just with environment variables</li> <li>Clear dependencies: Application depends on services, never the reverse</li> </ul> <p>Why \"application\" layer over \"infrastructure\"?</p> <ul> <li>Common terminology: Application layer coordinates business logic with external systems</li> <li>Infrastructure typically means: Lower-level concerns (database, network, logging)</li> <li>Expanders are use-case coordinators: They adapt the pure expansion service to specific environments</li> <li>Consistent with common patterns: Application layer is well-established for coordinating use cases</li> </ul> <p>Why not keep in services?</p> <ul> <li>Services should be pure and I/O-free</li> <li>Mixing pure logic with I/O makes testing harder</li> <li>Violates dependency inversion principle (high-level policy mixed with low-level details)</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#implications","title":"Implications","text":""},{"location":"adr/0007-layer-separation-services-vs-application/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clear boundaries: Easy to identify pure logic vs. integration code</li> <li>Better testability:</li> <li>Services: Test with simple dictionaries</li> <li>Application: Mock only the environment/file system, not expansion logic</li> <li>Easier to extend: New integrations (e.g., <code>ConfigFileExpander</code>) go in application layer</li> <li>Dependency graph clarity: Obvious which direction dependencies flow</li> <li>Matches established patterns: Follows Clean Architecture, Hexagonal Architecture principles</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#concerns","title":"Concerns","text":"<ul> <li>More files: Instead of one <code>expansion.py</code>, now have <code>services/expansion.py</code> and <code>application/expanders.py</code></li> <li>Mitigation: Better organization outweighs small increase in file count</li> <li>Import path changes: Public API imports from two places</li> <li>Mitigation: <code>__init__.py</code> exports both, so users only see <code>envresolve.expand_variables</code>, etc.</li> <li>Over-engineering risk: Small library might not need this complexity</li> <li>Mitigation: Separation is simple and pays dividends as library grows</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#alternatives","title":"Alternatives","text":""},{"location":"adr/0007-layer-separation-services-vs-application/#keep-everything-in-services-layer","title":"Keep Everything in Services Layer","text":"<p>Keep <code>expand_variables</code>, <code>EnvExpander</code>, <code>DotEnvExpander</code> together in <code>services/expansion.py</code>.</p> <ul> <li>Pros:</li> <li>Fewer files</li> <li>Everything related to expansion in one place</li> <li>Simpler import structure</li> <li>Cons:</li> <li>Mixed responsibilities (pure logic + I/O)</li> <li>Harder to test pure logic without mocking</li> <li>Dependency inversion violation</li> <li>Services layer depends on <code>os</code>, <code>pathlib</code>, <code>dotenv</code></li> <li>Rejection reason: Sacrifices architectural clarity for minor convenience</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#move-to-infrastructure-layer","title":"Move to Infrastructure Layer","text":"<p>Create <code>infrastructure/environment.py</code> and <code>infrastructure/files.py</code> for expanders.</p> <ul> <li>Pros:</li> <li>Clear I/O boundary</li> <li>Infrastructure layer is common pattern</li> <li>Cons:</li> <li>Infrastructure typically means low-level adapters (database, network)</li> <li>Expanders are use-case coordinators, not low-level adapters</li> <li>Creates confusion about infrastructure vs. application</li> <li>Rejection reason: Incorrect use of \"infrastructure\" terminology</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#flatten-into-multiple-modules","title":"Flatten into Multiple Modules","text":"<p>Create separate modules at same level:</p> <ul> <li><code>expansion.py</code> - pure logic</li> <li><code>env_integration.py</code> - <code>EnvExpander</code></li> <li> <p><code>file_integration.py</code> - <code>DotEnvExpander</code></p> </li> <li> <p>Pros:</p> </li> <li>Very granular separation</li> <li>Easy to find specific functionality</li> <li>Cons:</li> <li>No clear layer structure</li> <li>Harder to understand dependency direction</li> <li>Too many small files for small library</li> <li>Rejection reason: Over-fragmentation without clear architectural benefit</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#inline-into-public-api","title":"Inline into Public API","text":"<p>Move expanders to <code>api.py</code> alongside public API exports.</p> <ul> <li>Pros:</li> <li>All public-facing code in one place</li> <li>Minimal files</li> <li>Cons:</li> <li><code>api.py</code> becomes dumping ground for everything</li> <li>No separation of concerns</li> <li>Harder to extend with more expander types</li> <li>Rejection reason: API layer should be thin facade, not contain implementations</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#future-direction","title":"Future Direction","text":"<ul> <li>Additional application-layer components:</li> <li><code>application/resolver.py</code> - Secret URI resolution orchestration (when implementing <code>akv://</code> support)</li> <li><code>application/cache.py</code> - TTL caching for resolved secrets</li> <li> <p><code>application/loaders.py</code> - High-level <code>load_env()</code> functionality</p> </li> <li> <p>Potential infrastructure layer: If we add adapters for external systems:</p> </li> <li><code>infrastructure/azure_kv.py</code> - Azure Key Vault client adapter</li> <li><code>infrastructure/aws_secrets.py</code> - AWS Secrets Manager adapter</li> <li> <p>These would be low-level I/O adapters, distinct from application coordinators</p> </li> <li> <p>Re-evaluate if library grows: If services layer grows to 10+ modules, consider:</p> </li> <li>Domain-driven design with aggregates</li> <li>More sophisticated layering (use cases, repositories, etc.)</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#references","title":"References","text":"<ul> <li>Clean Architecture (Robert C. Martin): https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</li> <li>Hexagonal Architecture (Alistair Cockburn): https://alistair.cockburn.us/hexagonal-architecture/</li> <li>Implementation: <code>src/envresolve/application/expanders.py</code>, <code>src/envresolve/services/expansion.py</code></li> <li>Issue discussion: API redesign and layer separation</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0008-circular-reference-chain-tracking/#title","title":"Title","text":"<p>Track and Report Full Reference Chain in Circular Reference Errors</p>"},{"location":"adr/0008-circular-reference-chain-tracking/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0008-circular-reference-chain-tracking/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0008-circular-reference-chain-tracking/#context","title":"Context","text":"<p>Following ADR 0003 (Structured Exception Design), <code>CircularReferenceError</code> was designed to include structured data about the error. The initial implementation included only the variable name that caused the circular reference:</p> <pre><code>class CircularReferenceError(EnvResolveError):\n    def __init__(self, variable_name: str):\n        self.variable_name = variable_name\n        super().__init__(f\"Circular reference detected: {variable_name}\")\n</code></pre> <p>However, when debugging circular references in complex configurations, users need to see the full reference chain that led to the cycle, not just the variable where the cycle was detected.</p> <p>Example scenario:</p> <pre><code>A=${B}\nB=${C}\nC=${D}\nD=${A}  # Cycle here\n</code></pre> <p>Current error: <code>\"Circular reference detected: A\"</code></p> <ul> <li>User doesn't know which variables are involved in the cycle</li> <li>Hard to trace back through the reference chain</li> <li>Requires manual inspection of all variables to find the loop</li> </ul> <p>Desired error: <code>\"Circular reference detected: A -&gt; B -&gt; C -&gt; D -&gt; A\"</code></p> <ul> <li>Clear visualization of the complete cycle</li> <li>Easy to identify all variables involved</li> <li>Immediate understanding of the problem</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#decision","title":"Decision","text":"<p>Extend <code>CircularReferenceError</code> to track and report the full reference chain that forms the cycle:</p> <pre><code>class CircularReferenceError(EnvResolveError):\n    def __init__(self, variable_name: str, chain: list[str] | None = None):\n        self.variable_name = variable_name\n        self.chain = chain or []\n        chain_str = \" -&gt; \".join(self.chain) if self.chain else variable_name\n        msg = f\"Circular reference detected: {chain_str}\"\n        super().__init__(msg)\n</code></pre> <p>Implementation approach:</p> <ul> <li>Maintain a <code>stack: list[str]</code> during recursive expansion</li> <li>When a variable already in the stack is encountered, extract the cycle portion</li> <li>Pass the cycle chain to <code>CircularReferenceError</code> constructor</li> <li>Format chain as <code>\"A -&gt; B -&gt; C -&gt; A\"</code> in error message</li> </ul> <p>Algorithm:</p> <pre><code>def _resolve(var_name: str, env: dict[str, str], stack: list[str]) -&gt; str:\n    if var_name in stack:\n        # Found cycle - extract the cycle portion\n        cycle_start = stack.index(var_name)\n        cycle = [*stack[cycle_start:], var_name]\n        raise CircularReferenceError(var_name, cycle)\n\n    stack.append(var_name)\n    try:\n        return _expand_text(env[var_name], env, stack)\n    finally:\n        stack.pop()\n</code></pre>"},{"location":"adr/0008-circular-reference-chain-tracking/#rationale","title":"Rationale","text":"<p>Why track full chain?</p> <ul> <li>Debugging efficiency: Users immediately see the problem without manual tracing</li> <li>Error clarity: Complex cycles (<code>A -&gt; B -&gt; C -&gt; D -&gt; A</code>) are instantly visible</li> <li>Actionable information: Users know exactly which variables to fix</li> </ul> <p>Why format as \"A -&gt; B -&gt; A\"?</p> <ul> <li>Visual clarity: Arrow notation is intuitive and commonly used</li> <li>Cycle visibility: Showing start and end makes the loop obvious</li> <li>Familiarity: Matches stack trace and dependency chain conventions</li> </ul> <p>Why list of strings over single string?</p> <ul> <li>Programmatic access: Callers can analyze the chain (<code>len(exc.chain)</code> for cycle length)</li> <li>Testing: Can assert specific cycles in tests</li> <li>Future flexibility: Can format chain differently (JSON, graph, etc.)</li> <li>Consistency: Follows ADR 0003's principle of structured data over formatted strings</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#implications","title":"Implications","text":""},{"location":"adr/0008-circular-reference-chain-tracking/#positive-implications","title":"Positive Implications","text":"<ul> <li>Better user experience: Errors are immediately actionable</li> <li>Reduced debugging time: No need to manually trace through variable definitions</li> <li>Professional error messages: Clear, informative, helpful</li> <li>Testing improvement: Can verify exact cycle detection logic</li> <li>Programmatic error handling: Tools can analyze circular dependencies automatically</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#concerns","title":"Concerns","text":"<ul> <li>Memory overhead: Storing chain list for each error</li> <li>Mitigation: Chains are typically 2-10 variables; minimal memory impact</li> <li>Errors are exceptional path, not hot path</li> <li>Stack management complexity: Need to pass and maintain stack through recursion</li> <li>Mitigation: Stack is implementation detail, not exposed in public API</li> <li>Clear with try/finally pattern</li> <li>Chain extraction logic: Must correctly identify cycle portion</li> <li>Mitigation: Simple slice operation <code>stack[cycle_start:]</code></li> <li>Well-tested in unit tests</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#alternatives","title":"Alternatives","text":""},{"location":"adr/0008-circular-reference-chain-tracking/#variable-name-only-original-design","title":"Variable Name Only (Original Design)","text":"<p>Keep only <code>variable_name</code> without chain:</p> <pre><code>class CircularReferenceError(EnvResolveError):\n    def __init__(self, variable_name: str):\n        super().__init__(f\"Circular reference detected: {variable_name}\")\n</code></pre> <ul> <li>Pros:</li> <li>Simplest implementation</li> <li>Minimal memory usage</li> <li>No stack tracking needed</li> <li>Cons:</li> <li>Poor debugging experience</li> <li>User must manually trace references</li> <li>Hard to identify long cycles</li> <li>Rejection reason: Sacrifices usability for minimal complexity reduction</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#full-stack-trace-in-error-message","title":"Full Stack Trace in Error Message","text":"<p>Include full Python stack trace showing function calls:</p> <pre><code>import traceback\nmsg = f\"Circular reference: {variable_name}\\n{traceback.format_stack()}\"\n</code></pre> <ul> <li>Pros:</li> <li>Shows complete execution context</li> <li>Includes line numbers and file names</li> <li>Cons:</li> <li>Cluttered with implementation details (internal function names)</li> <li>Confuses users with irrelevant information</li> <li>Chain is buried in noise</li> <li>Rejection reason: Too much information, not user-focused</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#lazy-chain-computation","title":"Lazy Chain Computation","text":"<p>Don't track chain during expansion; recompute if error occurs:</p> <pre><code>def find_cycle(var_name: str, env: dict[str, str]) -&gt; list[str]:\n    # Re-traverse to find cycle\n    visited = []\n    current = var_name\n    while current not in visited:\n        visited.append(current)\n        current = extract_next_var(env[current])\n    return visited[visited.index(current):]\n</code></pre> <ul> <li>Pros:</li> <li>No overhead during normal execution</li> <li>Chain only computed when error occurs</li> <li>Cons:</li> <li>Complex re-traversal logic</li> <li>May not find exact same cycle (if nested expansion)</li> <li>Requires parsing variable references again</li> <li>Rejection reason: Complexity outweighs benefits; expansion already maintains stack</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#set-based-cycle-detection-only","title":"Set-Based Cycle Detection Only","text":"<p>Use a set for fast lookup, don't track order:</p> <pre><code>visited = set()\nif var_name in visited:\n    raise CircularReferenceError(var_name, list(visited))\n</code></pre> <ul> <li>Pros:</li> <li>Fast O(1) lookup</li> <li>Simple implementation</li> <li>Cons:</li> <li>Set is unordered; can't show reference chain in correct order</li> <li>Cycle path is lost (which variables led to which)</li> <li>Error message is confusing: \"Circular reference in {C, A, B, D}\" (no order)</li> <li>Rejection reason: Order is critical for understanding the problem</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#future-direction","title":"Future Direction","text":"<ul> <li>Cycle visualization: For complex cycles, consider:</li> <li>ASCII art diagram showing the cycle</li> <li>Graphviz DOT format for automated visualization</li> <li> <p>Suggestion of which variable to change</p> </li> <li> <p>Cycle length limits: If cycles exceed N variables, truncate display:</p> </li> </ul> <pre><code>\"Circular reference: A -&gt; B -&gt; ... -&gt; Y -&gt; Z -&gt; A (50 variables in cycle)\"\n</code></pre> <ul> <li>Interactive debugging: If running in interactive environment:</li> <li>Highlight cycle variables in configuration file</li> <li> <p>Suggest breaking the cycle with environment override</p> </li> <li> <p>Multiple cycle detection: Currently stops at first cycle found:</p> </li> <li>Consider detecting all cycles in a configuration</li> <li> <p>Report all cycles together for comprehensive fix</p> </li> <li> <p>Performance monitoring: Track cycle detection overhead:</p> </li> <li>If stack management becomes bottleneck, optimize</li> <li>Consider specialized data structure for large configurations</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#references","title":"References","text":"<ul> <li>ADR 0003: Structured Exception Design (establishes pattern of structured data in exceptions)</li> <li>Implementation: <code>src/envresolve/exceptions.py::CircularReferenceError</code></li> <li>Implementation: <code>src/envresolve/services/expansion.py::_resolve</code></li> <li>Test cases: <code>tests/unit/test_expansion.py::test_circular_reference_raises_error</code></li> <li>Graph cycle detection algorithms: https://en.wikipedia.org/wiki/Cycle_detection</li> <li>Error message best practices: https://developers.google.com/tech-writing/error-messages</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0009-manual-provider-registration-pattern/#title","title":"Title","text":"<p>Use Manual Provider Registration with Global Registry</p>"},{"location":"adr/0009-manual-provider-registration-pattern/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0009-manual-provider-registration-pattern/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0009-manual-provider-registration-pattern/#context","title":"Context","text":"<p>The Azure Key Vault secret resolution feature (Issue #3) required a mechanism to integrate secret providers with the resolution system. Several architectural questions arose:</p> <ol> <li>How should providers be discovered and registered?</li> <li>Should provider registration be automatic or explicit?</li> <li>How should the provider registry be structured?</li> <li>Should providers be singletons or instantiated per use?</li> </ol> <p>Key constraints:</p> <ul> <li>Users may not need all provider types (e.g., only Azure, not AWS)</li> <li>Provider initialization may require credentials or configuration</li> <li>Library should support multiple secret backends (Azure KV, AWS Secrets Manager, etc.)</li> <li>API should be simple and discoverable</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#decision","title":"Decision","text":"<p>Use manual provider registration with a global registry:</p> <ol> <li>Manual registration: Users explicitly call <code>register_azure_kv_provider()</code> before resolving secrets</li> <li>Global registry: Module-level <code>_PROVIDERS</code> dict maps URI schemes to provider instances</li> <li>Singleton providers: One provider instance per scheme, reused across all resolutions</li> <li>Explicit API: Registration functions are top-level exports (e.g., <code>envresolve.register_azure_kv_provider()</code>)</li> </ol> <p>Implementation pattern:</p> <pre><code># api.py\n_PROVIDERS: dict[str, SecretProvider] = {}\n\ndef register_azure_kv_provider() -&gt; None:\n    \"\"\"Register Azure Key Vault provider for akv:// and kv:// schemes.\"\"\"\n    provider = AzureKVProvider()\n    _PROVIDERS[\"akv\"] = provider\n    _PROVIDERS[\"kv\"] = provider  # Alias\n\ndef _get_provider(scheme: str) -&gt; SecretProvider:\n    \"\"\"Get provider for scheme, raise if not registered.\"\"\"\n    if scheme not in _PROVIDERS:\n        raise SecretResolutionError(f\"No provider registered for scheme '{scheme}'\")\n    return _PROVIDERS[scheme]\n</code></pre>"},{"location":"adr/0009-manual-provider-registration-pattern/#rationale","title":"Rationale","text":"<p>Why manual registration?</p> <ul> <li>Opt-in dependencies: Users only install and register providers they need</li> <li>Explicit control: Clear when providers are initialized (e.g., after credential setup)</li> <li>No magic: Obvious what's happening, easier to debug</li> <li>Configuration flexibility: Can pass custom credentials or config during registration</li> </ul> <p>Why global registry?</p> <ul> <li>Simplicity: No need to pass registry through call chains</li> <li>Singleton benefits: Provider instances can cache connections (e.g., Azure SecretClient per vault)</li> <li>Idempotent registration: Safe to call <code>register_*()</code> multiple times</li> <li>Thread-safe for reads: Once registered, providers are read-only</li> </ul> <p>Why singleton providers?</p> <ul> <li>Resource efficiency: Reuse authenticated clients across resolutions</li> <li>Connection pooling: Provider maintains connection cache internally</li> <li>Stateless operations: <code>resolve()</code> method is stateless, safe to share</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#implications","title":"Implications","text":""},{"location":"adr/0009-manual-provider-registration-pattern/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clear API surface: <code>register_*()</code> functions are discoverable via autocomplete</li> <li>Lazy loading: Only imported providers are loaded (no startup overhead)</li> <li>Testability: Easy to mock providers by registering test implementations</li> <li>Extensibility: New providers follow same pattern (e.g., <code>register_aws_provider()</code>)</li> <li>Error messages: Clear \"provider not registered\" errors guide users</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#concerns","title":"Concerns","text":"<ul> <li>Manual setup required: Users must remember to call <code>register_*()</code> before use</li> <li>Mitigation: Clear error messages with registration instructions</li> <li> <p>Mitigation: Examples in documentation show registration as first step</p> </li> <li> <p>Global state: Module-level registry is mutable global state</p> </li> <li>Mitigation: Registration is write-once in typical usage</li> <li>Mitigation: Tests can clear registry between test cases if needed</li> <li> <p>Future: Consider making registry explicit parameter for advanced use cases</p> </li> <li> <p>No auto-discovery: Cannot scan for available providers automatically</p> </li> <li>Mitigation: Explicit is better than implicit (Zen of Python)</li> <li>Future: Optional <code>register_all()</code> for convenience if many providers exist</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#alternatives","title":"Alternatives","text":""},{"location":"adr/0009-manual-provider-registration-pattern/#auto-registration-via-import","title":"Auto-Registration via Import","text":"<p>Automatically register providers when modules are imported:</p> <pre><code># providers/azure_kv.py\n# Auto-registers on import\nfrom envresolve.api import _PROVIDERS\n_PROVIDERS[\"akv\"] = AzureKVProvider()\n</code></pre> <ul> <li>Pros: No manual registration needed, automatic discovery</li> <li>Cons:</li> <li>Imports have side effects (anti-pattern)</li> <li>Cannot control initialization timing</li> <li>Cannot pass configuration</li> <li>Harder to test (import side effects)</li> <li>Forces loading of all provider dependencies</li> <li>Rejection reason: Side effects on import violate Python best practices; explicit is better</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#registry-as-explicit-parameter","title":"Registry as Explicit Parameter","text":"<p>Pass registry explicitly through function calls:</p> <pre><code>registry = ProviderRegistry()\nregistry.register(\"akv\", AzureKVProvider())\nresult = resolve_secret(\"akv://...\", registry=registry)\n</code></pre> <ul> <li>Pros:</li> <li>No global state</li> <li>Easy to use multiple registries</li> <li>Explicit dependency injection</li> <li>Cons:</li> <li>Verbose - every call needs registry parameter</li> <li>Poor ergonomics for simple use cases</li> <li>Complicates API significantly</li> <li>Rejection reason: Over-engineered for typical use; global registry is simpler</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#plugin-system-with-entry-points","title":"Plugin System with Entry Points","text":"<p>Use setuptools entry points for automatic discovery:</p> <pre><code># setup.py\nentry_points={\n    \"envresolve.providers\": [\n        \"akv = envresolve.providers.azure_kv:AzureKVProvider\"\n    ]\n}\n</code></pre> <ul> <li>Pros:</li> <li>Standard Python plugin pattern</li> <li>Extensible by third-party packages</li> <li>Auto-discovery without imports</li> <li>Cons:</li> <li>Overkill for first-party providers</li> <li>Complexity in initialization and configuration</li> <li>Harder to debug</li> <li>Not needed until third-party provider ecosystem exists</li> <li>Rejection reason: Premature optimization; manual registration is sufficient for v0.1.x</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#factory-pattern-with-builder","title":"Factory Pattern with Builder","text":"<p>Use factory pattern for provider creation:</p> <pre><code>provider = ProviderFactory.create(\"azure_kv\", vault=\"my-vault\")\nresult = resolve_secret(\"akv://...\", provider=provider)\n</code></pre> <ul> <li>Pros:</li> <li>Flexible provider configuration</li> <li>No global state</li> <li>Cons:</li> <li>Users must manage provider lifecycle</li> <li>Verbose for simple cases</li> <li>Cannot share providers across resolutions</li> <li>Rejection reason: Too much manual management; global registry with caching is better</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#future-direction","title":"Future Direction","text":"<ul> <li> <p>Optional <code>register_all()</code> convenience: If many providers exist, provide single-call registration:   <pre><code>envresolve.register_all()  # Registers all installed providers\n</code></pre></p> </li> <li> <p>Registry introspection: Add query functions if needed:   <pre><code>envresolve.list_providers()  # \u2192 [\"akv\", \"kv\", \"aws\"]\nenvresolve.is_provider_registered(\"akv\")  # \u2192 bool\n</code></pre></p> </li> <li> <p>Thread-safe registry mutations: If use cases emerge for dynamic provider registration in threaded environments, add locking</p> </li> <li> <p>Custom registries for advanced use cases: Support optional explicit registry parameter:   <pre><code>custom_registry = ProviderRegistry()\nresolve_secret(\"akv://...\", registry=custom_registry)  # Override global\n</code></pre></p> </li> <li> <p>Provider configuration API: If providers need complex configuration, add builder pattern:   <pre><code>register_azure_kv_provider(\n    credential=my_credential,\n    cache_ttl=600,\n    retry_policy=my_policy\n)\n</code></pre></p> </li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#references","title":"References","text":"<ul> <li>Issue #3: Azure Key Vault secret resolution support</li> <li>Implementation: <code>src/envresolve/api.py</code> (registry and registration functions)</li> <li>Implementation: <code>src/envresolve/providers/azure_kv.py</code> (provider implementation)</li> <li>Python Zen: \"Explicit is better than implicit\"</li> <li>Python anti-patterns: Import-time side effects</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0010-iterative-uri-resolution/#title","title":"Title","text":"<p>Iterative URI Resolution with Cycle Detection</p>"},{"location":"adr/0010-iterative-uri-resolution/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0010-iterative-uri-resolution/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0010-iterative-uri-resolution/#context","title":"Context","text":"<p>Secret URIs may resolve to values containing other URIs or variables requiring further expansion. This occurs in scenarios like:</p> <ul> <li>Gradual migration: <code>akv://vault/old-name</code> \u2192 <code>\"akv://vault/new-name\"</code> \u2192 actual secret</li> <li>Multi-level indirection for access control or configuration management</li> <li>Variable expansion in resolved values: <code>akv://vault/indirect</code> \u2192 <code>\"akv://vault/${KEY}\"</code> \u2192 needs expansion</li> </ul> <p>Without iterative resolution, users would need manual multi-step resolution. We need to maintain idempotency (plain strings return unchanged) while detecting circular references.</p>"},{"location":"adr/0010-iterative-uri-resolution/#decision","title":"Decision","text":"<p>Implement iterative resolution in <code>SecretResolver.resolve()</code> with cycle detection using a <code>seen</code> set:</p> <pre><code>seen = set()\ncurrent = uri\n\nwhile True:\n    if current in seen:\n        raise CircularReferenceError(variable_name=current, chain=[*list(seen), current])\n    seen.add(current)\n\n    expanded = expand_variables(current, env)\n    if not is_secret_uri(expanded):\n        return expanded  # Termination: not a URI\n\n    resolved = provider.resolve(parse_secret_uri(expanded))\n    if resolved == current:\n        return resolved  # Termination: stable value\n\n    current = resolved\n</code></pre>"},{"location":"adr/0010-iterative-uri-resolution/#rationale","title":"Rationale","text":"<ul> <li>Idempotency: Plain strings and non-target URIs return immediately without provider calls</li> <li>Flexibility: Supports arbitrary nesting depth and mixed variable/URI resolution</li> <li>Safety: <code>seen</code> set guarantees cycle detection without infinite loops</li> <li>Simplicity: Single resolution entry point handles all cases uniformly</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#implications","title":"Implications","text":""},{"location":"adr/0010-iterative-uri-resolution/#positive-implications","title":"Positive Implications","text":"<ul> <li>Users can chain URIs across vaults for access control patterns</li> <li>Variable expansion works at any nesting level</li> <li>Backward compatibility: existing single-level URIs work unchanged</li> <li>Idempotency ensures safe repeated calls</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#concerns","title":"Concerns","text":"<ul> <li>Performance: Multiple provider calls increase latency. Mitigation: Future TTL cache (ADR-pending)</li> <li>Debugging: Long resolution chains are hard to trace. Mitigation: <code>CircularReferenceError</code> includes full chain</li> <li>Complexity: Harder to reason about multi-step resolution. Mitigation: Comprehensive E2E tests (7 test cases)</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#alternatives","title":"Alternatives","text":""},{"location":"adr/0010-iterative-uri-resolution/#1-single-pass-resolution-only","title":"1. Single-pass resolution only","text":"<ul> <li>Simpler implementation</li> <li>Rejected: Users would need manual multi-step calls</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#2-recursive-resolution","title":"2. Recursive resolution","text":"<ul> <li>More functional style</li> <li>Rejected: Stack overflow risk, harder to track seen values</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#3-fixed-depth-limit-eg-max-10-iterations","title":"3. Fixed depth limit (e.g., max 10 iterations)","text":"<ul> <li>Simpler termination logic</li> <li>Rejected: Arbitrary limit; cycle detection is more robust</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#future-direction","title":"Future Direction","text":"<ul> <li>Add resolution metrics/logging for observability</li> <li>Consider optional depth limit as safety net (configurable, default disabled)</li> <li>Implement TTL cache to reduce redundant provider calls</li> <li>Evaluate async resolution for parallel multi-vault lookups</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#references","title":"References","text":"<ul> <li>E2E tests: <code>tests/e2e/test_nested_resolution.py</code></li> <li>Unit tests: <code>tests/unit/test_resolver.py</code></li> <li>Implementation: <code>src/envresolve/application/resolver.py:34-95</code></li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0011-conditional-doctest-skip/#title","title":"Title","text":"<p>Conditional Doctest Skip Based on Optional Dependencies</p>"},{"location":"adr/0011-conditional-doctest-skip/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0011-conditional-doctest-skip/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0011-conditional-doctest-skip/#context","title":"Context","text":"<p>Doctests in <code>api.py</code> demonstrate Azure Key Vault usage, but fail when <code>azure-identity</code> and <code>azure-keyvault-secrets</code> are not installed. Using <code># doctest: +SKIP</code> unconditionally skips these examples even when Azure SDK is available, preventing validation of documentation examples.</p> <p>We need doctests to:</p> <ul> <li>Run and validate when Azure SDK is installed</li> <li>Skip gracefully when Azure SDK is absent</li> <li>Work consistently across local development and CI environments</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#decision","title":"Decision","text":"<p>Implement pytest fixture-based conditional skipping in root <code>conftest.py</code>:</p> <pre><code>def _azure_sdk_available() -&gt; bool:\n    try:\n        return (\n            importlib.util.find_spec(\"azure.identity\") is not None\n            and importlib.util.find_spec(\"azure.keyvault.secrets\") is not None\n        )\n    except (ImportError, ModuleNotFoundError):\n        return False\n\n@pytest.fixture(autouse=True)\ndef _skip_azure_doctests(request: pytest.FixtureRequest) -&gt; None:\n    if not isinstance(request.node, pytest.DoctestItem):\n        return\n\n    if \"api.py\" in str(request.node.fspath):\n        azure_tests = [\"register_azure_kv_provider\", \"load_env\"]\n        is_azure = any(name in request.node.name for name in azure_tests)\n        if is_azure and not _azure_sdk_available():\n            pytest.skip(\"Azure SDK not available\")\n</code></pre> <p>Place in root <code>conftest.py</code> to apply to both <code>tests/</code> and <code>src/</code> (per <code>testpaths = [\"tests\", \"src\"]</code>).</p>"},{"location":"adr/0011-conditional-doctest-skip/#rationale","title":"Rationale","text":"<ul> <li>Environment-aware: Automatically detects Azure SDK availability</li> <li>Test coverage: Doctests run when dependencies are present</li> <li>No manual intervention: Users don't need to modify code based on their environment</li> <li>Pytest integration: Uses standard pytest skip mechanism</li> </ul> <p>Static <code># doctest: +SKIP</code> was rejected because it prevents testing when dependencies are available.</p>"},{"location":"adr/0011-conditional-doctest-skip/#implications","title":"Implications","text":""},{"location":"adr/0011-conditional-doctest-skip/#positive-implications","title":"Positive Implications","text":"<ul> <li>Doctests validate documentation accuracy when possible</li> <li>Graceful degradation without Azure SDK</li> <li>CI can test both scenarios (with/without optional deps)</li> <li>Consistent with <code>@pytest.mark.azure</code> strategy (ADR-0012)</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#concerns","title":"Concerns","text":"<ul> <li>Fixture complexity: More complex than simple <code>+SKIP</code></li> <li>Name coupling: Relies on doctest function names. Mitigation: Documented in fixture</li> <li>Maintenance: Future optional providers need fixture updates. Mitigation: Centralized in conftest.py</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#alternatives","title":"Alternatives","text":""},{"location":"adr/0011-conditional-doctest-skip/#1-unconditional-doctest-skip","title":"1. Unconditional <code># doctest: +SKIP</code>","text":"<ul> <li>Simpler</li> <li>Rejected: Never validates doctests, even when Azure SDK present</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#2-custom-doctest-directive-eg-skip_if_no_azure","title":"2. Custom doctest directive (e.g., <code>+SKIP_IF_NO_AZURE</code>)","text":"<ul> <li>More explicit in docstrings</li> <li>Rejected: Requires complex pytest doctest plugin customization</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#3-separate-doctest-files-for-optional-features","title":"3. Separate doctest files for optional features","text":"<ul> <li>Clear separation</li> <li>Rejected: Duplicates API documentation, harder to maintain</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#future-direction","title":"Future Direction","text":"<ul> <li>Extend pattern for other optional dependencies (AWS, GCP providers)</li> <li>Consider pytest plugin for cleaner syntax</li> <li>Add logging to show which doctests are skipped and why</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#references","title":"References","text":"<ul> <li>Implementation: <code>conftest.py:17-46</code></li> <li>Related: ADR-0012 (pytest markers for test files)</li> <li>Pytest docs: https://docs.pytest.org/en/stable/how-to/skipping.html</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#title","title":"Title","text":"<p>Use Pytest Marker to Isolate Azure-Dependent Tests</p>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#context","title":"Context","text":"<p>Optional Azure integrations (<code>azure-identity</code>, <code>azure-keyvault-secrets</code>) are not installed in every development or CI environment. When those packages are missing, importing Azure-specific test modules or running doctests that touch <code>envresolve.providers.azure_kv</code> causes hard failures, even though the core library and the majority of tests do not require Azure.</p> <p>We need an approach that allows the core suite to run without the Azure SDK while retaining full coverage when the optional dependencies are present.</p>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#decision","title":"Decision","text":"<p>Introduce a dedicated pytest marker (<code>azure</code>) and a complementary Nox session that excludes Azure-only modules when that marker is filtered out.</p> <pre><code># In Azure-focused test modules\nimport pytest\n\npytestmark = pytest.mark.azure\n\n\n@pytest.mark.azure\ndef test_azure_feature() -&gt; None:\n    ...\n</code></pre> <pre><code># noxfile.py\n@nox.session(python=\"3.12\")\ndef tests_without_azure(session: nox.Session) -&gt; None:\n    session.install(\"-e\", \".\", \"--group=dev\")  # without extras\n    session.run(\n        \"pytest\",\n        \"-m\",\n        \"not azure\",\n        \"--ignore=tests/unit/test_azure_kv_provider.py\",\n        \"--ignore=tests/e2e/test_azure_kv_resolution.py\",\n        \"--ignore=src/envresolve/providers/azure_kv.py\",\n    )\n</code></pre> <p>The explicit <code>--ignore</code> directives avoid import-time failures for modules that unconditionally import the Azure SDK.</p>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#rationale","title":"Rationale","text":"<ul> <li>Fail fast with clear signal: Tests that require Azure are labelled explicitly; skipped when marker excluded, and failures clearly indicate missing registration.</li> <li>Minimal disruption: Core contributors can run <code>nox -s tests_without_azure</code> without installing Azure packages, while CI can still run the full suite via <code>nox -s tests</code>.</li> <li>Consistency with doctests: Aligns with ADR-0011, which conditionally skips Azure doctests; both mechanisms rely on the same marker vocabulary.</li> <li>Discoverability: The <code>azure</code> marker is declared in <code>pyproject.toml</code> under <code>pytest.ini_options.markers</code>, making usage visible to contributors.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#implications","title":"Implications","text":""},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#positive-implications","title":"Positive Implications","text":"<ul> <li>Core regression suite (65 tests) executes without optional dependencies.</li> <li>CI pipelines can stage jobs: lightweight core run vs. full Azure-enabled run.</li> <li>Contributors immediately see which tests rely on Azure-specific behavior via the marker.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#concerns","title":"Concerns","text":"<ul> <li>Command verbosity: The combination of <code>-m \"not azure\"</code> with multiple <code>--ignore</code> flags is easy to mistype. Mitigation: Provide the <code>tests_without_azure</code> Nox session and document it in the contributor guide.</li> <li>Synchronization: When new Azure modules or tests are added, the ignore list must be updated. Mitigation: Future: Add to code review checklist to mark Azure tests and update Nox session.</li> <li>Marker proliferation: Future cloud providers may introduce additional markers. Mitigation: Document marker naming conventions and reuse the same pattern for other optional stacks if/when they arrive.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#alternatives","title":"Alternatives","text":""},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#always-install-azure-extras-in-ci","title":"Always Install Azure Extras in CI","text":"<ul> <li>Pros: Simplifies test invocation; no markers or ignores necessary.</li> <li>Cons: Forces every developer/CI job to install heavy dependencies and Azure native libraries. Does not solve local setups without the SDK.</li> <li>Rejection reason: Conflicts with the goal of running quickly on minimal environments.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#skip-tests-via-importerror-guards-inside-modules","title":"Skip Tests via <code>ImportError</code> Guards inside Modules","text":"<ul> <li>Pros: Keeps pytest invocation simple.</li> <li>Cons: Module-level code still executes before the guard runs, leading to <code>ImportError</code>. Requires defensive code at the top of every module.</li> <li>Rejection reason: Duplicate boilerplate with fragile control flow; marker approach centralizes the policy.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#separate-test-suite-command-custom-script","title":"Separate Test Suite Command (Custom Script)","text":"<ul> <li>Pros: Hide complexity behind a bespoke runner.</li> <li>Cons: Adds tooling to maintain; contributors still need to learn marker semantics eventually.</li> <li>Rejection reason: Nox already provides a lightweight orchestration layer; no need for another script.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#future-direction","title":"Future Direction","text":"<ul> <li>Consider refactoring Azure modules to import dependencies lazily (see ADR-0014). Once implemented, we can drop some <code>--ignore</code> flags and rely solely on markers.</li> <li>Add similar markers for other optional providers (AWS, GCP) if/when they are introduced.</li> <li>Automate marker enforcement (e.g., pytest plugin that fails if Azure SDK is missing while unmarked Azure tests are collected).</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#references","title":"References","text":"<ul> <li>Implementation: <code>noxfile.py::tests_without_azure</code></li> <li>Marker declaration: <code>pyproject.toml [tool.pytest.ini_options].markers</code></li> <li>Related ADRs: 0011 (conditional doctest skip), 0014 (lazy imports for optional providers)</li> <li>Test modules: <code>tests/unit/test_azure_kv_provider.py</code>, <code>tests/e2e/test_azure_kv_resolution.py</code></li> </ul>"},{"location":"adr/0013-class-based-api-design/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0013-class-based-api-design/#title","title":"Title","text":"<p>Encapsulate Resolution State in <code>EnvResolver</code> Class with Module Facade</p>"},{"location":"adr/0013-class-based-api-design/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0013-class-based-api-design/#date","title":"Date","text":"<p>2025-10-14</p>"},{"location":"adr/0013-class-based-api-design/#context","title":"Context","text":"<p>Early iterations of the secret resolution API maintained provider registrations and resolver state in module-level globals (<code>_PROVIDERS</code>, <code>_RESOLVER</code>). Although simple, this approach leaked mutable global state, required <code>global</code> declarations when mutating, and made it difficult to instantiate isolated resolvers for tests or advanced scenarios.</p> <p>We needed a structure that:</p> <ul> <li>Removes direct <code>global</code> manipulation from public functions</li> <li>Keeps the existing top-level API (<code>envresolve.resolve_secret</code>, <code>load_env</code>) for backward compatibility</li> <li>Allows creation of multiple resolver instances for specialized use cases (e.g., custom registries in tests)</li> <li>Keeps the provider registration pattern defined in ADR-0009</li> </ul>"},{"location":"adr/0013-class-based-api-design/#decision","title":"Decision","text":"<p>Introduce an <code>EnvResolver</code> class that encapsulates provider registration and resolution logic, and expose a singleton instance through module-level facade functions.</p> <pre><code>class EnvResolver:\n    def __init__(self) -&gt; None:\n        self._providers: dict[str, SecretProvider] = {}\n        self._resolver: SecretResolver | None = None\n\n    def register_azure_kv_provider(self, **kwargs: Any) -&gt; None:\n        ...\n\n    def resolve_secret(self, uri: str) -&gt; str:\n        ...\n\n    def load_env(self, path: PathLike[str] | None = None) -&gt; dict[str, str]:\n        ...\n\n\n_DEFAULT_RESOLVER = EnvResolver()\n\n\ndef resolve_secret(uri: str) -&gt; str:\n    return _DEFAULT_RESOLVER.resolve_secret(uri)\n\n\ndef register_azure_kv_provider(**kwargs: Any) -&gt; None:\n    _DEFAULT_RESOLVER.register_azure_kv_provider(**kwargs)\n</code></pre>"},{"location":"adr/0013-class-based-api-design/#rationale","title":"Rationale","text":"<ul> <li>Encapsulation: All mutable state (providers, cached resolver) is confined to an instance, eliminating <code>global</code> mutation patterns.</li> <li>Testability: Tests can instantiate <code>EnvResolver()</code> directly, register mock providers, and assert behavior without touching the global singleton.</li> <li>Extensibility: Future features (per-resolver caches, alternative registries) can build on the class without breaking the public facade.</li> <li>Backward compatibility: Existing users continue to call module-level functions; no API breakage.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#implications","title":"Implications","text":""},{"location":"adr/0013-class-based-api-design/#positive-implications","title":"Positive Implications","text":"<ul> <li>Cleaner separation between public facade and implementation details.</li> <li>Multiple resolvers can coexist in the same process if needed (e.g., multi-tenant scenarios).</li> <li>Easier to reason about initialization order\u2014<code>EnvResolver</code> constructor localizes default setup.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#concerns","title":"Concerns","text":"<ul> <li>Slightly higher indirection: Developers must look inside the class to understand state transitions. Mitigation: Comprehensive docstrings and ADR references.</li> <li>Singleton management: The <code>_DEFAULT_RESOLVER</code> remains module-level global state. Mitigation: Singleton usage isolated to facade; alternative resolvers supported when required.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#alternatives","title":"Alternatives","text":""},{"location":"adr/0013-class-based-api-design/#keep-module-level-globals","title":"Keep Module-Level Globals","text":"<ul> <li>Pros: Minimal code; fewer indirections.</li> <li>Cons: <code>global</code> keyword required for updates; difficult to create isolated resolver instances; tightly couples API to implementation details.</li> <li>Rejection reason: Conflicts with encapsulation and testability goals.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#dependency-injection-via-function-parameters","title":"Dependency Injection via Function Parameters","text":"<ul> <li>Pros: Explicitly pass provider registry/resolver to every function.</li> <li>Cons: Verbose public API; callers must thread dependencies through each call; hurts ergonomics.</li> <li>Rejection reason: Overly burdensome for primary use cases; the facade pattern strikes a better balance.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#metaclass-based-singleton","title":"Metaclass-Based Singleton","text":"<ul> <li>Pros: Guarantees only one instance ever exists.</li> <li>Cons: Unnecessarily complex; prevents intentional multiple instances in tests.</li> <li>Rejection reason: Simpler explicit singleton (module-level instance) suffices.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#future-direction","title":"Future Direction","text":"<ul> <li>Provide factory helpers (e.g., <code>create_resolver()</code>) that pre-register common providers.</li> <li>Expose hooks for dependency injection (custom cache, custom secret resolver) during <code>EnvResolver</code> initialization.</li> <li>Evaluate whether the <code>_DEFAULT_RESOLVER</code> should be lazy-initialized to reduce import-time side effects once provider registrations grow.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#references","title":"References","text":"<ul> <li>Implementation: <code>src/envresolve/api.py</code></li> <li>Tests: <code>tests/unit/test_resolver.py</code>, <code>tests/e2e/test_nested_resolution.py</code></li> <li>Related ADRs: 0009 (manual provider registration), 0010 (iterative URI resolution), 0014 (lazy imports for optional providers)</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0014-importlib-lazy-import/#title","title":"Title","text":"<p>Use <code>importlib</code> for Lazy Optional Dependency Loading with Rich Errors</p>"},{"location":"adr/0014-importlib-lazy-import/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0014-importlib-lazy-import/#date","title":"Date","text":"<p>2025-10-14</p>"},{"location":"adr/0014-importlib-lazy-import/#context","title":"Context","text":"<p>The Azure Key Vault provider depends on optional packages (<code>azure-identity</code>, <code>azure-keyvault-secrets</code>). Direct imports at module load time cause two problems:</p> <ol> <li>Importing <code>envresolve.providers.azure_kv</code> raises <code>ModuleNotFoundError</code> in environments without the Azure SDK, even if Azure functionality is never used.</li> <li>The resulting errors do not clearly instruct users which extras to install.</li> </ol> <p>We need a pattern that defers importing optional dependencies until the provider is actually requested and that explains how to resolve missing dependencies.</p>"},{"location":"adr/0014-importlib-lazy-import/#decision","title":"Decision","text":"<p>Use <code>importlib.import_module</code> inside <code>EnvResolver.register_azure_kv_provider</code> to load the provider lazily and produce a detailed error message when dependencies are missing.</p> <pre><code>import importlib\n\n\ndef register_azure_kv_provider(self, **kwargs: Any) -&gt; None:\n    try:\n        provider_module = importlib.import_module(\"envresolve.providers.azure_kv\")\n        provider_class = provider_module.AzureKVProvider\n    except ImportError as exc:  # Missing provider module or downstream deps\n        missing: list[str] = []\n        try:\n            importlib.util.find_spec(\"azure.identity\")\n        except (ImportError, ModuleNotFoundError):\n            missing.append(\"azure-identity\")\n\n        try:\n            importlib.util.find_spec(\"azure.keyvault.secrets\")\n        except (ImportError, ModuleNotFoundError):\n            missing.append(\"azure-keyvault-secrets\")\n\n        if missing:\n            hint = \", \".join(missing)\n            raise ProviderRegistrationError(\n                f\"Azure Key Vault provider requires {hint}. \"\n                \"Install with `pip install envresolve[azure]`.\",\n                original_error=exc\n            ) from exc\n\n        raise ProviderRegistrationError(\n            \"Failed to import Azure Key Vault provider; see chained exception for details.\",\n            original_error=exc\n        ) from exc\n\n    provider = provider_class(**kwargs)\n    self._providers[\"akv\"] = provider\n</code></pre>"},{"location":"adr/0014-importlib-lazy-import/#rationale","title":"Rationale","text":"<ul> <li>Lazy optional dependencies: Users without Azure extras can still import the package and use non-Azure features (aligns with ADR-0012).</li> <li>Actionable errors: When dependencies are missing, the raised message explicitly lists the missing packages and the extras command to install.</li> <li>Custom exception hierarchy: Uses <code>ProviderRegistrationError</code> instead of <code>ImportError</code> to align with ADR-0002 (custom exception hierarchy).</li> <li>Style compliance: Avoids Ruff's unused-import warnings and removes the need for <code>noqa</code> comments.</li> <li>Extensibility: Same pattern can be reused for future optional providers.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#implications","title":"Implications","text":""},{"location":"adr/0014-importlib-lazy-import/#positive-implications","title":"Positive Implications","text":"<ul> <li>Importing <code>envresolve</code> no longer requires the Azure SDK.</li> <li>Developers receive clear instructions on how to enable Azure functionality.</li> <li>Custom exception allows clients to handle provider registration errors separately from other errors (catch <code>ProviderRegistrationError</code> specifically or all envresolve errors via <code>EnvResolveError</code>).</li> <li>Unit tests can patch <code>importlib.import_module</code> to simulate missing dependencies.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#concerns","title":"Concerns","text":"<ul> <li>Slightly more boilerplate: Lazy import logic is longer than a simple <code>try/except ImportError</code>. Mitigation: Isolated inside a helper method and well-documented.</li> <li>Runtime detection cost: Uses <code>importlib.util.find_spec</code> to check dependencies. Mitigation: Called only when the provider is registered, not on every secret resolution.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#alternatives","title":"Alternatives","text":""},{"location":"adr/0014-importlib-lazy-import/#traditional-tryexcept-around-direct-import","title":"Traditional <code>try/except</code> around Direct Import","text":"<ul> <li>Pros: Very concise.</li> <li>Cons: Cannot distinguish which dependency is missing; forces import at module load time.</li> <li>Rejection reason: Fails the usability goal of actionable diagnostics and prevents import without Azure SDK.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#type_checking-guards","title":"<code>TYPE_CHECKING</code> Guards","text":"<ul> <li>Pros: Keeps type checkers aware of symbols while skipping runtime import.</li> <li>Cons: Does not help when the provider is actually used at runtime; still fails once the guarded code executes.</li> <li>Rejection reason: Insufficient for runtime optionality.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#entry-point-based-discovery","title":"Entry-Point Based Discovery","text":"<ul> <li>Pros: Can lazily load providers via plugin mechanism.</li> <li>Cons: Overkill for first-party providers and shifts complexity to packaging.</li> <li>Rejection reason: Simpler explicit import is adequate.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#future-direction","title":"Future Direction","text":"<ul> <li>Extract repeated dependency-check logic into a reusable helper once additional providers are added.</li> <li>Log missing-dependency diagnostics at DEBUG level when running in verbose mode to aid support investigations.</li> <li>Combine with ADR-0012 to remove explicit <code>--ignore</code> flags once all optional modules load lazily.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#references","title":"References","text":"<ul> <li>Implementation: <code>src/envresolve/api.py::EnvResolver.register_azure_kv_provider</code></li> <li>Related ADRs: 0002 (custom exception hierarchy), 0009 (provider registry), 0012 (pytest markers for optional providers)</li> <li>Python docs: https://docs.python.org/3/library/importlib.html</li> <li>Issue #5: Changed from <code>ImportError</code> to <code>ProviderRegistrationError</code> to align with ADR-0002</li> </ul>"},{"location":"adr/0015-terraform-managed-live-tests/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0015-terraform-managed-live-tests/#title","title":"Title","text":"<p>Manage Azure Live Test Infrastructure with Terraform</p>"},{"location":"adr/0015-terraform-managed-live-tests/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0015-terraform-managed-live-tests/#date","title":"Date","text":"<p>2025-10-15</p>"},{"location":"adr/0015-terraform-managed-live-tests/#context","title":"Context","text":"<p>envresolve includes optional support for Azure Key Vault. Unit and end-to-end tests currently use mocks to avoid external dependencies, but they cannot guarantee the integration behaves correctly against real Azure services. We also want a reproducible way to provision the required Azure resources (resource group, Key Vault, sample secrets) for contributors and CI without manual setup.</p> <p>Key considerations:</p> <ul> <li>Ensure infra can be created and destroyed deterministically for on-demand live tests.</li> <li>Capture secrets and configuration outputs so the pytest suite can authenticate and assert on real data.</li> <li>Keep costs low (single Key Vault, sample secret) and enable quick cleanup.</li> <li>Avoid leaking credentials by relying on standard Azure service principal flows and environment variables.</li> </ul>"},{"location":"adr/0015-terraform-managed-live-tests/#decision","title":"Decision","text":"<p>Adopt Terraform to manage live-test infrastructure and introduce an <code>azure and live</code> pytest marker for the real Azure integration tests. Provisioning is documented under <code>infra/terraform</code>, including helper Nox sessions (<code>terraform_plan_live</code>, <code>terraform_apply_live</code>, <code>terraform_destroy_live</code>) that wrap common operations. Terraform outputs supply the values consumed by live tests via environment variables such as <code>ENVRESOLVE_LIVE_KEY_VAULT_NAME</code> and <code>ENVRESOLVE_LIVE_SECRET_VALUE</code>.</p> <p>Live tests are opt-in: they skip automatically when configuration variables or Azure credentials are absent. A dedicated CI workflow (manual/cron) can apply Terraform, run the live suite, and tear down the resources afterwards.</p>"},{"location":"adr/0015-terraform-managed-live-tests/#rationale","title":"Rationale","text":"<ul> <li>Repeatability: Terraform defines the full resource graph, removing ad-hoc setup steps.</li> <li>Safety: Helper sessions ensure <code>terraform destroy</code> is easy to run and can be wired into CI cleanup even on failures.</li> <li>Isolation: Live tests sit behind explicit pytest markers, so day-to-day development remains fast and free from cloud dependencies.</li> <li>Documentation: A focused user guide page explains the workflow for both local and CI executions, lowering the barrier for contributors.</li> </ul>"},{"location":"adr/0015-terraform-managed-live-tests/#consequences","title":"Consequences","text":""},{"location":"adr/0015-terraform-managed-live-tests/#positive","title":"Positive","text":"<ul> <li>Real Azure regressions are caught before release.</li> <li>All required secrets and outputs are version-controlled and discoverable.</li> <li>CI pipelines can gate live tests separately from the core suite.</li> </ul>"},{"location":"adr/0015-terraform-managed-live-tests/#negative","title":"Negative","text":"<ul> <li>Terraform and Azure CLI become prerequisites for running the live suite.</li> <li>Sensitive Terraform outputs must be handled carefully (e.g., stored in CI secrets rather than printed to logs).</li> <li>Additional maintenance is required to keep infrastructure definitions aligned with evolving test needs.</li> </ul>"},{"location":"adr/0015-terraform-managed-live-tests/#alternatives-considered","title":"Alternatives Considered","text":"<ol> <li>Manual Azure setup instructions only</li> <li> <p>Rejected: Too error-prone; contributors might misconfigure permissions or forget cleanup.</p> </li> <li> <p>Dynamic resource creation inside pytest fixtures</p> </li> <li> <p>Rejected: Implementing provisioning in Python would duplicate Terraform features, complicate teardown, and intertwine infrastructure logic with tests.</p> </li> <li> <p>Always rely on mocked tests</p> </li> <li>Rejected: Mocks cannot detect changes in Azure SDK behavior, identity requirements, or Key Vault service quirks.</li> </ol>"},{"location":"adr/0015-terraform-managed-live-tests/#follow-up-actions","title":"Follow-Up Actions","text":"<ul> <li>Wire the Terraform workflow into CI (manual dispatch or scheduled job).</li> <li>Consider adding Key Vault network ACL configuration once CI egress addresses are known.</li> <li>Expand live coverage as new Azure providers or features are added.</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/","title":"Architecture Decision Record (ADR)","text":""},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#title","title":"Title","text":"<p>Use TypeError-based Custom Exception for Mutually Exclusive Parameters</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#date","title":"Date","text":"<p>2025-10-18</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#context","title":"Context","text":"<p>The <code>resolve_os_environ()</code> API accepts two filtering parameters: <code>keys</code> (list of specific keys) and <code>prefix</code> (filter by prefix and strip). These parameters serve different use cases and are mutually exclusive by design\u2014specifying both creates ambiguous behavior.</p> <p>We need to decide:</p> <ol> <li>How to handle the case when both parameters are specified</li> <li>What exception type to use</li> <li>Whether to use built-in exceptions or custom domain exceptions</li> </ol> <p>The options are:</p> <ol> <li>Silent precedence: Let one parameter silently override the other</li> <li>Raise TypeError: Use Python's built-in TypeError</li> <li>Raise ValueError: Use Python's built-in ValueError</li> <li>Raise custom exception: Create a domain-specific exception that also inherits from TypeError</li> </ol>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#decision","title":"Decision","text":"<p>Create a custom exception <code>MutuallyExclusiveArgumentsError</code> that inherits from both <code>EnvResolveError</code> (domain base) and <code>TypeError</code> (standard library semantic), and raise it when both <code>keys</code> and <code>prefix</code> are specified.</p> <pre><code>class MutuallyExclusiveArgumentsError(EnvResolveError, TypeError):\n    \"\"\"Raised when mutually exclusive arguments are specified together.\"\"\"\n\n    def __init__(self, arg1: str, arg2: str) -&gt; None:\n        self.arg1 = arg1\n        self.arg2 = arg2\n        msg = (\n            f\"Arguments '{arg1}' and '{arg2}' are mutually exclusive. \"\n            f\"Specify either '{arg1}' or '{arg2}', but not both.\"\n        )\n        super().__init__(msg)\n</code></pre>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#rationale","title":"Rationale","text":""},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#following-industry-standards","title":"Following Industry Standards","text":"<p>Research into established Python libraries revealed that <code>TypeError</code> is the standard exception for mutually exclusive parameters:</p> <ul> <li>pandas: Uses <code>TypeError</code> with message \"Keyword arguments <code>items</code>, <code>like</code>, or <code>regex</code> are mutually exclusive\" in <code>DataFrame.filter()</code></li> <li>pandas Exception Guidelines: Explicitly states TypeError should be raised for \"wrong number of arguments, mutually exclusive arguments\"</li> <li>Python argparse: Provides <code>add_mutually_exclusive_group()</code> which raises TypeError on conflict</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#aligning-with-existing-adrs","title":"Aligning with Existing ADRs","text":"<ul> <li>ADR-0002 (Custom Exception Hierarchy): Requires all library errors to inherit from <code>EnvResolveError</code> for selective error handling</li> <li>ADR-0003 (Structured Exception Design): Requires exceptions to accept structured data (argument names) with internal message construction</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#benefits-of-multiple-inheritance","title":"Benefits of Multiple Inheritance","text":"<p>Using <code>class MutuallyExclusiveArgumentsError(EnvResolveError, TypeError)</code>:</p> <ol> <li>Standard semantics: <code>isinstance(e, TypeError)</code> returns True, aligning with Python conventions</li> <li>Domain isolation: <code>isinstance(e, EnvResolveError)</code> returns True, allowing catch-all error handling</li> <li>Programmatic access: <code>e.arg1</code> and <code>e.arg2</code> attributes enable structured error handling</li> <li>Clear user feedback: Explicit error message prevents debugging confusion</li> </ol>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#better-than-silent-precedence","title":"Better Than Silent Precedence","text":"<p>Rejecting silent precedence (keys takes priority over prefix):</p> <ul> <li>Users may not notice the bug until production</li> <li>Implicit priority rules must be documented and remembered</li> <li>No feedback when API is misused</li> <li>Harder to debug when unexpected behavior occurs</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#implications","title":"Implications","text":""},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#positive-implications","title":"Positive Implications","text":"<ul> <li>Fail-fast: Errors are caught at function call time, not through unexpected behavior</li> <li>Clear API contract: Users immediately understand the constraint</li> <li>Consistent with ecosystem: Follows patterns from pandas and argparse</li> <li>Type-safe error handling: Callers can catch either <code>TypeError</code>, <code>EnvResolveError</code>, or the specific exception</li> <li>Structured data: <code>arg1</code> and <code>arg2</code> attributes allow programmatic error handling</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#concerns","title":"Concerns","text":"<ul> <li>Slight verbosity: Requires 2-3 lines of validation code at function entry</li> <li>Breaking change: Existing code passing both parameters will now raise an exception</li> </ul> <p>Mitigation:</p> <ul> <li>The validation is minimal and centralized in one place</li> <li>No existing code should rely on this undefined behavior (it was just implemented)</li> <li>The error message clearly explains how to fix the issue</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#alternatives","title":"Alternatives","text":""},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#alternative-1-keys-takes-precedence-silent","title":"Alternative 1: Keys Takes Precedence (Silent)","text":"<pre><code>if keys is not None:\n    keys_to_process = keys  # prefix ignored\nelif prefix is not None:\n    keys_to_process = [k for k in os.environ if k.startswith(prefix)]\n</code></pre> <p>Pros: Simple implementation, no exception handling needed Cons:</p> <ul> <li>Implicit behavior must be documented</li> <li>Users may not notice their mistake</li> <li>Debugging confusion when prefix is silently ignored</li> <li>Not consistent with pandas patterns</li> </ul> <p>Rejection reason: Poor user experience and against industry best practices</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#alternative-2-built-in-typeerror-only","title":"Alternative 2: Built-in TypeError Only","text":"<pre><code>if keys is not None and prefix is not None:\n    raise TypeError(\"Arguments 'keys' and 'prefix' are mutually exclusive\")\n</code></pre> <p>Pros: Uses standard library exception Cons:</p> <ul> <li>Cannot catch all envresolve errors with <code>except EnvResolveError</code></li> <li>No structured access to which arguments conflicted</li> <li>Violates ADR-0002 (custom exception hierarchy)</li> </ul> <p>Rejection reason: Breaks the domain exception hierarchy requirement</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#alternative-3-built-in-valueerror","title":"Alternative 3: Built-in ValueError","text":"<pre><code>if keys is not None and prefix is not None:\n    raise ValueError(\"Cannot specify both 'keys' and 'prefix'\")\n</code></pre> <p>Pros: Also a built-in exception Cons:</p> <ul> <li><code>ValueError</code> semantics are for \"right type, wrong value\"</li> <li>This is a \"wrong combination of arguments\" case (TypeError semantics)</li> <li>pandas uses TypeError for this pattern, not ValueError</li> </ul> <p>Rejection reason: Wrong exception semantics for this error type</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#alternative-4-apply-both-parameters","title":"Alternative 4: Apply Both Parameters","text":"<pre><code>if keys is not None and prefix is not None:\n    # Apply both: filter keys by prefix and strip\n    keys_to_process = [k for k in keys if k.startswith(prefix)]\n    strip_prefix = True\n</code></pre> <p>Pros: Maximally flexible Cons:</p> <ul> <li>Overlapping concerns\u2014prefix filtering can be done by the caller</li> <li>Adds complexity to the API surface</li> <li>Unclear semantics (does stripping still happen?)</li> </ul> <p>Rejection reason: Unnecessary complexity; orthogonal concerns should be separated</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding similar validation for other potential parameter conflicts in future APIs</li> <li>If multiple functions need mutual exclusivity checks, extract a reusable validator helper</li> <li>Monitor user feedback to see if other parameter combinations need similar treatment</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#references","title":"References","text":"<ul> <li>pandas Exception Guidelines: https://github.com/pandas-dev/pandas/wiki/Choosing-Exceptions-to-Raise</li> <li>pandas DataFrame.filter() implementation pattern</li> <li>ADR-0002: Custom Exception Hierarchy</li> <li>ADR-0003: Structured Exception Design</li> <li>Issue #7: Add resolve_os_environ() API</li> <li>Implementation: <code>src/envresolve/exceptions.py</code>, <code>src/envresolve/api.py</code></li> </ul>"},{"location":"api-reference/exceptions/","title":"Exceptions","text":"<p>This section details the custom exception hierarchy used in <code>envresolve</code>.</p>"},{"location":"api-reference/exceptions/#envresolve.exceptions","title":"envresolve.exceptions","text":"<p>Custom exceptions for envresolve.</p>"},{"location":"api-reference/exceptions/#envresolve.exceptions.EnvResolveError","title":"EnvResolveError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all envresolve errors.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class EnvResolveError(Exception):\n    \"\"\"Base exception for all envresolve errors.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.CircularReferenceError","title":"CircularReferenceError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when a circular reference is detected in variable expansion.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class CircularReferenceError(EnvResolveError):\n    \"\"\"Raised when a circular reference is detected in variable expansion.\"\"\"\n\n    def __init__(self, variable_name: str, chain: list[str] | None = None) -&gt; None:\n        \"\"\"Initialize CircularReferenceError.\n\n        Args:\n            variable_name: The variable that caused the circular reference\n            chain: Optional list showing the reference chain\n        \"\"\"\n        self.variable_name = variable_name\n        self.chain = chain or []\n        chain_str = \" -&gt; \".join(self.chain) if self.chain else variable_name\n        msg = f\"Circular reference detected: {chain_str}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.CircularReferenceError.__init__","title":"__init__","text":"<pre><code>__init__(\n    variable_name: str, chain: list[str] | None = None\n) -&gt; None\n</code></pre> <p>Initialize CircularReferenceError.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>The variable that caused the circular reference</p> required <code>chain</code> <code>list[str] | None</code> <p>Optional list showing the reference chain</p> <code>None</code> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(self, variable_name: str, chain: list[str] | None = None) -&gt; None:\n    \"\"\"Initialize CircularReferenceError.\n\n    Args:\n        variable_name: The variable that caused the circular reference\n        chain: Optional list showing the reference chain\n    \"\"\"\n    self.variable_name = variable_name\n    self.chain = chain or []\n    chain_str = \" -&gt; \".join(self.chain) if self.chain else variable_name\n    msg = f\"Circular reference detected: {chain_str}\"\n    super().__init__(msg)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.VariableNotFoundError","title":"VariableNotFoundError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when a referenced variable is not found in the environment.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class VariableNotFoundError(EnvResolveError):\n    \"\"\"Raised when a referenced variable is not found in the environment.\"\"\"\n\n    def __init__(self, variable_name: str) -&gt; None:\n        \"\"\"Initialize VariableNotFoundError.\n\n        Args:\n            variable_name: The variable that was not found\n        \"\"\"\n        self.variable_name = variable_name\n        super().__init__(f\"Variable not found: {variable_name}\")\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.VariableNotFoundError.__init__","title":"__init__","text":"<pre><code>__init__(variable_name: str) -&gt; None\n</code></pre> <p>Initialize VariableNotFoundError.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>The variable that was not found</p> required Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(self, variable_name: str) -&gt; None:\n    \"\"\"Initialize VariableNotFoundError.\n\n    Args:\n        variable_name: The variable that was not found\n    \"\"\"\n    self.variable_name = variable_name\n    super().__init__(f\"Variable not found: {variable_name}\")\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.URIParseError","title":"URIParseError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when a secret URI cannot be parsed.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class URIParseError(EnvResolveError):\n    \"\"\"Raised when a secret URI cannot be parsed.\"\"\"\n\n    def __init__(self, message: str, uri: str | None = None) -&gt; None:\n        \"\"\"Initialize URIParseError.\n\n        Args:\n            message: Error message describing the parsing failure\n            uri: The URI that failed to parse (optional)\n        \"\"\"\n        self.uri = uri\n        full_message = f\"{message}: {uri}\" if uri else message\n        super().__init__(full_message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.URIParseError.__init__","title":"__init__","text":"<pre><code>__init__(message: str, uri: str | None = None) -&gt; None\n</code></pre> <p>Initialize URIParseError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message describing the parsing failure</p> required <code>uri</code> <code>str | None</code> <p>The URI that failed to parse (optional)</p> <code>None</code> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(self, message: str, uri: str | None = None) -&gt; None:\n    \"\"\"Initialize URIParseError.\n\n    Args:\n        message: Error message describing the parsing failure\n        uri: The URI that failed to parse (optional)\n    \"\"\"\n    self.uri = uri\n    full_message = f\"{message}: {uri}\" if uri else message\n    super().__init__(full_message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.SecretResolutionError","title":"SecretResolutionError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when a secret cannot be resolved from its provider.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class SecretResolutionError(EnvResolveError):\n    \"\"\"Raised when a secret cannot be resolved from its provider.\"\"\"\n\n    def __init__(\n        self, message: str, uri: str, original_error: Exception | None = None\n    ) -&gt; None:\n        \"\"\"Initialize SecretResolutionError.\n\n        Args:\n            message: Error message describing the resolution failure\n            uri: The URI that failed to resolve\n            original_error: The original exception that caused this error (optional)\n        \"\"\"\n        self.uri = uri\n        self.original_error = original_error\n        full_message = f\"{message}: {uri}\"\n        if original_error:\n            full_message = f\"{full_message} (caused by: {original_error})\"\n        super().__init__(full_message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.SecretResolutionError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str,\n    uri: str,\n    original_error: Exception | None = None,\n) -&gt; None\n</code></pre> <p>Initialize SecretResolutionError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message describing the resolution failure</p> required <code>uri</code> <code>str</code> <p>The URI that failed to resolve</p> required <code>original_error</code> <code>Exception | None</code> <p>The original exception that caused this error (optional)</p> <code>None</code> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(\n    self, message: str, uri: str, original_error: Exception | None = None\n) -&gt; None:\n    \"\"\"Initialize SecretResolutionError.\n\n    Args:\n        message: Error message describing the resolution failure\n        uri: The URI that failed to resolve\n        original_error: The original exception that caused this error (optional)\n    \"\"\"\n    self.uri = uri\n    self.original_error = original_error\n    full_message = f\"{message}: {uri}\"\n    if original_error:\n        full_message = f\"{full_message} (caused by: {original_error})\"\n    super().__init__(full_message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.ProviderRegistrationError","title":"ProviderRegistrationError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when a provider registration fails.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class ProviderRegistrationError(EnvResolveError):\n    \"\"\"Raised when a provider registration fails.\"\"\"\n\n    def __init__(self, message: str, original_error: Exception | None = None) -&gt; None:\n        \"\"\"Initialize ProviderRegistrationError.\n\n        Args:\n            message: Error message describing the registration failure\n            original_error: The original exception that caused this error (optional)\n        \"\"\"\n        self.original_error = original_error\n        super().__init__(message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.ProviderRegistrationError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str, original_error: Exception | None = None\n) -&gt; None\n</code></pre> <p>Initialize ProviderRegistrationError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message describing the registration failure</p> required <code>original_error</code> <code>Exception | None</code> <p>The original exception that caused this error (optional)</p> <code>None</code> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(self, message: str, original_error: Exception | None = None) -&gt; None:\n    \"\"\"Initialize ProviderRegistrationError.\n\n    Args:\n        message: Error message describing the registration failure\n        original_error: The original exception that caused this error (optional)\n    \"\"\"\n    self.original_error = original_error\n    super().__init__(message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.MutuallyExclusiveArgumentsError","title":"MutuallyExclusiveArgumentsError","text":"<p>               Bases: <code>EnvResolveError</code>, <code>TypeError</code></p> <p>Raised when mutually exclusive arguments are specified together.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class MutuallyExclusiveArgumentsError(EnvResolveError, TypeError):\n    \"\"\"Raised when mutually exclusive arguments are specified together.\"\"\"\n\n    def __init__(self, arg1: str, arg2: str) -&gt; None:\n        \"\"\"Initialize MutuallyExclusiveArgumentsError.\n\n        Args:\n            arg1: First mutually exclusive argument name\n            arg2: Second mutually exclusive argument name\n        \"\"\"\n        self.arg1 = arg1\n        self.arg2 = arg2\n        msg = (\n            f\"Arguments '{arg1}' and '{arg2}' are mutually exclusive. \"\n            f\"Specify either '{arg1}' or '{arg2}', but not both.\"\n        )\n        super().__init__(msg)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.MutuallyExclusiveArgumentsError.__init__","title":"__init__","text":"<pre><code>__init__(arg1: str, arg2: str) -&gt; None\n</code></pre> <p>Initialize MutuallyExclusiveArgumentsError.</p> <p>Parameters:</p> Name Type Description Default <code>arg1</code> <code>str</code> <p>First mutually exclusive argument name</p> required <code>arg2</code> <code>str</code> <p>Second mutually exclusive argument name</p> required Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(self, arg1: str, arg2: str) -&gt; None:\n    \"\"\"Initialize MutuallyExclusiveArgumentsError.\n\n    Args:\n        arg1: First mutually exclusive argument name\n        arg2: Second mutually exclusive argument name\n    \"\"\"\n    self.arg1 = arg1\n    self.arg2 = arg2\n    msg = (\n        f\"Arguments '{arg1}' and '{arg2}' are mutually exclusive. \"\n        f\"Specify either '{arg1}' or '{arg2}', but not both.\"\n    )\n    super().__init__(msg)\n</code></pre>"},{"location":"api-reference/providers/","title":"Providers","text":"<p>Providers are responsible for fetching secrets from external stores. Learn how to use existing providers or create your own.</p>"},{"location":"api-reference/providers/#azure-key-vault-provider","title":"Azure Key Vault Provider","text":""},{"location":"api-reference/providers/#envresolve.providers.azure_kv","title":"envresolve.providers.azure_kv","text":"<p>Azure Key Vault provider implementation.</p>"},{"location":"api-reference/providers/#envresolve.providers.azure_kv.AzureKVProvider","title":"AzureKVProvider","text":"<p>Provider for resolving secrets from Azure Key Vault.</p> <p>Supports both akv:// and kv:// URI schemes. Uses DefaultAzureCredential for authentication. Caches SecretClient instances per vault for efficiency.</p> Source code in <code>src/envresolve/providers/azure_kv.py</code> <pre><code>class AzureKVProvider:\n    \"\"\"Provider for resolving secrets from Azure Key Vault.\n\n    Supports both akv:// and kv:// URI schemes.\n    Uses DefaultAzureCredential for authentication.\n    Caches SecretClient instances per vault for efficiency.\n    \"\"\"\n\n    def __init__(self, credential: \"TokenCredential | None\" = None) -&gt; None:\n        \"\"\"Initialize Azure Key Vault provider.\n\n        Args:\n            credential: Azure credential to use.\n                If None, DefaultAzureCredential is used.\n        \"\"\"\n        self.credential = credential or DefaultAzureCredential()\n        self._clients: dict[str, SecretClient] = {}\n\n    def _get_client(self, vault_name: str) -&gt; SecretClient:\n        \"\"\"Get or create a SecretClient for the given vault.\n\n        Args:\n            vault_name: Name of the Key Vault\n\n        Returns:\n            SecretClient instance for the vault\n        \"\"\"\n        if vault_name not in self._clients:\n            vault_url = f\"https://{vault_name}.vault.azure.net\"\n            self._clients[vault_name] = SecretClient(\n                vault_url=vault_url, credential=self.credential\n            )\n        return self._clients[vault_name]\n\n    def resolve(self, parsed_uri: ParsedURI) -&gt; str:\n        \"\"\"Resolve a secret from Azure Key Vault.\n\n        Args:\n            parsed_uri: Parsed URI dictionary containing vault, secret,\n                and optional version\n\n        Returns:\n            The secret value as a string\n\n        Raises:\n            SecretResolutionError: If the secret cannot be resolved\n        \"\"\"\n        vault_name = parsed_uri[\"vault\"]\n        secret_name = parsed_uri[\"secret\"]\n        version = parsed_uri[\"version\"]\n\n        # Reconstruct URI for error messages\n        uri = f\"{parsed_uri['scheme']}://{vault_name}/{secret_name}\"\n        if version:\n            uri = f\"{uri}?version={version}\"\n\n        try:\n            client = self._get_client(vault_name)\n            secret = client.get_secret(secret_name, version=version)\n        except AzureError as e:\n            msg = \"Failed to resolve secret from Azure Key Vault\"\n            raise SecretResolutionError(msg, uri=uri, original_error=e) from e\n        else:\n            if secret.value is None:\n                msg = \"Secret value is None\"\n                raise SecretResolutionError(msg, uri=uri)\n            return secret.value\n</code></pre>"},{"location":"api-reference/providers/#envresolve.providers.azure_kv.AzureKVProvider.__init__","title":"__init__","text":"<pre><code>__init__(credential: TokenCredential | None = None) -&gt; None\n</code></pre> <p>Initialize Azure Key Vault provider.</p> <p>Parameters:</p> Name Type Description Default <code>credential</code> <code>TokenCredential | None</code> <p>Azure credential to use. If None, DefaultAzureCredential is used.</p> <code>None</code> Source code in <code>src/envresolve/providers/azure_kv.py</code> <pre><code>def __init__(self, credential: \"TokenCredential | None\" = None) -&gt; None:\n    \"\"\"Initialize Azure Key Vault provider.\n\n    Args:\n        credential: Azure credential to use.\n            If None, DefaultAzureCredential is used.\n    \"\"\"\n    self.credential = credential or DefaultAzureCredential()\n    self._clients: dict[str, SecretClient] = {}\n</code></pre>"},{"location":"api-reference/providers/#envresolve.providers.azure_kv.AzureKVProvider.resolve","title":"resolve","text":"<pre><code>resolve(parsed_uri: ParsedURI) -&gt; str\n</code></pre> <p>Resolve a secret from Azure Key Vault.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_uri</code> <code>ParsedURI</code> <p>Parsed URI dictionary containing vault, secret, and optional version</p> required <p>Returns:</p> Type Description <code>str</code> <p>The secret value as a string</p> <p>Raises:</p> Type Description <code>SecretResolutionError</code> <p>If the secret cannot be resolved</p> Source code in <code>src/envresolve/providers/azure_kv.py</code> <pre><code>def resolve(self, parsed_uri: ParsedURI) -&gt; str:\n    \"\"\"Resolve a secret from Azure Key Vault.\n\n    Args:\n        parsed_uri: Parsed URI dictionary containing vault, secret,\n            and optional version\n\n    Returns:\n        The secret value as a string\n\n    Raises:\n        SecretResolutionError: If the secret cannot be resolved\n    \"\"\"\n    vault_name = parsed_uri[\"vault\"]\n    secret_name = parsed_uri[\"secret\"]\n    version = parsed_uri[\"version\"]\n\n    # Reconstruct URI for error messages\n    uri = f\"{parsed_uri['scheme']}://{vault_name}/{secret_name}\"\n    if version:\n        uri = f\"{uri}?version={version}\"\n\n    try:\n        client = self._get_client(vault_name)\n        secret = client.get_secret(secret_name, version=version)\n    except AzureError as e:\n        msg = \"Failed to resolve secret from Azure Key Vault\"\n        raise SecretResolutionError(msg, uri=uri, original_error=e) from e\n    else:\n        if secret.value is None:\n            msg = \"Secret value is None\"\n            raise SecretResolutionError(msg, uri=uri)\n        return secret.value\n</code></pre>"},{"location":"api-reference/providers/#base-provider-for-custom-implementations","title":"Base Provider (for custom implementations)","text":""},{"location":"api-reference/providers/#envresolve.providers.base","title":"envresolve.providers.base","text":"<p>Base provider protocol.</p>"},{"location":"api-reference/providers/#envresolve.providers.base.SecretProvider","title":"SecretProvider","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for secret providers.</p> Source code in <code>src/envresolve/providers/base.py</code> <pre><code>class SecretProvider(Protocol):\n    \"\"\"Protocol for secret providers.\"\"\"\n\n    def resolve(self, parsed_uri: ParsedURI) -&gt; str:\n        \"\"\"Resolve a secret from its provider.\n\n        Args:\n            parsed_uri: Parsed URI dictionary\n\n        Returns:\n            The secret value as a string\n\n        Raises:\n            SecretResolutionError: If the secret cannot be resolved\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api-reference/providers/#envresolve.providers.base.SecretProvider.resolve","title":"resolve","text":"<pre><code>resolve(parsed_uri: ParsedURI) -&gt; str\n</code></pre> <p>Resolve a secret from its provider.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_uri</code> <code>ParsedURI</code> <p>Parsed URI dictionary</p> required <p>Returns:</p> Type Description <code>str</code> <p>The secret value as a string</p> <p>Raises:</p> Type Description <code>SecretResolutionError</code> <p>If the secret cannot be resolved</p> Source code in <code>src/envresolve/providers/base.py</code> <pre><code>def resolve(self, parsed_uri: ParsedURI) -&gt; str:\n    \"\"\"Resolve a secret from its provider.\n\n    Args:\n        parsed_uri: Parsed URI dictionary\n\n    Returns:\n        The secret value as a string\n\n    Raises:\n        SecretResolutionError: If the secret cannot be resolved\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/public_api/","title":"Public API","text":"<p>This section covers the main functions intended for direct use in your applications.</p>"},{"location":"api-reference/public_api/#envresolve.api","title":"envresolve.api","text":"<p>Public API for envresolve.</p>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver","title":"EnvResolver","text":"<p>Manages provider registration and secret resolution.</p> <p>This class encapsulates the provider registry and resolver instance, eliminating the need for module-level global variables.</p> Source code in <code>src/envresolve/api.py</code> <pre><code>class EnvResolver:\n    \"\"\"Manages provider registration and secret resolution.\n\n    This class encapsulates the provider registry and resolver instance,\n    eliminating the need for module-level global variables.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize an empty provider registry.\"\"\"\n        self._providers: dict[str, SecretProvider] = {}\n        self._resolver: SecretResolver | None = None\n\n    def _get_resolver(self) -&gt; SecretResolver:\n        \"\"\"Get or create the resolver instance.\n\n        Returns:\n            SecretResolver instance configured with registered providers\n        \"\"\"\n        if self._resolver is None:\n            self._resolver = SecretResolver(self._providers)\n        return self._resolver\n\n    def register_azure_kv_provider(\n        self, provider: \"SecretProvider | None\" = None\n    ) -&gt; None:\n        \"\"\"Register Azure Key Vault provider for akv:// scheme.\n\n        This method is safe to call multiple times (idempotent).\n\n        Args:\n            provider: Optional custom provider. If None, uses default AzureKVProvider.\n\n        Raises:\n            ProviderRegistrationError: If azure-identity or azure-keyvault-secrets\n                is not installed (only when provider is None)\n        \"\"\"\n        if provider is None:\n            try:\n                # Dynamically import the provider module\n                provider_module = importlib.import_module(\n                    \"envresolve.providers.azure_kv\"\n                )\n                provider_class = provider_module.AzureKVProvider\n            except ImportError as e:\n                # Check which dependency is missing\n                missing_deps: list[str] = []\n                try:\n                    importlib.import_module(\"azure.identity\")\n                except ImportError:\n                    missing_deps.append(\"azure-identity\")\n\n                try:\n                    importlib.import_module(\"azure.keyvault.secrets\")\n                except ImportError:\n                    missing_deps.append(\"azure-keyvault-secrets\")\n\n                if missing_deps:\n                    deps_str = \", \".join(missing_deps)\n                    msg = (\n                        f\"Azure Key Vault provider requires: {deps_str}. \"\n                        \"Install with: pip install envresolve[azure]\"\n                    )\n                else:\n                    msg = f\"Failed to import Azure Key Vault provider. Error: {e}\"\n                raise ProviderRegistrationError(msg, original_error=e) from e\n\n            provider = provider_class()\n\n        self._providers[\"akv\"] = provider\n        # Reset resolver to pick up new providers\n        self._resolver = None\n\n    def resolve_secret(self, uri: str) -&gt; str:\n        \"\"\"Resolve a secret URI to its value.\n\n        This function supports:\n        - Variable expansion: ${VAR} and $VAR syntax using os.environ\n        - Secret URI resolution: akv:// scheme\n        - Idempotent resolution: Plain strings and non-target URIs pass through\n\n        Args:\n            uri: Secret URI or plain string to resolve\n\n        Returns:\n            Resolved secret value or the original string if not a secret URI\n\n        Raises:\n            URIParseError: If the URI format is invalid\n            SecretResolutionError: If secret resolution fails\n            VariableNotFoundError: If a referenced variable is not found\n            CircularReferenceError: If a circular variable reference is detected\n        \"\"\"\n        resolver = self._get_resolver()\n        return resolver.resolve(uri)\n\n    def resolve_with_env(self, value: str, env: dict[str, str]) -&gt; str:\n        \"\"\"Expand variables and resolve secret URIs with custom environment.\n\n        Args:\n            value: Value to resolve (may contain variables or be a secret URI)\n            env: Environment dict for variable expansion\n\n        Returns:\n            Resolved value\n        \"\"\"\n        resolver = self._get_resolver()\n        return resolver.resolve(value, env)\n\n    def load_env(\n        self,\n        path: str | Path = \".env\",\n        *,\n        export: bool = True,\n        override: bool = False,\n    ) -&gt; dict[str, str]:\n        \"\"\"Load environment variables from a .env file and resolve secret URIs.\n\n        This function:\n        1. Loads variables from the .env file\n        2. Expands variable references within values\n        3. Resolves secret URIs (akv://) to actual secret values\n        4. Optionally exports to os.environ\n\n        Args:\n            path: Path to .env file (default: \".env\")\n            export: If True, export resolved variables to os.environ\n            override: If True, override existing os.environ variables\n\n        Returns:\n            Dictionary of resolved environment variables\n\n        Raises:\n            FileNotFoundError: If the .env file doesn't exist\n            URIParseError: If a URI format is invalid\n            SecretResolutionError: If secret resolution fails\n            VariableNotFoundError: If a referenced variable is not found\n            CircularReferenceError: If a circular variable reference is detected\n        \"\"\"\n        # Load .env file\n        env_dict = {k: v for k, v in dotenv_values(path).items() if v is not None}\n\n        # Build complete environment (for variable expansion)\n        complete_env = dict(os.environ)\n        complete_env.update(env_dict)\n\n        # Resolve each variable\n        resolved: dict[str, str] = {}\n        for key, value in env_dict.items():\n            resolved[key] = self.resolve_with_env(value, complete_env)\n\n        # Export to os.environ if requested\n        if export:\n            for key, value in resolved.items():\n                if override or key not in os.environ:\n                    os.environ[key] = value\n\n        return resolved\n\n    def resolve_os_environ(\n        self,\n        keys: list[str] | None = None,\n        prefix: str | None = None,\n        *,\n        overwrite: bool = True,\n        stop_on_error: bool = True,\n    ) -&gt; dict[str, str]:\n        \"\"\"Resolve secret URIs in os.environ.\n\n        Args:\n            keys: List of specific keys to resolve. If None, scan all keys.\n                Mutually exclusive with prefix.\n            prefix: Only process keys with this prefix, strip prefix from output.\n                Mutually exclusive with keys.\n            overwrite: If True, update os.environ with resolved values.\n            stop_on_error: If False, continue on secret resolution errors\n                (e.g., SecretResolutionError), skipping the failed key. Other\n                unexpected errors will still be raised.\n\n        Returns:\n            Dictionary of resolved values\n\n        Raises:\n            MutuallyExclusiveArgumentsError: If both keys and prefix are specified\n        \"\"\"\n        # Check mutually exclusive arguments\n        if keys is not None and prefix is not None:\n            arg1 = \"keys\"\n            arg2 = \"prefix\"\n            raise MutuallyExclusiveArgumentsError(arg1, arg2)\n\n        # Determine which keys to process\n        if keys is not None:\n            keys_to_process = keys\n        elif prefix is not None:\n            keys_to_process = [k for k in os.environ if k.startswith(prefix)]\n        else:\n            keys_to_process = list(os.environ)\n\n        # Resolve each key\n        resolved: dict[str, str] = {}\n        for key in keys_to_process:\n            if key not in os.environ:\n                continue\n\n            value = os.environ[key]\n\n            # Resolve the value\n            try:\n                resolved_value = self.resolve_with_env(value, dict(os.environ))\n            except EnvResolveError:\n                if stop_on_error:\n                    raise\n                # Skip this key on error\n                continue\n\n            # Determine output key (strip prefix if specified)\n            output_key = (\n                key[len(prefix) :] if prefix and key.startswith(prefix) else key\n            )\n\n            resolved[output_key] = resolved_value\n\n            # Update os.environ if requested\n            if overwrite:\n                os.environ[output_key] = resolved_value\n                # If prefix stripping occurred, remove the old key\n                if prefix and key.startswith(prefix) and output_key != key:\n                    del os.environ[key]\n\n        return resolved\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize an empty provider registry.</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty provider registry.\"\"\"\n    self._providers: dict[str, SecretProvider] = {}\n    self._resolver: SecretResolver | None = None\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.register_azure_kv_provider","title":"register_azure_kv_provider","text":"<pre><code>register_azure_kv_provider(\n    provider: SecretProvider | None = None,\n) -&gt; None\n</code></pre> <p>Register Azure Key Vault provider for akv:// scheme.</p> <p>This method is safe to call multiple times (idempotent).</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>SecretProvider | None</code> <p>Optional custom provider. If None, uses default AzureKVProvider.</p> <code>None</code> <p>Raises:</p> Type Description <code>ProviderRegistrationError</code> <p>If azure-identity or azure-keyvault-secrets is not installed (only when provider is None)</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def register_azure_kv_provider(\n    self, provider: \"SecretProvider | None\" = None\n) -&gt; None:\n    \"\"\"Register Azure Key Vault provider for akv:// scheme.\n\n    This method is safe to call multiple times (idempotent).\n\n    Args:\n        provider: Optional custom provider. If None, uses default AzureKVProvider.\n\n    Raises:\n        ProviderRegistrationError: If azure-identity or azure-keyvault-secrets\n            is not installed (only when provider is None)\n    \"\"\"\n    if provider is None:\n        try:\n            # Dynamically import the provider module\n            provider_module = importlib.import_module(\n                \"envresolve.providers.azure_kv\"\n            )\n            provider_class = provider_module.AzureKVProvider\n        except ImportError as e:\n            # Check which dependency is missing\n            missing_deps: list[str] = []\n            try:\n                importlib.import_module(\"azure.identity\")\n            except ImportError:\n                missing_deps.append(\"azure-identity\")\n\n            try:\n                importlib.import_module(\"azure.keyvault.secrets\")\n            except ImportError:\n                missing_deps.append(\"azure-keyvault-secrets\")\n\n            if missing_deps:\n                deps_str = \", \".join(missing_deps)\n                msg = (\n                    f\"Azure Key Vault provider requires: {deps_str}. \"\n                    \"Install with: pip install envresolve[azure]\"\n                )\n            else:\n                msg = f\"Failed to import Azure Key Vault provider. Error: {e}\"\n            raise ProviderRegistrationError(msg, original_error=e) from e\n\n        provider = provider_class()\n\n    self._providers[\"akv\"] = provider\n    # Reset resolver to pick up new providers\n    self._resolver = None\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.resolve_secret","title":"resolve_secret","text":"<pre><code>resolve_secret(uri: str) -&gt; str\n</code></pre> <p>Resolve a secret URI to its value.</p> <p>This function supports: - Variable expansion: ${VAR} and $VAR syntax using os.environ - Secret URI resolution: akv:// scheme - Idempotent resolution: Plain strings and non-target URIs pass through</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Secret URI or plain string to resolve</p> required <p>Returns:</p> Type Description <code>str</code> <p>Resolved secret value or the original string if not a secret URI</p> <p>Raises:</p> Type Description <code>URIParseError</code> <p>If the URI format is invalid</p> <code>SecretResolutionError</code> <p>If secret resolution fails</p> <code>VariableNotFoundError</code> <p>If a referenced variable is not found</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def resolve_secret(self, uri: str) -&gt; str:\n    \"\"\"Resolve a secret URI to its value.\n\n    This function supports:\n    - Variable expansion: ${VAR} and $VAR syntax using os.environ\n    - Secret URI resolution: akv:// scheme\n    - Idempotent resolution: Plain strings and non-target URIs pass through\n\n    Args:\n        uri: Secret URI or plain string to resolve\n\n    Returns:\n        Resolved secret value or the original string if not a secret URI\n\n    Raises:\n        URIParseError: If the URI format is invalid\n        SecretResolutionError: If secret resolution fails\n        VariableNotFoundError: If a referenced variable is not found\n        CircularReferenceError: If a circular variable reference is detected\n    \"\"\"\n    resolver = self._get_resolver()\n    return resolver.resolve(uri)\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.resolve_with_env","title":"resolve_with_env","text":"<pre><code>resolve_with_env(value: str, env: dict[str, str]) -&gt; str\n</code></pre> <p>Expand variables and resolve secret URIs with custom environment.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Value to resolve (may contain variables or be a secret URI)</p> required <code>env</code> <code>dict[str, str]</code> <p>Environment dict for variable expansion</p> required <p>Returns:</p> Type Description <code>str</code> <p>Resolved value</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def resolve_with_env(self, value: str, env: dict[str, str]) -&gt; str:\n    \"\"\"Expand variables and resolve secret URIs with custom environment.\n\n    Args:\n        value: Value to resolve (may contain variables or be a secret URI)\n        env: Environment dict for variable expansion\n\n    Returns:\n        Resolved value\n    \"\"\"\n    resolver = self._get_resolver()\n    return resolver.resolve(value, env)\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.load_env","title":"load_env","text":"<pre><code>load_env(\n    path: str | Path = \".env\",\n    *,\n    export: bool = True,\n    override: bool = False,\n) -&gt; dict[str, str]\n</code></pre> <p>Load environment variables from a .env file and resolve secret URIs.</p> <p>This function: 1. Loads variables from the .env file 2. Expands variable references within values 3. Resolves secret URIs (akv://) to actual secret values 4. Optionally exports to os.environ</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to .env file (default: \".env\")</p> <code>'.env'</code> <code>export</code> <code>bool</code> <p>If True, export resolved variables to os.environ</p> <code>True</code> <code>override</code> <code>bool</code> <p>If True, override existing os.environ variables</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of resolved environment variables</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the .env file doesn't exist</p> <code>URIParseError</code> <p>If a URI format is invalid</p> <code>SecretResolutionError</code> <p>If secret resolution fails</p> <code>VariableNotFoundError</code> <p>If a referenced variable is not found</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def load_env(\n    self,\n    path: str | Path = \".env\",\n    *,\n    export: bool = True,\n    override: bool = False,\n) -&gt; dict[str, str]:\n    \"\"\"Load environment variables from a .env file and resolve secret URIs.\n\n    This function:\n    1. Loads variables from the .env file\n    2. Expands variable references within values\n    3. Resolves secret URIs (akv://) to actual secret values\n    4. Optionally exports to os.environ\n\n    Args:\n        path: Path to .env file (default: \".env\")\n        export: If True, export resolved variables to os.environ\n        override: If True, override existing os.environ variables\n\n    Returns:\n        Dictionary of resolved environment variables\n\n    Raises:\n        FileNotFoundError: If the .env file doesn't exist\n        URIParseError: If a URI format is invalid\n        SecretResolutionError: If secret resolution fails\n        VariableNotFoundError: If a referenced variable is not found\n        CircularReferenceError: If a circular variable reference is detected\n    \"\"\"\n    # Load .env file\n    env_dict = {k: v for k, v in dotenv_values(path).items() if v is not None}\n\n    # Build complete environment (for variable expansion)\n    complete_env = dict(os.environ)\n    complete_env.update(env_dict)\n\n    # Resolve each variable\n    resolved: dict[str, str] = {}\n    for key, value in env_dict.items():\n        resolved[key] = self.resolve_with_env(value, complete_env)\n\n    # Export to os.environ if requested\n    if export:\n        for key, value in resolved.items():\n            if override or key not in os.environ:\n                os.environ[key] = value\n\n    return resolved\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.resolve_os_environ","title":"resolve_os_environ","text":"<pre><code>resolve_os_environ(\n    keys: list[str] | None = None,\n    prefix: str | None = None,\n    *,\n    overwrite: bool = True,\n    stop_on_error: bool = True,\n) -&gt; dict[str, str]\n</code></pre> <p>Resolve secret URIs in os.environ.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str] | None</code> <p>List of specific keys to resolve. If None, scan all keys. Mutually exclusive with prefix.</p> <code>None</code> <code>prefix</code> <code>str | None</code> <p>Only process keys with this prefix, strip prefix from output. Mutually exclusive with keys.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>If True, update os.environ with resolved values.</p> <code>True</code> <code>stop_on_error</code> <code>bool</code> <p>If False, continue on secret resolution errors (e.g., SecretResolutionError), skipping the failed key. Other unexpected errors will still be raised.</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of resolved values</p> <p>Raises:</p> Type Description <code>MutuallyExclusiveArgumentsError</code> <p>If both keys and prefix are specified</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def resolve_os_environ(\n    self,\n    keys: list[str] | None = None,\n    prefix: str | None = None,\n    *,\n    overwrite: bool = True,\n    stop_on_error: bool = True,\n) -&gt; dict[str, str]:\n    \"\"\"Resolve secret URIs in os.environ.\n\n    Args:\n        keys: List of specific keys to resolve. If None, scan all keys.\n            Mutually exclusive with prefix.\n        prefix: Only process keys with this prefix, strip prefix from output.\n            Mutually exclusive with keys.\n        overwrite: If True, update os.environ with resolved values.\n        stop_on_error: If False, continue on secret resolution errors\n            (e.g., SecretResolutionError), skipping the failed key. Other\n            unexpected errors will still be raised.\n\n    Returns:\n        Dictionary of resolved values\n\n    Raises:\n        MutuallyExclusiveArgumentsError: If both keys and prefix are specified\n    \"\"\"\n    # Check mutually exclusive arguments\n    if keys is not None and prefix is not None:\n        arg1 = \"keys\"\n        arg2 = \"prefix\"\n        raise MutuallyExclusiveArgumentsError(arg1, arg2)\n\n    # Determine which keys to process\n    if keys is not None:\n        keys_to_process = keys\n    elif prefix is not None:\n        keys_to_process = [k for k in os.environ if k.startswith(prefix)]\n    else:\n        keys_to_process = list(os.environ)\n\n    # Resolve each key\n    resolved: dict[str, str] = {}\n    for key in keys_to_process:\n        if key not in os.environ:\n            continue\n\n        value = os.environ[key]\n\n        # Resolve the value\n        try:\n            resolved_value = self.resolve_with_env(value, dict(os.environ))\n        except EnvResolveError:\n            if stop_on_error:\n                raise\n            # Skip this key on error\n            continue\n\n        # Determine output key (strip prefix if specified)\n        output_key = (\n            key[len(prefix) :] if prefix and key.startswith(prefix) else key\n        )\n\n        resolved[output_key] = resolved_value\n\n        # Update os.environ if requested\n        if overwrite:\n            os.environ[output_key] = resolved_value\n            # If prefix stripping occurred, remove the old key\n            if prefix and key.startswith(prefix) and output_key != key:\n                del os.environ[key]\n\n    return resolved\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.register_azure_kv_provider","title":"register_azure_kv_provider","text":"<pre><code>register_azure_kv_provider(\n    provider: SecretProvider | None = None,\n) -&gt; None\n</code></pre> <p>Register Azure Key Vault provider for akv:// scheme.</p> <p>This function should be called before attempting to resolve secrets from Azure Key Vault. It is safe to call multiple times (idempotent).</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>SecretProvider | None</code> <p>Optional custom provider. If None, uses default AzureKVProvider.</p> <code>None</code> <p>Raises:</p> Type Description <code>ProviderRegistrationError</code> <p>If azure-identity or azure-keyvault-secrets is not installed (only when provider is None)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import envresolve\n&gt;&gt;&gt; # Default behavior\n&gt;&gt;&gt; envresolve.register_azure_kv_provider()\n&gt;&gt;&gt; # Custom provider (requires Azure SDK imports)\n&gt;&gt;&gt; # from envresolve.providers.azure_kv import AzureKVProvider\n&gt;&gt;&gt; # from azure.identity import ManagedIdentityCredential\n&gt;&gt;&gt; # custom = AzureKVProvider(credential=ManagedIdentityCredential())\n&gt;&gt;&gt; # envresolve.register_azure_kv_provider(provider=custom)\n&gt;&gt;&gt; # Now you can resolve secrets (requires Azure authentication)\n&gt;&gt;&gt; # secret = envresolve.resolve_secret(\"akv://my-vault/db-password\")\n</code></pre> Source code in <code>src/envresolve/api.py</code> <pre><code>def register_azure_kv_provider(provider: \"SecretProvider | None\" = None) -&gt; None:\n    \"\"\"Register Azure Key Vault provider for akv:// scheme.\n\n    This function should be called before attempting to resolve secrets\n    from Azure Key Vault. It is safe to call multiple times (idempotent).\n\n    Args:\n        provider: Optional custom provider. If None, uses default AzureKVProvider.\n\n    Raises:\n        ProviderRegistrationError: If azure-identity or azure-keyvault-secrets\n            is not installed (only when provider is None)\n\n    Examples:\n        &gt;&gt;&gt; import envresolve\n        &gt;&gt;&gt; # Default behavior\n        &gt;&gt;&gt; envresolve.register_azure_kv_provider()\n        &gt;&gt;&gt; # Custom provider (requires Azure SDK imports)\n        &gt;&gt;&gt; # from envresolve.providers.azure_kv import AzureKVProvider\n        &gt;&gt;&gt; # from azure.identity import ManagedIdentityCredential\n        &gt;&gt;&gt; # custom = AzureKVProvider(credential=ManagedIdentityCredential())\n        &gt;&gt;&gt; # envresolve.register_azure_kv_provider(provider=custom)\n        &gt;&gt;&gt; # Now you can resolve secrets (requires Azure authentication)\n        &gt;&gt;&gt; # secret = envresolve.resolve_secret(\"akv://my-vault/db-password\")\n    \"\"\"\n    _default_resolver.register_azure_kv_provider(provider=provider)\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.resolve_secret","title":"resolve_secret","text":"<pre><code>resolve_secret(uri: str) -&gt; str\n</code></pre> <p>Resolve a secret URI to its value.</p> <p>This function supports: - Variable expansion: ${VAR} and $VAR syntax using os.environ - Secret URI resolution: akv:// scheme - Idempotent resolution: Plain strings and non-target URIs pass through unchanged</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Secret URI or plain string to resolve</p> required <p>Returns:</p> Type Description <code>str</code> <p>Resolved secret value or the original string if not a secret URI</p> <p>Raises:</p> Type Description <code>URIParseError</code> <p>If the URI format is invalid</p> <code>SecretResolutionError</code> <p>If secret resolution fails</p> <code>VariableNotFoundError</code> <p>If a referenced variable is not found</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import envresolve\n&gt;&gt;&gt; # Idempotent - plain strings pass through\n&gt;&gt;&gt; value = envresolve.resolve_secret(\"just-a-string\")\n&gt;&gt;&gt; value\n'just-a-string'\n&gt;&gt;&gt; # Non-target URIs pass through unchanged\n&gt;&gt;&gt; uri = envresolve.resolve_secret(\"postgres://localhost/db\")\n&gt;&gt;&gt; uri\n'postgres://localhost/db'\n&gt;&gt;&gt; # Secret URIs require provider registration and authentication\n&gt;&gt;&gt; # envresolve.register_azure_kv_provider()\n&gt;&gt;&gt; # secret = envresolve.resolve_secret(\"akv://my-vault/db-password\")\n</code></pre> Source code in <code>src/envresolve/api.py</code> <pre><code>def resolve_secret(uri: str) -&gt; str:\n    \"\"\"Resolve a secret URI to its value.\n\n    This function supports:\n    - Variable expansion: ${VAR} and $VAR syntax using os.environ\n    - Secret URI resolution: akv:// scheme\n    - Idempotent resolution: Plain strings and non-target URIs pass through unchanged\n\n    Args:\n        uri: Secret URI or plain string to resolve\n\n    Returns:\n        Resolved secret value or the original string if not a secret URI\n\n    Raises:\n        URIParseError: If the URI format is invalid\n        SecretResolutionError: If secret resolution fails\n        VariableNotFoundError: If a referenced variable is not found\n        CircularReferenceError: If a circular variable reference is detected\n\n    Examples:\n        &gt;&gt;&gt; import envresolve\n        &gt;&gt;&gt; # Idempotent - plain strings pass through\n        &gt;&gt;&gt; value = envresolve.resolve_secret(\"just-a-string\")\n        &gt;&gt;&gt; value\n        'just-a-string'\n        &gt;&gt;&gt; # Non-target URIs pass through unchanged\n        &gt;&gt;&gt; uri = envresolve.resolve_secret(\"postgres://localhost/db\")\n        &gt;&gt;&gt; uri\n        'postgres://localhost/db'\n        &gt;&gt;&gt; # Secret URIs require provider registration and authentication\n        &gt;&gt;&gt; # envresolve.register_azure_kv_provider()\n        &gt;&gt;&gt; # secret = envresolve.resolve_secret(\"akv://my-vault/db-password\")\n    \"\"\"\n    return _default_resolver.resolve_secret(uri)\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.load_env","title":"load_env","text":"<pre><code>load_env(\n    path: str | Path = \".env\",\n    *,\n    export: bool = True,\n    override: bool = False,\n) -&gt; dict[str, str]\n</code></pre> <p>Load environment variables from a .env file and resolve secret URIs.</p> <p>This function: 1. Loads variables from the .env file 2. Expands variable references within values 3. Resolves secret URIs (akv://) to actual secret values 4. Optionally exports to os.environ</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Path to .env file (default: \".env\")</p> <code>'.env'</code> <code>export</code> <code>bool</code> <p>If True, export resolved variables to os.environ (default: True)</p> <code>True</code> <code>override</code> <code>bool</code> <p>If True, override existing os.environ variables (default: False)</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of resolved environment variables</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the .env file doesn't exist</p> <code>URIParseError</code> <p>If a URI format is invalid</p> <code>SecretResolutionError</code> <p>If secret resolution fails</p> <code>VariableNotFoundError</code> <p>If a referenced variable is not found</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import envresolve\n&gt;&gt;&gt; envresolve.register_azure_kv_provider()\n&gt;&gt;&gt; # Load and export to os.environ\n&gt;&gt;&gt; resolved = envresolve.load_env(\".env\", export=True)\n&gt;&gt;&gt; # Load without exporting\n&gt;&gt;&gt; resolved = envresolve.load_env(\".env\", export=False)\n</code></pre> Source code in <code>src/envresolve/api.py</code> <pre><code>def load_env(\n    path: str | Path = \".env\",\n    *,\n    export: bool = True,\n    override: bool = False,\n) -&gt; dict[str, str]:\n    \"\"\"Load environment variables from a .env file and resolve secret URIs.\n\n    This function:\n    1. Loads variables from the .env file\n    2. Expands variable references within values\n    3. Resolves secret URIs (akv://) to actual secret values\n    4. Optionally exports to os.environ\n\n    Args:\n        path: Path to .env file (default: \".env\")\n        export: If True, export resolved variables to os.environ (default: True)\n        override: If True, override existing os.environ variables (default: False)\n\n    Returns:\n        Dictionary of resolved environment variables\n\n    Raises:\n        FileNotFoundError: If the .env file doesn't exist\n        URIParseError: If a URI format is invalid\n        SecretResolutionError: If secret resolution fails\n        VariableNotFoundError: If a referenced variable is not found\n        CircularReferenceError: If a circular variable reference is detected\n\n    Examples:\n        &gt;&gt;&gt; import envresolve\n        &gt;&gt;&gt; envresolve.register_azure_kv_provider()\n        &gt;&gt;&gt; # Load and export to os.environ\n        &gt;&gt;&gt; resolved = envresolve.load_env(\".env\", export=True)  # doctest: +SKIP\n        &gt;&gt;&gt; # Load without exporting\n        &gt;&gt;&gt; resolved = envresolve.load_env(\".env\", export=False)  # doctest: +SKIP\n    \"\"\"\n    return _default_resolver.load_env(path, export=export, override=override)\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.resolve_os_environ","title":"resolve_os_environ","text":"<pre><code>resolve_os_environ(\n    keys: list[str] | None = None,\n    prefix: str | None = None,\n    *,\n    overwrite: bool = True,\n    stop_on_error: bool = True,\n) -&gt; dict[str, str]\n</code></pre> <p>Resolve secret URIs in os.environ.</p> <p>This function resolves secret URIs that are already set in environment variables, useful when values are passed from parent shells or container orchestrators.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str] | None</code> <p>List of specific keys to resolve. If None, scan all keys. Mutually exclusive with prefix.</p> <code>None</code> <code>prefix</code> <code>str | None</code> <p>Only process keys with this prefix, strip prefix from output. Mutually exclusive with keys.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>If True, update os.environ with resolved values (default: True).</p> <code>True</code> <code>stop_on_error</code> <code>bool</code> <p>If False, continue on secret resolution errors (e.g., SecretResolutionError), skipping the failed key. Other unexpected errors will still be raised (default: True).</p> <code>True</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of resolved values</p> <p>Raises:</p> Type Description <code>MutuallyExclusiveArgumentsError</code> <p>If both keys and prefix are specified</p> <code>URIParseError</code> <p>If the URI format is invalid</p> <code>SecretResolutionError</code> <p>If secret resolution fails (when stop_on_error=True)</p> <code>VariableNotFoundError</code> <p>If a referenced variable is not found</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import envresolve\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; envresolve.register_azure_kv_provider()\n&gt;&gt;&gt; # Resolve all environment variables\n&gt;&gt;&gt; resolved = envresolve.resolve_os_environ()\n&gt;&gt;&gt; # Resolve specific keys only\n&gt;&gt;&gt; resolved = envresolve.resolve_os_environ(keys=[\"API_KEY\"])\n</code></pre> Source code in <code>src/envresolve/api.py</code> <pre><code>def resolve_os_environ(\n    keys: list[str] | None = None,\n    prefix: str | None = None,\n    *,\n    overwrite: bool = True,\n    stop_on_error: bool = True,\n) -&gt; dict[str, str]:\n    \"\"\"Resolve secret URIs in os.environ.\n\n    This function resolves secret URIs that are already set in environment variables,\n    useful when values are passed from parent shells or container orchestrators.\n\n    Args:\n        keys: List of specific keys to resolve. If None, scan all keys.\n            Mutually exclusive with prefix.\n        prefix: Only process keys with this prefix, strip prefix from output.\n            Mutually exclusive with keys.\n        overwrite: If True, update os.environ with resolved values (default: True).\n        stop_on_error: If False, continue on secret resolution errors\n            (e.g., SecretResolutionError), skipping the failed key. Other\n            unexpected errors will still be raised (default: True).\n\n    Returns:\n        Dictionary of resolved values\n\n    Raises:\n        MutuallyExclusiveArgumentsError: If both keys and prefix are specified\n        URIParseError: If the URI format is invalid\n        SecretResolutionError: If secret resolution fails (when stop_on_error=True)\n        VariableNotFoundError: If a referenced variable is not found\n        CircularReferenceError: If a circular variable reference is detected\n\n    Examples:\n        &gt;&gt;&gt; import envresolve\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; envresolve.register_azure_kv_provider()\n        &gt;&gt;&gt; # Resolve all environment variables\n        &gt;&gt;&gt; resolved = envresolve.resolve_os_environ()  # doctest: +SKIP\n        &gt;&gt;&gt; # Resolve specific keys only\n        &gt;&gt;&gt; resolved = envresolve.resolve_os_environ(keys=[\"API_KEY\"])  # doctest: +SKIP\n    \"\"\"\n    return _default_resolver.resolve_os_environ(\n        keys=keys,\n        prefix=prefix,\n        overwrite=overwrite,\n        stop_on_error=stop_on_error,\n    )\n</code></pre>"},{"location":"architecture/adr/","title":"Architecture Decision Records (ADRs)","text":"<p>This page provides an overview of all architectural decisions made for envresolve.</p>"},{"location":"architecture/adr/#what-are-adrs","title":"What are ADRs?","text":"<p>Architecture Decision Records document important architectural decisions along with their context and consequences. They help track the \"why\" behind design choices.</p>"},{"location":"architecture/adr/#current-adrs","title":"Current ADRs","text":""},{"location":"architecture/adr/#adr-0001-variable-expansion-with-regular-expressions","title":"ADR 0001: Variable Expansion with Regular Expressions","text":"<p>Status: Accepted Date: 2025-10-11</p> <p>Decided to use regular expressions for variable expansion instead of manual string parsing.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0002-custom-exception-hierarchy","title":"ADR 0002: Custom Exception Hierarchy","text":"<p>Status: Accepted Date: 2025-10-11</p> <p>Established a custom exception hierarchy with base exceptions for better error handling.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0003-structured-exception-design","title":"ADR 0003: Structured Exception Design","text":"<p>Status: Accepted Date: 2025-10-11</p> <p>Defined structured exception design for variable expansion errors.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0004-stateless-function-based-variable-expansion","title":"ADR 0004: Stateless Function-Based Variable Expansion","text":"<p>Status: Accepted Date: 2025-10-11</p> <p>Chose a stateless function (<code>expand_variables()</code>) as the core API with convenience wrapper classes.</p> <p>Key Decision: Use <code>expand_variables(text, env)</code> instead of a stateful <code>VariableExpander(env)</code> class.</p> <p>Rationale:</p> <ul> <li>Simpler and more explicit</li> <li>No hidden state</li> <li>Better for testing</li> <li>More Pythonic for stateless operations</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0005-string-based-api-with-idempotent-resolution","title":"ADR 0005: String-Based API with Idempotent Resolution","text":"<p>Status: Accepted Date: 2025-10-12</p> <p>Decided to use a string-based API instead of data models for resolution results.</p> <p>Key Decision: Return <code>str</code> directly instead of <code>ResolutionResult</code> models.</p> <p>Rationale:</p> <ul> <li>Users ultimately need strings for <code>os.environ</code></li> <li>Zero conversion overhead</li> <li>Infrastructure utilities should be transparent</li> <li>Idempotent resolution is safer and more composable</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0006-nested-variable-expansion-implementation","title":"ADR 0006: Nested Variable Expansion Implementation","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Chose a two-phase iterative algorithm for supporting nested variable expansion like <code>${VAR_${NESTED}}</code>.</p> <p>Key Decision: Expand innermost curly braces first, then simple variables, iterating until stable.</p> <p>Rationale:</p> <ul> <li>Correct inside-out evaluation order</li> <li>Predictable behavior for complex nesting</li> <li>No recursion depth limits</li> <li>Clear error detection</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0007-layer-separation-services-vs-application","title":"ADR 0007: Layer Separation (Services vs Application)","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Separated pure business logic (services layer) from environment integration (application layer).</p> <p>Key Decision: Move <code>EnvExpander</code> and <code>DotEnvExpander</code> from <code>services/expansion.py</code> to <code>application/expanders.py</code>.</p> <p>Rationale:</p> <ul> <li>Single Responsibility Principle</li> <li>Better testability (pure logic without I/O)</li> <li>Clear dependency direction</li> <li>Matches clean architecture patterns</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0008-circular-reference-chain-tracking","title":"ADR 0008: Circular Reference Chain Tracking","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Extended <code>CircularReferenceError</code> to include full reference chain for better debugging.</p> <p>Key Decision: Add <code>chain: list[str]</code> attribute showing complete cycle (e.g., <code>[\"A\", \"B\", \"C\", \"A\"]</code>).</p> <p>Rationale:</p> <ul> <li>Immediate visibility of complete cycle</li> <li>Better debugging experience</li> <li>Programmatic access to cycle information</li> <li>Actionable error messages</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0009-manual-provider-registration-pattern","title":"ADR 0009: Manual Provider Registration Pattern","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Established manual provider registration with a global registry instead of auto-discovery or dependency injection.</p> <p>Key Decision: Users explicitly call <code>register_azure_kv_provider()</code> before resolving secrets. Providers are stored in a module-level singleton registry.</p> <p>Rationale:</p> <ul> <li>Opt-in dependencies (only load what you need)</li> <li>Explicit control over initialization timing</li> <li>Resource efficiency through singleton providers</li> <li>Clear API surface</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0010-iterative-uri-resolution","title":"ADR 0010: Iterative URI Resolution","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Implemented iterative resolution with cycle detection to support URI-to-URI resolution chains.</p> <p>Key Decision: Use a <code>while</code> loop with a <code>seen</code> set to resolve URIs iteratively until a stable value is reached or a cycle is detected.</p> <p>Rationale:</p> <ul> <li>Supports arbitrary nesting depth</li> <li>Maintains idempotency (plain strings pass through)</li> <li>Safe cycle detection without infinite loops</li> <li>Flexible for mixed variable/URI resolution</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0011-conditional-doctest-skip","title":"ADR 0011: Conditional Doctest Skip","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Implemented pytest fixture-based conditional skipping for doctests that require optional dependencies.</p> <p>Key Decision: Use autouse fixture in <code>conftest.py</code> to detect Azure SDK availability and skip Azure-related doctests when dependencies are missing.</p> <p>Rationale:</p> <ul> <li>Doctests validate documentation when dependencies are present</li> <li>Graceful degradation without Azure SDK</li> <li>Consistent with pytest marker strategy</li> <li>Avoids manual <code>+SKIP</code> directives</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0012-pytest-markers-for-azure-dependencies","title":"ADR 0012: Pytest Markers for Azure Dependencies","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Introduced dedicated pytest marker (<code>azure</code>) to isolate tests requiring optional Azure SDK dependencies.</p> <p>Key Decision: Mark Azure-dependent tests with <code>@pytest.mark.azure</code> and provide <code>tests_without_azure</code> Nox session that excludes them.</p> <p>Rationale:</p> <ul> <li>Core test suite runs without optional dependencies</li> <li>Clear signal for which tests require Azure</li> <li>CI can run lightweight and full test suites separately</li> <li>Minimal disruption for contributors</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0013-class-based-api-design","title":"ADR 0013: Class-Based API Design","text":"<p>Status: Accepted Date: 2025-10-14</p> <p>Encapsulated resolution state in <code>EnvResolver</code> class with module-level facade for backward compatibility.</p> <p>Key Decision: Introduce <code>EnvResolver</code> class that encapsulates provider registry and resolver instance, expose singleton instance through module-level functions.</p> <p>Rationale:</p> <ul> <li>Eliminates <code>global</code> keyword usage</li> <li>Better testability (tests can instantiate isolated resolvers)</li> <li>Maintains simple module-level API</li> <li>Supports multiple resolver instances if needed</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0014-importlib-lazy-import","title":"ADR 0014: Importlib Lazy Import","text":"<p>Status: Accepted Date: 2025-10-14</p> <p>Used <code>importlib.import_module</code> for lazy loading of optional Azure SDK dependencies with rich error messages.</p> <p>Key Decision: Defer Azure SDK imports until <code>register_azure_kv_provider()</code> is called, and raise <code>ProviderRegistrationError</code> (not <code>ImportError</code>) with helpful installation instructions when dependencies are missing.</p> <p>Rationale:</p> <ul> <li>Users can import envresolve without Azure SDK</li> <li>Clear, actionable error messages</li> <li>Aligns with custom exception hierarchy (ADR-0002)</li> <li>Extensible pattern for future optional providers</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0015-manage-azure-live-test-infrastructure-with-terraform","title":"ADR 0015: Manage Azure Live Test Infrastructure with Terraform","text":"<p>Status: Accepted Date: 2025-10-15</p> <p>Standardized live Azure Key Vault testing with Terraform-managed resources and explicit pytest gating.</p> <p>Key Decision: Use Terraform manifests in <code>infra/terraform</code> plus helper Nox sessions to provision/destroy a Key Vault and sample secret for live tests.</p> <p>Rationale:</p> <ul> <li>Repeatable provisioning for contributors and CI</li> <li>Clear separation between mocked and live suites via markers</li> <li>Easier cleanup through scripted Terraform destroy</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0016-typeerror-based-custom-exception-for-mutually-exclusive-parameters","title":"ADR 0016: TypeError-based Custom Exception for Mutually Exclusive Parameters","text":"<p>Status: Accepted Date: 2025-10-18</p> <p>Created <code>MutuallyExclusiveArgumentsError</code> inheriting from both <code>EnvResolveError</code> and <code>TypeError</code> following pandas exception patterns.</p> <p>Key Decision: Raise <code>MutuallyExclusiveArgumentsError</code> when both <code>keys</code> and <code>prefix</code> are specified in <code>resolve_os_environ()</code>.</p> <p>Rationale:</p> <ul> <li>Aligns with Python ecosystem standards (pandas, argparse use <code>TypeError</code>)</li> <li>Maintains domain exception hierarchy while providing standard semantics</li> <li>Fail-fast approach with structured exception data (<code>arg1</code>, <code>arg2</code> attributes)</li> </ul> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-template","title":"ADR Template","text":"<p>All ADRs follow a consistent template defined in ADR 0000: ADR Template.</p>"},{"location":"architecture/adr/#contributing","title":"Contributing","text":"<p>When making significant architectural decisions, please:</p> <ol> <li>Review existing ADRs to ensure consistency</li> <li>Use the ADR template for new decisions</li> <li>Document both what you chose AND what you rejected</li> <li>Include the \"why\" behind your decision</li> </ol>"},{"location":"developer-guide/contributing/","title":"Contributing to envresolve","text":"<p>Thank you for considering contributing to envresolve!</p>"},{"location":"developer-guide/contributing/#development-setup","title":"Development Setup","text":""},{"location":"developer-guide/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>uv package manager</li> <li>Git</li> </ul>"},{"location":"developer-guide/contributing/#setup","title":"Setup","text":"<ol> <li> <p>Fork the repository on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>git clone https://github.com/YOUR-USERNAME/envresolve.git\ncd envresolve\n</code></pre> </li> <li> <p>Add the upstream remote to sync with the main repository:</p> <pre><code>git remote add upstream https://github.com/osoekawaitlab/envresolve.git\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>uv sync\n</code></pre> </li> <li> <p>Run tests to verify setup:</p> <pre><code>nox -s tests\n</code></pre> </li> </ol>"},{"location":"developer-guide/contributing/#development-workflow","title":"Development Workflow","text":"<p>envresolve follows a strict Test-Driven Development (TDD) cycle.</p>"},{"location":"developer-guide/contributing/#running-tests","title":"Running Tests","text":"<pre><code># All tests with coverage\nnox -s tests\n\n# Unit tests only\nnox -s tests_unit\n\n# E2E tests only\nnox -s tests_e2e\n\n# All Python versions\nnox -s tests_all_versions\n</code></pre>"},{"location":"developer-guide/contributing/#code-quality","title":"Code Quality","text":"<pre><code># Type checking\nnox -s mypy\n\n# Linting\nnox -s lint\n\n# Format code\nnox -s format_code\n\n# All quality checks\nnox -s quality\n\n# Everything (tests + quality)\nnox -s check_all\n</code></pre>"},{"location":"developer-guide/contributing/#code-style","title":"Code Style","text":"<ul> <li>Type Hints: Required for all public APIs</li> <li>Docstrings: Google style, required for all public functions/classes</li> <li>Linting: Ruff with \"ALL\" rules (see <code>pyproject.toml</code>)</li> <li>Type Checking: Strict mypy configuration</li> </ul>"},{"location":"developer-guide/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create a new branch from <code>main</code></li> <li>Make your changes following the TDD cycle</li> <li>Ensure all tests pass: <code>nox -s check_all</code></li> <li>Update documentation if needed</li> <li>Write or update ADRs for architectural decisions</li> <li>Submit a pull request with a clear description</li> </ol>"},{"location":"developer-guide/contributing/#pr-checklist","title":"PR Checklist","text":"<ul> <li>[ ] Tests added/updated and passing</li> <li>[ ] Code follows style guidelines (ruff check passes)</li> <li>[ ] Type hints added (mypy passes)</li> <li>[ ] Docstrings added/updated (Google style)</li> <li>[ ] Coverage maintained at 80%+</li> <li>[ ] ADRs written for design decisions</li> <li>[ ] Documentation updated if needed</li> </ul>"},{"location":"developer-guide/contributing/#architecture","title":"Architecture","text":"<p>envresolve follows a layered architecture:</p> <pre><code>Layer 5: api.py (Public API facade)\nLayer 4: application/ (resolver, cache)\nLayer 3: providers/ (factory, registry, implementations)\nLayer 2: services/ (reference, expansion)\nLayer 1: Domain (models, exceptions) + Infrastructure (base, logging)\nLayer 0: External dependencies\n</code></pre> <p>Key Principles:</p> <ul> <li>Higher layers depend on lower layers</li> <li>Lower layers NEVER depend on higher layers</li> <li>Domain layer has NO internal dependencies</li> </ul> <p>See Architecture ADRs for design decisions.</p>"},{"location":"developer-guide/contributing/#documentation","title":"Documentation","text":"<p>Documentation is built with MkDocs Material:</p> <pre><code># Serve documentation locally\nmkdocs serve\n\n# Build documentation\nmkdocs build\n</code></pre>"},{"location":"developer-guide/contributing/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>User Guide: Installation and usage tutorials</li> <li>API Reference: Auto-generated from docstrings (mkdocstrings)</li> <li>Architecture: ADRs and design decisions</li> <li>Contributing: This file</li> </ul>"},{"location":"developer-guide/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Use the GitHub issue tracker to report bugs or request features.</p> <p>When reporting bugs, please include:</p> <ul> <li>Python version</li> <li>envresolve version</li> <li>Minimal code to reproduce</li> <li>Expected vs actual behavior</li> <li>Error messages/stack traces</li> </ul>"},{"location":"developer-guide/contributing/#questions","title":"Questions?","text":"<ul> <li>Check the documentation</li> <li>Review existing issues</li> <li>Open a new issue for questions</li> </ul>"},{"location":"developer-guide/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"developer-guide/contributing/#live-azure-tests","title":"Live Azure Tests","text":"<p>Optional integration tests against real Azure Key Vault infrastructure. Run these tests to validate changes that affect Azure SDK integration or provider implementations.</p> <p>Note: Live tests automatically skip when environment variables are not set (<code>ENVRESOLVE_LIVE_KEY_VAULT_NAME</code>, etc.), so they won't interfere with normal development.</p>"},{"location":"developer-guide/contributing/#one-time-setup","title":"One-Time Setup","text":"<pre><code># 1. Configure terraform (requires Azure subscription and az login)\ncd infra/terraform\ncp terraform.tfvars.example terraform.tfvars\n\n# 2. Edit terraform.tfvars with your values:\n#    - subscription_id, tenant_id, name_prefix\n#    - test_principal_object_id (get your object ID: az ad signed-in-user show --query id -o tsv)\n\n# 3. Create resources\nterraform init\nterraform apply\n\n# 4. Return to project root and set environment variables (per shell session)\ncd ../..\nsource scripts/setup_live_tests.sh\n</code></pre>"},{"location":"developer-guide/contributing/#running-live-tests","title":"Running Live Tests","text":"<pre><code>nox -s tests_live\n</code></pre>"},{"location":"developer-guide/contributing/#cleanup","title":"Cleanup","text":"<p>Resources can be kept for reuse. Destroy only when done:</p> <pre><code>cd infra/terraform\nterraform destroy\n</code></pre>"},{"location":"developer-guide/live-tests/","title":"Live Azure Tests","text":"<p>This project includes optional integration tests that run against a real Azure Key Vault instance. These tests are marked with the <code>live</code> and <code>azure</code> pytest markers.</p>"},{"location":"developer-guide/live-tests/#why-live-tests","title":"Why Live Tests?","text":"<p>While most of the application can be tested using mocked SDKs (E2E tests), live tests provide an extra layer of confidence by verifying the integration with the actual Azure service. This helps catch issues related to authentication, permissions, or unexpected API changes.</p>"},{"location":"developer-guide/live-tests/#setup-instructions","title":"Setup Instructions","text":"<p>Running these tests requires one-time setup using Terraform to provision the necessary Azure resources.</p>"},{"location":"developer-guide/live-tests/#1-install-tools","title":"1. Install Tools","text":"<p>Ensure you have Terraform and the Azure CLI installed.</p>"},{"location":"developer-guide/live-tests/#2-configure-terraform","title":"2. Configure Terraform","text":"<p>Navigate to the Terraform directory:</p> <pre><code>cd infra/terraform\n</code></pre> <p>Create a <code>terraform.tfvars</code> file from the example:</p> <pre><code>cp terraform.tfvars.example terraform.tfvars\n</code></pre> <p>Edit <code>terraform.tfvars</code> and fill in your Azure subscription details and desired resource names.</p>"},{"location":"developer-guide/live-tests/#3-provision-resources","title":"3. Provision Resources","text":"<p>Initialize and apply the Terraform configuration:</p> <pre><code>terraform init\nterraform apply\n</code></pre> <p>This will create an Azure Resource Group, a Key Vault, and a secret to be used for testing.</p>"},{"location":"developer-guide/live-tests/#running-the-tests","title":"Running the Tests","text":""},{"location":"developer-guide/live-tests/#1-authenticate","title":"1. Authenticate","text":"<p>Log in to Azure via the CLI:</p> <pre><code>az login\n</code></pre>"},{"location":"developer-guide/live-tests/#2-set-environment-variables","title":"2. Set Environment Variables","text":"<p>Run the setup script to export the Key Vault details as environment variables for the test runner:</p> <pre><code>source scripts/setup_live_tests.sh\n</code></pre> <p>This script reads the Terraform output and sets <code>AZURE_TENANT_ID</code>, <code>AZURE_CLIENT_ID</code>, etc.</p>"},{"location":"developer-guide/live-tests/#3-execute-tests","title":"3. Execute Tests","text":"<p>Finally, run the live tests using <code>nox</code>:</p> <pre><code>nox -s tests_live\n</code></pre>"},{"location":"developer-guide/live-tests/#cleaning-up","title":"Cleaning Up","text":"<p>To avoid incurring costs, destroy the Azure resources when you are done testing:</p> <pre><code>cd infra/terraform\nterraform destroy\n</code></pre>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":""},{"location":"user-guide/basic-usage/#variable-expansion","title":"Variable Expansion","text":"<p>envresolve supports variable expansion using <code>${VAR}</code> and <code>$VAR</code> syntax.</p>"},{"location":"user-guide/basic-usage/#simple-variable-expansion","title":"Simple Variable Expansion","text":"${VAR} syntax$VAR syntax <pre><code>from envresolve import expand_variables\n\nenv = {\"VAULT_NAME\": \"my-vault\"}\nresult = expand_variables(\"${VAULT_NAME}\", env)\n\nprint(result)  # Output: my-vault\n</code></pre> <pre><code>from envresolve import expand_variables\n\nenv = {\"VAULT_NAME\": \"my-vault\"}\nresult = expand_variables(\"$VAULT_NAME\", env)\n\nprint(result)  # Output: my-vault\n</code></pre>"},{"location":"user-guide/basic-usage/#multiple-variables","title":"Multiple Variables","text":"<p>You can reference multiple variables in a single string:</p> <pre><code>from envresolve import expand_variables\n\nenv = {\n    \"VAULT_NAME\": \"my-vault\",\n    \"SECRET_NAME\": \"db-password\"\n}\nresult = expand_variables(\"akv://${VAULT_NAME}/${SECRET_NAME}\", env)\n\nprint(result)  # Output: akv://my-vault/db-password\n</code></pre>"},{"location":"user-guide/basic-usage/#nested-variable-expansion","title":"Nested Variable Expansion","text":"<p>Variables can reference other variables:</p> <pre><code>from envresolve import expand_variables\n\nenv = {\n    \"ENVIRONMENT\": \"prod\",\n    \"VAULT_NAME\": \"${ENVIRONMENT}-vault\",\n    \"SECRET_URI\": \"akv://${VAULT_NAME}/api-key\"\n}\nresult = expand_variables(env[\"SECRET_URI\"], env)\n\nprint(result)  # Output: akv://prod-vault/api-key\n</code></pre>"},{"location":"user-guide/basic-usage/#using-environment-variables","title":"Using Environment Variables","text":""},{"location":"user-guide/basic-usage/#with-osenviron","title":"With os.environ","text":"<p>Use <code>EnvExpander</code> to expand variables from the current environment:</p> <pre><code>import os\nfrom envresolve import EnvExpander\n\n# Set environment variable\nos.environ[\"VAULT_NAME\"] = \"production-vault\"\n\nexpander = EnvExpander()\nresult = expander.expand(\"akv://${VAULT_NAME}/secret\")\n\nprint(result)  # Output: akv://production-vault/secret\n</code></pre> <p>Snapshot Behavior</p> <p><code>EnvExpander</code> takes a snapshot of <code>os.environ</code> at initialization time. Changes to environment variables after initialization won't be reflected.</p>"},{"location":"user-guide/basic-usage/#with-env-files","title":"With .env Files","text":"<p>Use <code>DotEnvExpander</code> to expand variables from a <code>.env</code> file:</p> <pre><code>from envresolve import DotEnvExpander\n\n# Contents of .env:\n# VAULT_NAME=my-company-vault\n# DB_PASSWORD=akv://${VAULT_NAME}/db-password\n# API_KEY=akv://${VAULT_NAME}/api-key\n\nexpander = DotEnvExpander(\".env\")\ndb_password_uri = expander.expand(\"${DB_PASSWORD}\")\napi_key_uri = expander.expand(\"${API_KEY}\")\n\nprint(db_password_uri)  # Output: akv://my-company-vault/db-password\nprint(api_key_uri)      # Output: akv://my-company-vault/api-key\n</code></pre>"},{"location":"user-guide/basic-usage/#secret-resolution","title":"Secret Resolution","text":"<p>envresolve can resolve secrets referenced with <code>akv://</code> URIs. Provider registration is explicit so you only pay the dependency cost when you opt in.</p>"},{"location":"user-guide/basic-usage/#1-install-the-azure-extra-once-per-environment","title":"1. Install the Azure extra (once per environment)","text":"<pre><code>pip install envresolve[azure]\n</code></pre>"},{"location":"user-guide/basic-usage/#2-register-the-provider","title":"2. Register the provider","text":"<pre><code>import envresolve\n\nenvresolve.register_azure_kv_provider()\n</code></pre> <p><code>register_azure_kv_provider()</code> is idempotent\u2014you can call it during application startup without worrying about duplicate work.</p>"},{"location":"user-guide/basic-usage/#3-resolve-a-secret-uri","title":"3. Resolve a secret URI","text":"<pre><code>import envresolve\n\nenvresolve.register_azure_kv_provider()\n\n# Plain strings are returned unchanged (idempotent behaviour)\nprint(envresolve.resolve_secret(\"db-password\"))  # db-password\n\n# Secret URIs fetch values from Azure Key Vault\npassword = envresolve.resolve_secret(\"akv://corp-vault/db-password\")\nprint(password)\n</code></pre>"},{"location":"user-guide/basic-usage/#custom-provider-configuration","title":"Custom Provider Configuration","text":"<p>For advanced scenarios like testing or custom authentication, you can inject a custom provider instance:</p> <pre><code>import envresolve\nfrom envresolve.providers.azure_kv import AzureKVProvider\nfrom azure.identity import ManagedIdentityCredential\n\n# Create custom provider with specific credential\ncustom_provider = AzureKVProvider(\n    credential=ManagedIdentityCredential(client_id=\"your-client-id\")\n)\n\n# Register the custom provider\nenvresolve.register_azure_kv_provider(provider=custom_provider)\n\n# Now use envresolve as normal\nsecret = envresolve.resolve_secret(\"akv://vault/secret\")\n</code></pre> <p>This is particularly useful for:</p> <ul> <li>Testing: Inject mock providers without patching internal implementation details</li> <li>Custom authentication: Use specific Azure credentials (service principal, managed identity with client ID, etc.)</li> <li>Provider configuration: Pre-configure providers with custom settings before registration</li> </ul>"},{"location":"user-guide/basic-usage/#iterative-resolution","title":"Iterative resolution","text":"<p><code>resolve_secret()</code> keeps resolving until the returned value is stable. This lets you chain indirections or mix URI results with variable expansion:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\nos.environ[\"ENVIRONMENT\"] = \"prod\"\n\n# akv://config/service \u2192 \"akv://vault-${ENVIRONMENT}/service\"\nsecret = envresolve.resolve_secret(\"akv://config/service\")\nprint(secret)  # Resolved value from akv://vault-prod/service\n</code></pre>"},{"location":"user-guide/basic-usage/#loading-and-exporting-from-env","title":"Loading and exporting from <code>.env</code>","text":"<pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\n# .env may contain plain values, variable references, and akv:// URIs\nresolved = envresolve.load_env(\".env\", export=True)\n\nprint(resolved[\"DB_PASSWORD\"])\nprint(os.environ[\"DB_PASSWORD\"])  # Exported unless override=False and already set\n</code></pre> <p>Use <code>export=False</code> when you only need the resolved dictionary, or set <code>override=True</code> if you want to intentionally replace existing <code>os.environ</code> values.</p>"},{"location":"user-guide/basic-usage/#resolving-existing-environment-variables","title":"Resolving Existing Environment Variables","text":"<p>Use <code>resolve_os_environ()</code> to resolve secret URIs that are already set in <code>os.environ</code>. This is useful when environment variables are passed from parent shells or container orchestrators:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\n# Environment variables set by parent process or container\nos.environ[\"API_KEY\"] = \"akv://prod-vault/api-key\"\nos.environ[\"DB_PASSWORD\"] = \"akv://prod-vault/db-password\"\n\n# Resolve all environment variables containing secret URIs\nresolved = envresolve.resolve_os_environ()\n\nprint(resolved[\"API_KEY\"])      # Resolved secret value\nprint(os.environ[\"API_KEY\"])    # os.environ is updated by default\n</code></pre>"},{"location":"user-guide/basic-usage/#filtering-by-specific-keys","title":"Filtering by Specific Keys","text":"<p>Resolve only specific environment variables:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\nos.environ[\"API_KEY\"] = \"akv://prod-vault/api-key\"\nos.environ[\"DB_PASSWORD\"] = \"akv://prod-vault/db-password\"\nos.environ[\"PLAIN_CONFIG\"] = \"some-value\"\n\n# Resolve only API_KEY and DB_PASSWORD\nresolved = envresolve.resolve_os_environ(keys=[\"API_KEY\", \"DB_PASSWORD\"])\n\n# PLAIN_CONFIG is not processed\nassert \"PLAIN_CONFIG\" not in resolved\n</code></pre>"},{"location":"user-guide/basic-usage/#filtering-by-prefix","title":"Filtering by Prefix","text":"<p>Resolve variables with a specific prefix and strip the prefix from output:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\n# Different environments using prefixes\nos.environ[\"DEV_API_KEY\"] = \"akv://dev-vault/api-key\"\nos.environ[\"DEV_DB_URL\"] = \"akv://dev-vault/db-url\"\nos.environ[\"PROD_API_KEY\"] = \"akv://prod-vault/api-key\"\nos.environ[\"PROD_DB_URL\"] = \"akv://prod-vault/db-url\"\n\n# Resolve only DEV_ variables and strip the prefix\nresolved = envresolve.resolve_os_environ(prefix=\"DEV_\")\n\n# Results have prefix stripped\nprint(resolved[\"API_KEY\"])      # Resolved from DEV_API_KEY\nprint(resolved[\"DB_URL\"])       # Resolved from DEV_DB_URL\n\n# os.environ is updated with stripped keys\nprint(os.environ[\"API_KEY\"])    # Resolved value\nassert \"DEV_API_KEY\" not in os.environ  # Old key removed\n</code></pre> <p>Prefix Stripping Behavior</p> <p>When using <code>prefix</code>, the resolved values are stored in <code>os.environ</code> with the prefix stripped, and the original prefixed keys are removed.</p>"},{"location":"user-guide/basic-usage/#without-updating-osenviron","title":"Without Updating os.environ","text":"<p>Use <code>overwrite=False</code> to get resolved values without modifying <code>os.environ</code>:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\nos.environ[\"API_KEY\"] = \"akv://prod-vault/api-key\"\n\n# Get resolved values without updating os.environ\nresolved = envresolve.resolve_os_environ(overwrite=False)\n\nprint(resolved[\"API_KEY\"])              # Resolved secret value\nprint(os.environ[\"API_KEY\"])            # Still the original URI\nassert os.environ[\"API_KEY\"] == \"akv://prod-vault/api-key\"\n</code></pre>"},{"location":"user-guide/basic-usage/#continuing-on-errors","title":"Continuing on Errors","text":"<p>Use <code>stop_on_error=False</code> to continue resolving other variables even if a secret resolution error occurs. This allows the function to skip over individual secrets that might be misconfigured or inaccessible, without halting the entire process.</p> <pre><code>Note that this only applies to expected resolution errors (like `SecretResolutionError`); other unexpected errors (like programming mistakes) will still stop the process regardless of this flag.\n</code></pre> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\nos.environ[\"GOOD_KEY\"] = \"akv://prod-vault/valid-secret\"\nos.environ[\"BAD_KEY\"] = \"akv://prod-vault/missing-secret\"  # Doesn't exist\nos.environ[\"PLAIN\"] = \"plain-value\"\n\n# Continue on errors instead of raising\nresolved = envresolve.resolve_os_environ(stop_on_error=False)\n\n# Successfully resolved variables are in the result\nprint(resolved[\"GOOD_KEY\"])    # Resolved value\nprint(resolved[\"PLAIN\"])       # plain-value\nassert \"BAD_KEY\" not in resolved  # Skipped due to error\n</code></pre>"},{"location":"user-guide/basic-usage/#error-handling","title":"Error Handling","text":"<p>When working with external services, it's important to handle potential errors like missing dependencies, incorrect configuration, or network issues.</p>"},{"location":"user-guide/basic-usage/#provider-and-resolution-errors","title":"Provider and Resolution Errors","text":"<p>Here is a robust example of how to handle errors during provider registration and secret resolution:</p> <pre><code>import envresolve\nfrom envresolve.exceptions import ProviderRegistrationError, SecretResolutionError\n\ntry:\n    # This might fail if 'envresolve[azure]' is not installed\n    envresolve.register_azure_kv_provider()\n\n    # This might fail due to permissions, network issues, or if the secret doesn't exist\n    secret_value = envresolve.resolve_secret(\"akv://corp-vault/db-password\")\n    print(secret_value)\n\nexcept ProviderRegistrationError as e:\n    print(f\"Provider setup failed: {e}\")\n    # Example: Provider setup failed: Azure Key Vault provider requires: azure-identity, azure-keyvault-secrets. Install with: pip install envresolve[azure]\n\nexcept SecretResolutionError as e:\n    print(f\"Failed to fetch secret: {e}\")\n</code></pre> <p>This pattern ensures that your application can gracefully handle both setup-time (missing dependencies) and run-time (secret access) errors.</p>"},{"location":"user-guide/basic-usage/#circular-reference-detection","title":"Circular Reference Detection","text":"<p>envresolve automatically detects circular references and raises a clear error:</p> <pre><code>from envresolve import expand_variables\nfrom envresolve.exceptions import CircularReferenceError\n\nenv = {\n    \"A\": \"${B}\",\n    \"B\": \"${A}\"\n}\n\ntry:\n    result = expand_variables(env[\"A\"], env)\nexcept CircularReferenceError as e:\n    print(f\"Error: {e}\")\n    # Error: Circular reference detected: B -&gt; A -&gt; B\n\n    # Inspect the exact cycle if you need more detail\n    print(e.chain)  # ['B', 'A', 'B']\n</code></pre>"},{"location":"user-guide/basic-usage/#missing-variable-error","title":"Missing Variable Error","text":"<p>If a referenced variable doesn't exist, <code>VariableNotFoundError</code> is raised:</p> <pre><code>from envresolve import expand_variables\nfrom envresolve.exceptions import VariableNotFoundError\n\nenv = {\"A\": \"value\"}\n\ntry:\n    result = expand_variables(\"${MISSING}\", env)\nexcept VariableNotFoundError as e:\n    print(f\"Error: {e}\")\n    # Error: Variable 'MISSING' not found\n</code></pre>"},{"location":"user-guide/basic-usage/#mutually-exclusive-arguments","title":"Mutually Exclusive Arguments","text":"<p>Some API functions have mutually exclusive parameters. For example, <code>resolve_os_environ()</code> cannot accept both <code>keys</code> and <code>prefix</code> parameters:</p> <pre><code>import envresolve\nfrom envresolve.exceptions import MutuallyExclusiveArgumentsError\n\nenvresolve.register_azure_kv_provider()\n\ntry:\n    # This will raise an error - cannot specify both\n    envresolve.resolve_os_environ(\n        keys=[\"API_KEY\"],\n        prefix=\"DEV_\"\n    )\nexcept MutuallyExclusiveArgumentsError as e:\n    print(f\"Error: {e}\")\n    # Error: Arguments 'keys' and 'prefix' are mutually exclusive.\n    #        Specify either 'keys' or 'prefix', but not both.\n\n    # Access argument names programmatically\n    print(f\"Conflicting arguments: {e.arg1} and {e.arg2}\")\n    # Conflicting arguments: keys and prefix\n</code></pre> <p>TypeError Compatibility</p> <p><code>MutuallyExclusiveArgumentsError</code> also inherits from <code>TypeError</code>, so you can catch it with standard exception handling:</p> <pre><code>try:\n    envresolve.resolve_os_environ(keys=[\"API_KEY\"], prefix=\"DEV_\")\nexcept TypeError as e:\n    print(f\"Invalid argument combination: {e}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#advanced-use-cases","title":"Advanced Use Cases","text":""},{"location":"user-guide/basic-usage/#building-secret-uris-dynamically","title":"Building Secret URIs Dynamically","text":"<pre><code>from envresolve import expand_variables\n\n# Define vault and environment once\nenv = {\n    \"ENVIRONMENT\": \"production\",\n    \"VAULT\": \"${ENVIRONMENT}-keyvault\",\n\n    # Define all secrets using the vault\n    \"DB_HOST_URI\": \"akv://${VAULT}/db-host\",\n    \"DB_USER_URI\": \"akv://${VAULT}/db-user\",\n    \"DB_PASS_URI\": \"akv://${VAULT}/db-password\",\n    \"API_KEY_URI\": \"akv://${VAULT}/api-key\",\n}\n\n# Expand each URI\nfor key in [\"DB_HOST_URI\", \"DB_USER_URI\", \"DB_PASS_URI\", \"API_KEY_URI\"]:\n    expanded = expand_variables(env[key], env)\n    print(f\"{key}: {expanded}\")\n\n# Output:\n# DB_HOST_URI: akv://production-keyvault/db-host\n# DB_USER_URI: akv://production-keyvault/db-user\n# DB_PASS_URI: akv://production-keyvault/db-password\n# API_KEY_URI: akv://production-keyvault/api-key\n</code></pre>"},{"location":"user-guide/basic-usage/#plain-text-pass-through","title":"Plain Text Pass-Through","text":"<p>Text without variable references is returned unchanged:</p> <pre><code>from envresolve import expand_variables\n\nresult = expand_variables(\"plain text with $100 price\", {\"VAR\": \"value\"})\nprint(result)  # Output: plain text with $100 price\n</code></pre> <p>Note: A lone <code>$</code> followed by non-variable characters (like digits) is preserved.</p>"},{"location":"user-guide/basic-usage/#secret-resolution-errors","title":"Secret Resolution Errors","text":"<p>Azure-specific failures (missing vaults, permission issues, network errors) raise <code>SecretResolutionError</code>. The exception carries the failing URI, making it easy to log or surface to users:</p> <pre><code>import envresolve\nfrom envresolve.exceptions import SecretResolutionError\n\nenvresolve.register_azure_kv_provider()\n\ntry:\n    envresolve.resolve_secret(\"akv://missing-vault/api-key\")\nexcept SecretResolutionError as exc:\n    print(exc)              # Human-readable message\n    print(exc.uri)          # akv://missing-vault/api-key\n    print(exc.original_error)  # Underlying Azure exception (if available)\n</code></pre>"},{"location":"user-guide/installation/","title":"Installation","text":""},{"location":"user-guide/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> </ul>"},{"location":"user-guide/installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install envresolve\n</code></pre>"},{"location":"user-guide/installation/#install-with-uv","title":"Install with uv","text":"<pre><code>uv pip install envresolve\n</code></pre>"},{"location":"user-guide/installation/#install-for-development","title":"Install for Development","text":"<p>To install envresolve for development with all dependencies:</p> <pre><code># Clone the repository\ngit clone https://github.com/osoekawaitlab/envresolve.git\ncd envresolve\n\n# Install with development dependencies\nuv sync\n\n# Run tests\nnox -s tests\n\n# Run all quality checks\nnox -s check_all\n</code></pre>"},{"location":"user-guide/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"user-guide/installation/#azure-key-vault-support","title":"Azure Key Vault Support","text":"<p>Install the Azure extra when you need <code>akv://</code> resolution:</p> <pre><code>pip install envresolve[azure]\n</code></pre> <p>This pulls in:</p> <ul> <li><code>azure-identity</code></li> <li><code>azure-keyvault-secrets</code></li> </ul> <p>After installation, register the provider before resolving secrets:</p> <pre><code>import envresolve\n\nenvresolve.register_azure_kv_provider()\n</code></pre>"}]}