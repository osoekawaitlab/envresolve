{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to envresolve","text":"<p>Resolve environment variables from secret stores like Azure Key Vault.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Variable expansion: Expand <code>${VAR}</code> and <code>$VAR</code> syntax in strings</li> <li>Secret resolution: Fetch secrets from Azure Key Vault (more providers coming)</li> <li>.env support: Load variables from <code>.env</code> files and automatically resolve secrets</li> <li>Circular reference detection: Prevents infinite loops in variable chains</li> <li>Type-safe: Full mypy type checking support</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#load-from-env-file","title":"Load from .env File","text":"<p>The easiest way to use <code>envresolve</code> is by loading a <code>.env</code> file.</p> <pre><code>import envresolve\n\n# .env file content:\n# VAULT_NAME=my-vault\n# DATABASE_URL=akv://${VAULT_NAME}/db-url\n# API_KEY=akv://${VAULT_NAME}/api-key\n\n# Requires: pip install envresolve[azure]\n# Requires: Azure authentication (az login, Managed Identity, etc.)\nenvresolve.register_azure_kv_provider()\n\n# Load .env and resolve all secret URIs\n# By default, searches for .env in current directory and exports to os.environ\nresolved_vars = envresolve.load_env()\n\n# Or specify explicit path and disable export\nresolved_vars = envresolve.load_env(dotenv_path=\".env\", export=False)\n</code></pre>"},{"location":"#direct-secret-resolution","title":"Direct Secret Resolution","text":"<p>You can also fetch individual secrets directly:</p> <pre><code>import envresolve\n\n# Requires: pip install envresolve[azure]\ntry:\n    envresolve.register_azure_kv_provider()\n    secret_value = envresolve.resolve_secret(\"akv://corp-vault/db-password\")\n    print(secret_value)\nexcept envresolve.ProviderRegistrationError as e:\n    print(f\"Azure SDK not available: {e}\")\nexcept envresolve.SecretResolutionError as e:\n    print(f\"Failed to fetch secret: {e}\")\n</code></pre>"},{"location":"#simple-variable-expansion","title":"Simple Variable Expansion","text":"<p>Expand variables without connecting to external services:</p> <pre><code>from envresolve import expand_variables\n\nenv = {\"VAULT\": \"corp-kv\", \"SECRET\": \"db-password\"}\nresult = expand_variables(\"akv://${VAULT}/${SECRET}\", env)\nprint(result)  # akv://corp-kv/db-password\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code># Basic installation (variable expansion only)\npip install envresolve\n\n# With Azure Key Vault support\npip install envresolve[azure]\n</code></pre>"},{"location":"roadmap/","title":"Roadmap","text":""},{"location":"roadmap/#current-version-017","title":"Current Version: 0.1.7","text":""},{"location":"roadmap/#completed-features","title":"Completed Features","text":"<ul> <li>\u2705 Variable expansion with <code>${VAR}</code> and <code>$VAR</code> syntax</li> <li>\u2705 Circular reference detection</li> <li>\u2705 Nested variable expansion</li> <li>\u2705 Support for <code>os.environ</code>, <code>.env</code> files, and custom dictionaries</li> <li>\u2705 Secret URI resolution with Azure Key Vault provider (<code>resolve_secret</code>, <code>load_env</code>)</li> <li>\u2705 Variable ignore patterns (Phase 1): <code>ignore_keys</code> parameter for exact string matching</li> </ul>"},{"location":"roadmap/#planned-features","title":"Planned Features","text":""},{"location":"roadmap/#v01x-in-progress","title":"v0.1.x (In Progress)","text":"<ul> <li>Structured logging hooks for resolution diagnostics</li> <li>Variable ignore patterns (Phase 2 &amp; 3):<ul> <li>\u2705 Phase 1: <code>ignore_keys</code> parameter with exact string matching</li> <li>Phase 2: <code>ignore_patterns</code> parameter with glob-style matching (e.g., <code>PS*</code>, <code>PROMPT*</code>)</li> <li>Phase 3: <code>ENVRESOLVE_IGNORE</code> environment variable configuration</li> </ul> </li> </ul>"},{"location":"roadmap/#v02x","title":"v0.2.x","text":"<ul> <li>CLI tool (<code>envresolve render</code>)</li> <li>pydantic-settings integration</li> <li>Secret caching with TTL</li> </ul>"},{"location":"roadmap/#v03x","title":"v0.3.x+","text":"<ul> <li>Additional secret providers:<ul> <li>AWS Secrets Manager / SSM Parameter Store</li> <li>Google Secret Manager</li> <li>HashiCorp Vault</li> <li>Local: 1Password, Bitwarden, pass, sops</li> </ul> </li> <li>Async support for concurrent secret resolution</li> </ul>"},{"location":"adr/0000-adr-template/","title":"ADR 0000: This is ADR Template and Short Title of the Architectural Decision Goes Here","text":""},{"location":"adr/0000-adr-template/#status","title":"Status","text":"<p>[Proposed | Accepted | Deprecated | Superseded]</p>"},{"location":"adr/0000-adr-template/#date","title":"Date","text":"<p>YYYY-MM-DD</p>"},{"location":"adr/0000-adr-template/#context","title":"Context","text":"<p>Describe the context and problem statement. What is the architectural challenge that needs to be addressed? Include any relevant constraints or requirements that influenced the decision.</p>"},{"location":"adr/0000-adr-template/#decision","title":"Decision","text":"<p>State the architectural decision clearly and concisely. What specific approach, technology, pattern, or solution was chosen?</p>"},{"location":"adr/0000-adr-template/#rationale","title":"Rationale","text":"<p>Explain the reasoning that led to this decision. Why was this particular option selected among the alternatives? Include relevant factors such as:</p> <ul> <li>Technical considerations</li> <li>Business requirements</li> <li>Team capabilities</li> <li>Time constraints</li> <li>Cost implications</li> </ul>"},{"location":"adr/0000-adr-template/#implications","title":"Implications","text":""},{"location":"adr/0000-adr-template/#positive-implications","title":"Positive Implications","text":"<p>List the benefits and positive outcomes expected from this decision.</p>"},{"location":"adr/0000-adr-template/#concerns","title":"Concerns","text":"<p>List potential challenges, risks, or negative consequences along with possible mitigation strategies.</p>"},{"location":"adr/0000-adr-template/#alternatives","title":"Alternatives","text":"<p>Describe other options that were considered and why they were not selected. For each alternative, briefly explain:</p> <ul> <li>Key characteristics</li> <li>Pros and cons relative to the chosen solution</li> <li>Reasons for rejection</li> </ul>"},{"location":"adr/0000-adr-template/#future-direction","title":"Future Direction","text":"<p>Outline any follow-up actions, future considerations, or potential changes that might be necessary as a result of this decision. Include potential triggers for revisiting this decision.</p>"},{"location":"adr/0000-adr-template/#references","title":"References","text":"<p>List any relevant documents, articles, books, or other resources that supported this decision:</p> <ul> <li>Links to relevant documentation</li> <li>Research materials</li> <li>Benchmarks or performance data</li> <li>Team discussions or meeting notes</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/","title":"ADR 0001: Use Regular Expressions for Variable Expansion","text":""},{"location":"adr/0001-variable-expansion-with-regex/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0001-variable-expansion-with-regex/#date","title":"Date","text":"<p>2025-10-10</p>"},{"location":"adr/0001-variable-expansion-with-regex/#context","title":"Context","text":"<p>The envresolve library needs to expand environment variable references in strings using <code>${VAR}</code> and <code>$VAR</code> syntax. The expansion must:</p> <ul> <li>Support both <code>${VAR}</code> and <code>$VAR</code> formats</li> <li>Handle multiple variables in a single string</li> <li>Enable future support for nested variable expansion</li> <li>Detect circular references</li> <li>Provide clear error messages when variables are missing</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#decision","title":"Decision","text":"<p>Use Python's <code>re</code> module with regex pattern matching (<code>\\$\\{([^}]+)\\}</code> for <code>${VAR}</code>) to implement variable expansion.</p>"},{"location":"adr/0001-variable-expansion-with-regex/#rationale","title":"Rationale","text":"<ul> <li>Simplicity: Regex provides a concise way to match variable patterns</li> <li>Standard library: No additional dependencies required</li> <li>Flexibility: Easy to extend patterns for <code>$VAR</code> syntax and more complex cases</li> <li>Performance: Regex is efficient for this use case</li> <li>Maintainability: Pattern is clear and well-understood by Python developers</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#implications","title":"Implications","text":""},{"location":"adr/0001-variable-expansion-with-regex/#positive-implications","title":"Positive Implications","text":"<ul> <li>Minimal code required for basic expansion</li> <li>Easy to test with unit tests</li> <li>Fast execution for typical use cases</li> <li>Clear separation between pattern matching and value substitution</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#concerns","title":"Concerns","text":"<ul> <li>Regex may become complex if we add many features (escaping, default values, etc.)</li> <li>Performance could degrade with very large strings or many variables</li> <li>Error messages from regex failures can be cryptic</li> </ul> <p>Mitigation: Keep patterns simple and add custom validation/error handling as needed.</p>"},{"location":"adr/0001-variable-expansion-with-regex/#alternatives","title":"Alternatives","text":""},{"location":"adr/0001-variable-expansion-with-regex/#string-template-stdlib","title":"String Template (stdlib)","text":"<p>Python's <code>string.Template</code> class provides variable substitution.</p> <ul> <li>Pros: Built-in, simple API, safer than format strings</li> <li>Cons: Limited to <code>$VAR</code> and <code>${VAR}</code> only, less flexible for custom extensions</li> <li>Rejection reason: We need more control over expansion behavior (cycle detection, nested expansion)</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#manual-string-parsing","title":"Manual String Parsing","text":"<p>Iterate through characters to find and replace variables.</p> <ul> <li>Pros: Complete control, potentially better error messages</li> <li>Cons: More complex to implement correctly, prone to edge case bugs, harder to maintain</li> <li>Rejection reason: Regex provides sufficient control with less complexity</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#ast-based-parsing","title":"AST-based Parsing","text":"<p>Build an abstract syntax tree for variable references.</p> <ul> <li>Pros: Very flexible, excellent error handling</li> <li>Cons: Overkill for this use case, significant complexity overhead</li> <li>Rejection reason: Not justified for simple variable expansion</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#future-direction","title":"Future Direction","text":"<ul> <li>If complexity grows (escaping, default values, filters), consider migrating to a dedicated template engine</li> <li>Monitor performance with profiling; optimize regex patterns if needed</li> <li>Add support for <code>$VAR</code> syntax using additional regex pattern</li> <li>Implement nested expansion through recursive calls with cycle detection</li> </ul>"},{"location":"adr/0001-variable-expansion-with-regex/#references","title":"References","text":"<ul> <li>Python <code>re</code> module documentation: https://docs.python.org/3/library/re.html</li> <li>Issue #1: Variable expansion in environment variables</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/","title":"ADR 0002: Use Custom Exception Hierarchy Instead of Built-in Exceptions","text":""},{"location":"adr/0002-custom-exception-hierarchy/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0002-custom-exception-hierarchy/#date","title":"Date","text":"<p>2025-10-11</p>"},{"location":"adr/0002-custom-exception-hierarchy/#context","title":"Context","text":"<p>The envresolve library needs to handle various error conditions during variable expansion (e.g., missing variables, circular references). We must decide whether to:</p> <ol> <li>Use Python's built-in exceptions (KeyError, ValueError, RuntimeError)</li> <li>Create custom exception classes specific to envresolve</li> </ol>"},{"location":"adr/0002-custom-exception-hierarchy/#decision","title":"Decision","text":"<p>Create a custom exception hierarchy with a base exception class (<code>EnvResolveError</code>) and specific exception types for each error condition (e.g., <code>VariableNotFoundError</code>, <code>CircularReferenceError</code>).</p>"},{"location":"adr/0002-custom-exception-hierarchy/#rationale","title":"Rationale","text":"<ul> <li>Selective error handling: Clients can catch <code>EnvResolveError</code> to handle all library errors or catch specific exceptions for fine-grained control</li> <li>Clear API contract: Custom exceptions document what errors the library can raise</li> <li>Namespace isolation: Prevents accidental catching of unrelated KeyError/ValueError from other code</li> <li>Domain semantics: Exception names reflect domain concepts (<code>VariableNotFoundError</code> is clearer than <code>KeyError</code>)</li> <li>Future extensibility: Easy to add new exception types as features are added</li> <li>Prevents leakage: Internal implementation details (like using dict for env) don't leak into the API</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/#implications","title":"Implications","text":""},{"location":"adr/0002-custom-exception-hierarchy/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clients can write <code>except EnvResolveError</code> to catch all library errors</li> <li>Clear separation between library errors and other Python errors</li> <li>Better IDE support with domain-specific exception names</li> <li>Exception hierarchy can evolve independently from implementation</li> <li>Easier to add exception-specific attributes and methods</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/#concerns","title":"Concerns","text":"<ul> <li>Slightly more boilerplate code (exception class definitions)</li> <li>Developers must remember to use custom exceptions instead of built-ins</li> </ul> <p>Mitigation: Exception classes are stable and infrequently modified. The benefits far outweigh the minimal overhead.</p>"},{"location":"adr/0002-custom-exception-hierarchy/#alternatives","title":"Alternatives","text":""},{"location":"adr/0002-custom-exception-hierarchy/#use-built-in-exceptions","title":"Use Built-in Exceptions","text":"<p>Raise <code>KeyError</code> for missing variables, <code>RuntimeError</code> for circular references.</p> <pre><code>if var_name not in env:\n    raise KeyError(var_name)\n</code></pre> <ul> <li>Pros: No extra code, familiar to Python developers</li> <li>Cons:<ul> <li>Cannot distinguish library errors from other KeyError in client code</li> <li>Poor semantic clarity (KeyError doesn't convey \"variable not found in expansion\")</li> <li>Tight coupling to implementation (exposes that we use dict internally)</li> <li>Cannot catch \"all envresolve errors\" without catching unrelated errors</li> </ul> </li> <li>Rejection reason: Lack of namespace isolation and poor API clarity</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/#exception-wrapper-pattern","title":"Exception Wrapper Pattern","text":"<p>Catch built-in exceptions and wrap them.</p> <pre><code>try:\n    value = env[var_name]\nexcept KeyError as e:\n    raise VariableNotFoundError(...) from e\n</code></pre> <ul> <li>Pros: Clear API boundary, custom exceptions for clients</li> <li>Cons: Still need to define custom exceptions (same as our decision)</li> <li>Note: This pattern is actually used in our implementation for internal error handling, but the key decision is to expose custom exceptions in the public API</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding exception base class methods for common operations (e.g., <code>to_dict()</code> for structured logging)</li> <li>Add exception hierarchy documentation to API reference</li> <li>Evaluate if recovery/retry strategies should be exception attributes</li> </ul>"},{"location":"adr/0002-custom-exception-hierarchy/#references","title":"References","text":"<ul> <li>Python Exception Hierarchy: https://docs.python.org/3/library/exceptions.html#exception-hierarchy</li> <li>PEP 3151: Reworking the OS and IO exception hierarchy</li> <li>Issue #1: Variable expansion feature implementation</li> </ul>"},{"location":"adr/0003-structured-exception-design/","title":"ADR 0003: Use Structured Exceptions with Data Attributes","text":""},{"location":"adr/0003-structured-exception-design/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0003-structured-exception-design/#date","title":"Date","text":"<p>2025-10-11</p>"},{"location":"adr/0003-structured-exception-design/#context","title":"Context","text":"<p>Following ADR 0002 (Custom Exception Hierarchy), we have decided to use custom exceptions. This ADR addresses how to design those exception classes.</p> <p>When designing custom exceptions, we can choose between:</p> <ol> <li>Message-based: Pass error messages directly to exception constructors</li> <li>Structured: Pass structured data (variable names, values) and construct messages within the exception class</li> </ol>"},{"location":"adr/0003-structured-exception-design/#decision","title":"Decision","text":"<p>Use structured exceptions that accept specific data attributes (e.g., <code>variable_name</code>) and construct error messages internally within the exception class.</p>"},{"location":"adr/0003-structured-exception-design/#rationale","title":"Rationale","text":"<ul> <li>Consistency: Error message format is standardized across the codebase</li> <li>Programmatic access: Callers can access structured data (e.g., <code>e.variable_name</code>) for logging, debugging, or recovery</li> <li>Testability: Tests can validate specific error conditions by checking attributes rather than fragile string matching</li> <li>Internationalization: Message templates can be changed without modifying call sites</li> <li>Type safety: IDE and type checkers can validate that correct parameters are passed</li> </ul>"},{"location":"adr/0003-structured-exception-design/#implications","title":"Implications","text":""},{"location":"adr/0003-structured-exception-design/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clear separation between error data and error presentation</li> <li>Easier to extend exceptions with additional context (e.g., resolution suggestions)</li> <li>Better error handling in client code (can extract variable names programmatically)</li> <li>Consistent error message format across the library</li> </ul>"},{"location":"adr/0003-structured-exception-design/#concerns","title":"Concerns","text":"<ul> <li>Slightly more code in exception class definitions</li> <li>Need to maintain message templates when adding new exception types</li> </ul> <p>Mitigation: Exception classes are relatively stable; the benefits outweigh the minimal maintenance cost.</p>"},{"location":"adr/0003-structured-exception-design/#alternatives","title":"Alternatives","text":""},{"location":"adr/0003-structured-exception-design/#message-based-exceptions","title":"Message-based Exceptions","text":"<p>Pass complete error messages to exception constructors.</p> <pre><code>raise VariableNotFoundError(f\"Variable not found: {var_name}\")\n</code></pre> <ul> <li>Pros: Simple, minimal code, flexible message format</li> <li>Cons: Inconsistent messages, no programmatic access to error details, harder to test</li> <li>Rejection reason: Sacrifices structure and testability for minimal code savings</li> </ul>"},{"location":"adr/0003-structured-exception-design/#exception-with-optional-message-override","title":"Exception with Optional Message Override","text":"<p>Accept structured data but allow message override.</p> <pre><code>class VariableNotFoundError(EnvResolveError):\n    def __init__(self, variable_name: str, message: str | None = None):\n        self.variable_name = variable_name\n        msg = message or f\"Variable not found: {variable_name}\"\n        super().__init__(msg)\n</code></pre> <ul> <li>Pros: Flexibility for special cases</li> <li>Cons: Inconsistency risk if developers override messages arbitrarily</li> <li>Rejection reason: Flexibility not needed for this use case; consistency is more valuable</li> </ul>"},{"location":"adr/0003-structured-exception-design/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding helper methods for common error message patterns (e.g., <code>with_suggestion()</code>)</li> <li>If internationalization is needed, replace f-strings with message templates and localization framework</li> <li>Add structured logging integration that automatically logs exception attributes</li> </ul>"},{"location":"adr/0003-structured-exception-design/#references","title":"References","text":"<ul> <li>ADR 0002: Custom Exception Hierarchy</li> <li>Python Exception Best Practices: https://docs.python.org/3/tutorial/errors.html</li> <li>Issue #1: Variable expansion feature implementation</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/","title":"ADR 0004: Use Stateless Function for Variable Expansion Core Logic","text":""},{"location":"adr/0004-stateless-function-based-variable-expansion/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#date","title":"Date","text":"<p>2025-10-11</p>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#context","title":"Context","text":"<p>The variable expansion service needs to provide a simple API for expanding <code>${VAR}</code> and <code>$VAR</code> references in strings. We must decide on the interface design:</p> <ol> <li>Stateless function: <code>expand_variables(text, env)</code> - takes both text and environment dict as parameters</li> <li>Stateful class: <code>VariableExpander(env)</code> with <code>expand(text)</code> method - environment configured at initialization</li> <li>Hybrid: Stateless function as core, with convenience wrapper class for os.environ integration</li> </ol> <p>Key considerations:</p> <ul> <li>Simplicity and ease of use</li> <li>Testability</li> <li>Flexibility for different use cases (.env files, os.environ, custom dicts)</li> <li>Performance (avoiding unnecessary object creation)</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#decision","title":"Decision","text":"<p>Use a stateless function (<code>expand_variables(text, env)</code>) as the core API, with an <code>EnvExpander</code> convenience class for os.environ integration.</p> <pre><code># Core API: stateless function\ndef expand_variables(text: str, env: dict[str, str]) -&gt; str:\n    \"\"\"Expand ${VAR} and $VAR in text using provided environment dictionary.\"\"\"\n\n# Convenience wrapper for os.environ\nclass EnvExpander:\n    def expand(self, text: str) -&gt; str:\n        return expand_variables(text, dict(os.environ))\n</code></pre>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#rationale","title":"Rationale","text":"<ul> <li>Simplicity: Functions are simpler than classes for stateless operations</li> <li>Explicit dependencies: <code>env</code> parameter makes it clear what data is being used</li> <li>Testability: Easy to test with different env dicts without object creation</li> <li>No unnecessary state: No need to store <code>env</code> when it's only used during expansion</li> <li>Performance: Avoids object allocation for one-time expansions</li> <li>Flexibility: Callers can easily switch env dicts between calls</li> <li>Pythonic: Aligns with Python's preference for functions over classes when state is not needed</li> <li>Convenience when needed: <code>EnvExpander</code> provides a clean API for the common os.environ use case</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#implications","title":"Implications","text":""},{"location":"adr/0004-stateless-function-based-variable-expansion/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clear, simple API that's easy to understand and use</li> <li>No hidden state or side effects</li> <li>Easier to reason about in tests (no setup required)</li> <li>Can be used as a building block for higher-level abstractions</li> <li>Flexibility to use with any dict (os.environ, .env files, custom configs)</li> <li>Better performance for one-off expansions</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#concerns","title":"Concerns","text":"<ul> <li>Slightly more verbose when repeatedly expanding with the same env dict</li> <li>Need to maintain consistency between function and class API</li> </ul> <p>Mitigation: The <code>EnvExpander</code> class addresses the verbosity concern for the os.environ use case. For other repeated use cases, callers can use <code>functools.partial</code> if needed.</p>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#alternatives","title":"Alternatives","text":""},{"location":"adr/0004-stateless-function-based-variable-expansion/#stateful-class-only","title":"Stateful Class Only","text":"<p>Use a class with env configured at initialization:</p> <pre><code>expander = VariableExpander(env)\nresult = expander.expand(text)\n</code></pre> <ul> <li>Pros: Less repetition when using the same env multiple times</li> <li>Cons:<ul> <li>Unnecessary object creation for one-time use</li> <li>Hidden state makes testing more complex</li> <li>Need to create new objects to switch env dicts</li> <li>Violates \"functions over classes\" principle when state is not needed</li> </ul> </li> <li>Rejection reason: Adds complexity without sufficient benefit. State is not needed for this operation.</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#factory-functions","title":"Factory Functions","text":"<p>Provide factory functions for common cases:</p> <pre><code>def create_expander(env: dict[str, str]) -&gt; Callable[[str], str]:\n    return lambda text: expand_variables(text, env)\n\ndef create_env_expander() -&gt; Callable[[str], str]:\n    return lambda text: expand_variables(text, dict(os.environ))\n</code></pre> <ul> <li>Pros: Functional style, flexible</li> <li>Cons: Less discoverable than a class, lambda functions harder to debug</li> <li>Rejection reason: Class provides better IDE support and clearer intent than lambda</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#global-state","title":"Global State","text":"<p>Store environment in module-level variable:</p> <pre><code>_env = {}\n\ndef set_environment(env: dict[str, str]) -&gt; None:\n    global _env\n    _env = env\n\ndef expand(text: str) -&gt; str:\n    return expand_variables(text, _env)\n</code></pre> <ul> <li>Pros: Very concise API</li> <li>Cons: Global mutable state, not thread-safe, makes testing difficult</li> <li>Rejection reason: Anti-pattern that causes numerous testing and concurrency issues</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding <code>functools.lru_cache</code> decorator if profiling shows repeated parsing overhead</li> <li>If more configuration options are needed (e.g., custom patterns, escaping), consider a configuration object</li> <li>Monitor usage patterns; if most calls use os.environ, consider making it the default parameter</li> </ul>"},{"location":"adr/0004-stateless-function-based-variable-expansion/#references","title":"References","text":"<ul> <li>ADR 0001: Regular expressions for variable expansion</li> <li>Python Design Philosophy: \"Simple is better than complex\" (PEP 20)</li> <li>Issue #1: Variable expansion feature implementation</li> <li>Discussion: Function vs. Class API design</li> </ul>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/","title":"ADR 0005: Use String-Based API with Idempotent Resolution Instead of Data Models","text":""},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#date","title":"Date","text":"<p>2025-10-12</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#context","title":"Context","text":"<p>As a library for resolving environment variables and secret URIs, envresolve must decide how to represent resolved values in its public API. There are two main approaches:</p> <ol> <li>Model-based API: Return structured data models (e.g., Pydantic models) with metadata</li> <li>String-based API: Return plain strings with utility functions for validation</li> </ol> <p>Key considerations:</p> <ul> <li>End users ultimately need string values to set as environment variables</li> <li>Library should integrate seamlessly with existing code</li> <li>Users should not be forced to perform type conversions</li> <li>Resolution should be safe to call multiple times (idempotent)</li> </ul> <p>The library's positioning as an infrastructure utility (not a domain framework) heavily influences this decision.</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#decision","title":"Decision","text":"<p>Use a string-based API with idempotent resolution, and plan for companion validation utilities in a later iteration.</p> <p>Current implementation:</p> <ol> <li>Public expansion helpers return <code>str</code></li> <li>Expanding an already resolved string is a no-op (idempotent)</li> <li>Internal helpers may use data structures, but the public surface stays string-based</li> </ol> <p>Planned follow-up (tracked for a future release):</p> <ol> <li>Expose validation utilities (<code>is_resolved()</code>, <code>needs_expansion()</code>, <code>is_secret_uri()</code>)</li> <li>Keep those helpers optional enhancements rather than mandatory steps before calling <code>resolve()</code></li> </ol>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#rationale","title":"Rationale","text":"<p>Why string-based API:</p> <ul> <li>Zero friction: Users get exactly what they need (strings for <code>os.environ</code>)</li> <li>No conversion overhead: No need to extract <code>.value</code> or call conversion methods</li> <li>Easy integration: Works with existing code that expects strings</li> <li>Library positioning: Infrastructure utilities should be transparent, not opinionated</li> </ul> <p>Why idempotent resolution:</p> <ul> <li>Safety: Can safely apply <code>resolve()</code> to already-resolved values</li> <li>Composability: Easy to chain or apply conditionally without checks</li> <li>Simplicity: User doesn't need to track resolution state manually</li> </ul> <p>Why validation utilities:</p> <ul> <li>Explicit control: Users can check state before resolution if needed</li> <li>Debugging: Easy to verify if a value is resolved or needs processing</li> <li>Flexibility: Enables conditional logic based on value state</li> </ul>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#implications","title":"Implications","text":""},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#positive-implications","title":"Positive Implications","text":"<ul> <li>Superior user experience: Minimal API surface, intuitive usage</li> <li>Easy adoption: No learning curve for basic usage</li> <li>Type safety internally: Can still use Pydantic models for internal validation</li> <li>Flexible integration: Works with any code expecting strings</li> <li>Performance: No object allocation overhead in hot paths</li> </ul>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#concerns","title":"Concerns","text":"<ul> <li>Less metadata: Cannot return source location, resolution timestamp, etc.</li> <li>String validation: Determining if a string is \"resolved\" requires heuristics</li> </ul> <p>Mitigation:</p> <ul> <li>Metadata can be provided through separate functions if needed (e.g., <code>get_resolution_info()</code>)</li> <li>Validation functions use well-defined rules (e.g., \"no URI schemes, no variable references\")</li> </ul>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#alternatives","title":"Alternatives","text":""},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#model-based-api-with-metadata","title":"Model-Based API with Metadata","text":"<p>Return structured results with metadata:</p> <pre><code>result = resolve(\"akv://vault/secret\")  # \u2192 ResolutionResult\nsecret = result.value  # \u2192 str\nsource = result.source  # \u2192 \"akv://vault/secret\"\n</code></pre> <p>Pros:</p> <ul> <li>Rich metadata (source, timestamp, cache status, etc.)</li> <li>Type-safe error handling</li> <li>Explicit success/failure state</li> </ul> <p>Cons:</p> <ul> <li>Friction: Users must extract <code>.value</code> every time</li> <li>Type conversion overhead: Extra step for the common case</li> <li>Complex API: More to learn, more verbose code</li> <li>Poor fit: Environment variables are fundamentally strings</li> </ul> <p>Rejection reason: The overhead of type conversion outweighs metadata benefits. Users prioritize simplicity for infrastructure code.</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#non-idempotent-resolution-with-strict-validation","title":"Non-Idempotent Resolution with Strict Validation","text":"<p>Raise errors when resolving already-resolved values:</p> <pre><code>resolve(\"akv://vault/secret\")  # \u2192 str\nresolve(\"actual-secret-value\")  # \u2192 Error: not a URI\n</code></pre> <p>Pros:</p> <ul> <li>Explicit error on misuse</li> <li>Forces user awareness</li> </ul> <p>Cons:</p> <ul> <li>Not composable: Cannot safely chain operations</li> <li>User burden: Must track resolution state manually</li> <li>Fragile: Breaks if applied twice by accident</li> </ul> <p>Rejection reason: Idempotency is more valuable than strict validation in infrastructure code.</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#hybrid-approach-with-optional-metadata","title":"Hybrid Approach with Optional Metadata","text":"<p>Provide both simple and rich APIs:</p> <pre><code># Simple (returns str)\nsecret = resolve(\"akv://...\")\n\n# Rich (returns model)\nresult = resolve_with_metadata(\"akv://...\")\n</code></pre> <p>Pros:</p> <ul> <li>Best of both worlds</li> <li>User chooses complexity level</li> </ul> <p>Cons:</p> <ul> <li>API bloat: Two APIs to maintain</li> <li>Confusion: Which one to use?</li> <li>Maintenance burden: Keep both in sync</li> </ul> <p>Rejection reason: Adds complexity without clear benefit. Simple API with separate utility functions is cleaner.</p>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding optional logging/tracing for debugging (e.g., via context manager)</li> <li>Implement the planned validation helpers (<code>is_resolved()</code>, <code>needs_expansion()</code>, <code>is_secret_uri()</code>) as the next iterative step</li> <li>If metadata needs emerge, provide separate query functions: <code>get_source()</code>, <code>get_resolution_time()</code></li> <li>Monitor usage patterns; if metadata is frequently needed, reconsider hybrid approach in v2.x</li> </ul>"},{"location":"adr/0005-string-based-api-with-idempotent-resolution/#references","title":"References","text":"<ul> <li>ADR 0004: Stateless Function-Based Variable Expansion (established pattern of simple APIs)</li> <li>Discussion: Data models vs. string-based API for environment variable library</li> <li>Python stdlib <code>os.environ</code> - exclusively string-based, established pattern</li> <li>Issue #1: Variable expansion feature (informed by user needs)</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/","title":"ADR 0006: Two-Phase Iterative Algorithm for Nested Variable Expansion","text":""},{"location":"adr/0006-nested-variable-expansion-implementation/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0006-nested-variable-expansion-implementation/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0006-nested-variable-expansion-implementation/#context","title":"Context","text":"<p>The variable expansion service needs to support nested variable references like <code>${VAR_${NESTED}}</code>, where variable names themselves contain variable references that must be resolved first. This enables dynamic construction of variable names based on runtime values.</p> <p>Example use case:</p> <pre><code>ENV=prod\nDB_HOST=${DB_HOST_${ENV}}  # Should resolve to ${DB_HOST_prod}\nDB_HOST_prod=prod-server.example.com\n</code></pre> <p>Key requirements:</p> <ul> <li>Support arbitrary nesting depth (<code>${A_${B_${C}}}</code>)</li> <li>Maintain backward compatibility with simple expansion</li> <li>Detect circular references at any nesting level</li> <li>Provide clear error messages</li> <li>Acceptable performance for typical use cases</li> </ul> <p>Algorithm choices:</p> <ol> <li>Single-pass recursive regex: Replace variables recursively until no matches remain</li> <li>Two-phase iterative: Expand innermost curly braces first, then simple variables</li> <li>AST-based parser: Build syntax tree, evaluate bottom-up</li> <li>Multi-pass until stable: Keep expanding until output stops changing</li> </ol>"},{"location":"adr/0006-nested-variable-expansion-implementation/#decision","title":"Decision","text":"<p>Use a two-phase iterative algorithm that processes variables in phases:</p>"},{"location":"adr/0006-nested-variable-expansion-implementation/#phase-1-innermost-curly-braces","title":"Phase 1: Innermost Curly Braces","text":"<ul> <li>Pattern: <code>\\$\\{([^{}]+)\\}</code> (no nested braces)</li> <li>Expand innermost <code>${VAR}</code> references first</li> <li>Repeat until no more innermost curly braces match</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#phase-2-simple-variables","title":"Phase 2: Simple Variables","text":"<ul> <li>Pattern: <code>\\$([A-Za-z_][A-Za-z0-9_]*)\\b</code></li> <li>Expand <code>$VAR</code> syntax</li> <li>Repeat until no more simple variables match</li> </ul> <p>Algorithm:</p> <pre><code>def _expand_text(value: str, env: dict[str, str], stack: list[str]) -&gt; str:\n    current = value\n    while True:\n        # Phase 1: Expand innermost curly braces\n        if INNER_CURLY_PATTERN matches:\n            current = expand matches with _resolve()\n            continue\n\n        # Phase 2: Expand simple variables\n        if SIMPLE_VAR_PATTERN matches:\n            current = expand matches with _resolve()\n            continue\n\n        # No more matches - done or error\n        if unresolved patterns remain:\n            raise VariableNotFoundError\n        return current\n</code></pre>"},{"location":"adr/0006-nested-variable-expansion-implementation/#rationale","title":"Rationale","text":"<p>Why two-phase?</p> <ul> <li>Correctness: Innermost-first ensures nested references resolve correctly</li> <li>Predictability: Clear evaluation order (inside-out, left-to-right within phase)</li> <li>Error detection: Unresolved patterns after both phases indicate missing variables</li> </ul> <p>Why iterative over recursive?</p> <ul> <li>Stack safety: No recursion depth limits for deeply nested expressions</li> <li>Debuggability: Easier to trace expansion steps</li> <li>Performance: Avoids function call overhead for simple cases</li> </ul> <p>Why separate phases?</p> <ul> <li>Ambiguity resolution: <code>$VAR_${NESTED}</code> - which part expands first?</li> <li>Backward compatibility: Simple <code>${VAR}</code> and <code>$VAR</code> work as before</li> <li>Error clarity: Can distinguish between syntax errors and missing variables</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#implications","title":"Implications","text":""},{"location":"adr/0006-nested-variable-expansion-implementation/#positive-implications","title":"Positive Implications","text":"<ul> <li>Enables dynamic variable names: Powerful pattern for environment-specific configuration</li> <li>Maintains simplicity: Core algorithm remains understandable</li> <li>Preserves performance: Only iterates when variables are actually present</li> <li>Clear semantics: Inside-out evaluation matches user intuition</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#concerns","title":"Concerns","text":"<ul> <li>Performance: Deeply nested variables require multiple passes<ul> <li>Mitigation: Most real-world usage is 1-2 levels deep; still O(n*m) where m is nesting depth</li> </ul> </li> <li>Pattern ambiguity: <code>${VAR${NESTED}}</code> (missing underscore) is syntactically valid but confusing<ul> <li>Mitigation: Document best practices; users should use <code>${VAR_${NESTED}}</code></li> </ul> </li> <li>Infinite loop risk: Pattern must make progress each iteration<ul> <li>Mitigation: Iteration only continues if pattern matched; unresolved patterns raise errors</li> </ul> </li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#alternatives","title":"Alternatives","text":""},{"location":"adr/0006-nested-variable-expansion-implementation/#single-pass-recursive-regex","title":"Single-Pass Recursive Regex","text":"<p>Recursively expand all variables in one pass:</p> <pre><code>pattern = r\"\\$\\{([^}]+)\\}|\\$([A-Za-z_][A-Za-z0-9_]*)\"\nre.sub(pattern, replace_func, text)\n</code></pre> <ul> <li>Pros: Simple implementation, single pass</li> <li>Cons:<ul> <li>Cannot handle nested braces correctly</li> <li><code>${VAR_${NESTED}}</code> - inner <code>${NESTED}</code> not matched by <code>[^}]+</code></li> <li>Would need complex lookahead/lookbehind patterns</li> </ul> </li> <li>Rejection reason: Regex cannot elegantly handle nested structures</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#ast-based-parser","title":"AST-Based Parser","text":"<p>Build abstract syntax tree, evaluate bottom-up:</p> <pre><code>ast = parse(\"${VAR_${NESTED}}\")\n# \u2192 BraceExpansion(\n#     name=Concat([Literal(\"VAR_\"), BraceExpansion(name=\"NESTED\")])\n#   )\nresult = evaluate(ast, env)\n</code></pre> <ul> <li>Pros:<ul> <li>Very explicit structure</li> <li>Easy to add features (filters, default values)</li> <li>Excellent error reporting with positions</li> </ul> </li> <li>Cons:<ul> <li>Significant complexity overhead</li> <li>Requires lexer, parser, evaluator</li> <li>Overkill for current feature set</li> </ul> </li> <li>Rejection reason: Complexity not justified for variable expansion use case</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#multi-pass-until-stable","title":"Multi-Pass Until Stable","text":"<p>Keep expanding until output stops changing:</p> <pre><code>while True:\n    new_value = expand_once(current, env)\n    if new_value == current:\n        break\n    current = new_value\n</code></pre> <ul> <li>Pros: Handles any nesting depth automatically</li> <li>Cons:<ul> <li>Risk of infinite loops if pattern produces itself</li> <li>Harder to detect true errors vs. stability</li> <li>No clear phase ordering for mixed syntax</li> </ul> </li> <li>Rejection reason: Less predictable behavior, harder error handling</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#greedy-regex-with-backtracking","title":"Greedy Regex with Backtracking","text":"<p>Use greedy matching with backtracking for nested patterns:</p> <pre><code>pattern = r\"\\$\\{([^{}]|\\{[^{}]*\\})*\\}\"\n</code></pre> <ul> <li>Pros: Single regex pattern</li> <li>Cons:<ul> <li>Regex complexity explodes with nesting depth</li> <li>Poor error messages on mismatch</li> <li>Performance degrades with deep nesting (catastrophic backtracking risk)</li> </ul> </li> <li>Rejection reason: Regex is wrong tool for nested structures</li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#future-direction","title":"Future Direction","text":"<ul> <li> <p>Performance optimization: If profiling shows issues, consider:</p> <ul> <li>Compile patterns once (already done with module-level <code>re.compile</code>)</li> <li>Add depth limit to prevent pathological cases</li> <li>Cache expansion results for repeated patterns</li> </ul> </li> <li> <p>Enhanced error messages: Show partial expansion state when errors occur:</p> </li> </ul> <pre><code>VariableNotFoundError: MISSING\nDuring expansion of: \"${DB_${ENV}}\" \u2192 \"${DB_prod}\" \u2192 \"${DB_prod_MISSING}\"\n</code></pre> <ul> <li> <p>Syntax extensions: If needed, two-phase algorithm can be extended:</p> <ul> <li>Default values: <code>${VAR:-default}</code></li> <li>Filters: <code>${VAR|lowercase}</code></li> <li>Escape sequences: <code>\\${NOT_A_VAR}</code></li> </ul> </li> <li> <p>Migration to AST: If feature set grows significantly (10+ syntax features), consider AST-based approach for maintainability</p> </li> </ul>"},{"location":"adr/0006-nested-variable-expansion-implementation/#references","title":"References","text":"<ul> <li>ADR 0001: Regular expressions for variable expansion</li> <li>ADR 0004: Stateless function-based variable expansion</li> <li>Implementation: <code>src/envresolve/services/expansion.py</code></li> <li>Test cases: <code>tests/unit/test_expansion.py::test_expand_nested_curly_braces</code></li> <li>Bash variable expansion: https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/","title":"ADR 0007: Separate Services Layer (Pure Logic) from Application Layer (Environment Integration)","text":""},{"location":"adr/0007-layer-separation-services-vs-application/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0007-layer-separation-services-vs-application/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0007-layer-separation-services-vs-application/#context","title":"Context","text":"<p>As envresolve evolved, the <code>services/expansion.py</code> module contained both:</p> <ul> <li>Pure logic: <code>expand_variables(text, env)</code> - stateless string transformation</li> <li>Environment integration: <code>EnvExpander</code>, <code>DotEnvExpander</code> - classes that access <code>os.environ</code> and read <code>.env</code> files</li> </ul> <p>This mixing of concerns violated clean architecture principles:</p> <ul> <li>Services layer should contain pure business logic (testable without I/O)</li> <li>Environment/file I/O are infrastructure concerns</li> <li>Clear dependency direction ensures maintainability</li> </ul> <p>The question: Where should <code>EnvExpander</code> and <code>DotEnvExpander</code> reside?</p> <p>Options:</p> <ol> <li>Keep everything in services layer (current state before this ADR)</li> <li>Move expanders to a new application layer</li> <li>Move expanders to an infrastructure layer</li> <li>Create separate modules for each concern (services, io, etc.)</li> </ol>"},{"location":"adr/0007-layer-separation-services-vs-application/#decision","title":"Decision","text":"<p>Introduce an application layer and move <code>EnvExpander</code> and <code>DotEnvExpander</code> to <code>application/expanders.py</code>, while keeping <code>expand_variables</code> in <code>services/expansion.py</code>.</p> <p>Layer structure:</p> <pre><code>application/expanders.py    # EnvExpander, DotEnvExpander (environment integration)\n    \u2193 depends on\nservices/expansion.py       # expand_variables (pure logic)\n    \u2193 depends on\nexceptions.py              # Domain exceptions\n</code></pre> <p>Responsibility assignment:</p> <p>Services layer (<code>services/expansion.py</code>):</p> <ul> <li>Pure string transformation logic</li> <li><code>expand_variables(text: str, env: dict[str, str]) -&gt; str</code></li> <li>No I/O, no external dependencies beyond stdlib</li> <li>Easily testable with any dictionary</li> </ul> <p>Application layer (<code>application/expanders.py</code>):</p> <ul> <li>Integration with operating system and file system</li> <li><code>EnvExpander</code> - reads from <code>os.environ</code></li> <li><code>DotEnvExpander</code> - reads from <code>.env</code> files</li> <li>Coordinates services layer with external systems</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#rationale","title":"Rationale","text":"<p>Why separate layers?</p> <ul> <li>Single Responsibility Principle: Each layer has one reason to change<ul> <li>Services: Change when expansion logic needs modification</li> <li>Application: Change when integration with environment/files changes</li> </ul> </li> <li>Testability: Pure logic can be tested without mocking <code>os.environ</code> or file system</li> <li>Reusability: <code>expand_variables</code> can be used in any context, not just with environment variables</li> <li>Clear dependencies: Application depends on services, never the reverse</li> </ul> <p>Why \"application\" layer over \"infrastructure\"?</p> <ul> <li>Common terminology: Application layer coordinates business logic with external systems</li> <li>Infrastructure typically means: Lower-level concerns (database, network, logging)</li> <li>Expanders are use-case coordinators: They adapt the pure expansion service to specific environments</li> <li>Consistent with common patterns: Application layer is well-established for coordinating use cases</li> </ul> <p>Why not keep in services?</p> <ul> <li>Services should be pure and I/O-free</li> <li>Mixing pure logic with I/O makes testing harder</li> <li>Violates dependency inversion principle (high-level policy mixed with low-level details)</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#implications","title":"Implications","text":""},{"location":"adr/0007-layer-separation-services-vs-application/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clear boundaries: Easy to identify pure logic vs. integration code</li> <li>Better testability:<ul> <li>Services: Test with simple dictionaries</li> <li>Application: Mock only the environment/file system, not expansion logic</li> </ul> </li> <li>Easier to extend: New integrations (e.g., <code>ConfigFileExpander</code>) go in application layer</li> <li>Dependency graph clarity: Obvious which direction dependencies flow</li> <li>Matches established patterns: Follows Clean Architecture, Hexagonal Architecture principles</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#concerns","title":"Concerns","text":"<ul> <li>More files: Instead of one <code>expansion.py</code>, now have <code>services/expansion.py</code> and <code>application/expanders.py</code><ul> <li>Mitigation: Better organization outweighs small increase in file count</li> </ul> </li> <li>Import path changes: Public API imports from two places<ul> <li>Mitigation: <code>__init__.py</code> exports both, so users only see <code>envresolve.expand_variables</code>, etc.</li> </ul> </li> <li>Over-engineering risk: Small library might not need this complexity<ul> <li>Mitigation: Separation is simple and pays dividends as library grows</li> </ul> </li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#alternatives","title":"Alternatives","text":""},{"location":"adr/0007-layer-separation-services-vs-application/#keep-everything-in-services-layer","title":"Keep Everything in Services Layer","text":"<p>Keep <code>expand_variables</code>, <code>EnvExpander</code>, <code>DotEnvExpander</code> together in <code>services/expansion.py</code>.</p> <ul> <li>Pros:<ul> <li>Fewer files</li> <li>Everything related to expansion in one place</li> <li>Simpler import structure</li> </ul> </li> <li>Cons:<ul> <li>Mixed responsibilities (pure logic + I/O)</li> <li>Harder to test pure logic without mocking</li> <li>Dependency inversion violation</li> <li>Services layer depends on <code>os</code>, <code>pathlib</code>, <code>dotenv</code></li> </ul> </li> <li>Rejection reason: Sacrifices architectural clarity for minor convenience</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#move-to-infrastructure-layer","title":"Move to Infrastructure Layer","text":"<p>Create <code>infrastructure/environment.py</code> and <code>infrastructure/files.py</code> for expanders.</p> <ul> <li>Pros:<ul> <li>Clear I/O boundary</li> <li>Infrastructure layer is common pattern</li> </ul> </li> <li>Cons:<ul> <li>Infrastructure typically means low-level adapters (database, network)</li> <li>Expanders are use-case coordinators, not low-level adapters</li> <li>Creates confusion about infrastructure vs. application</li> </ul> </li> <li>Rejection reason: Incorrect use of \"infrastructure\" terminology</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#flatten-into-multiple-modules","title":"Flatten into Multiple Modules","text":"<p>Create separate modules at same level:</p> <ul> <li><code>expansion.py</code> - pure logic</li> <li><code>env_integration.py</code> - <code>EnvExpander</code></li> <li> <p><code>file_integration.py</code> - <code>DotEnvExpander</code></p> </li> <li> <p>Pros:</p> <ul> <li>Very granular separation</li> <li>Easy to find specific functionality</li> </ul> </li> <li>Cons:<ul> <li>No clear layer structure</li> <li>Harder to understand dependency direction</li> <li>Too many small files for small library</li> </ul> </li> <li>Rejection reason: Over-fragmentation without clear architectural benefit</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#inline-into-public-api","title":"Inline into Public API","text":"<p>Move expanders to <code>api.py</code> alongside public API exports.</p> <ul> <li>Pros:<ul> <li>All public-facing code in one place</li> <li>Minimal files</li> </ul> </li> <li>Cons:<ul> <li><code>api.py</code> becomes dumping ground for everything</li> <li>No separation of concerns</li> <li>Harder to extend with more expander types</li> </ul> </li> <li>Rejection reason: API layer should be thin facade, not contain implementations</li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#future-direction","title":"Future Direction","text":"<ul> <li> <p>Additional application-layer components:</p> <ul> <li><code>application/resolver.py</code> - Secret URI resolution orchestration (when implementing <code>akv://</code> support)</li> <li><code>application/cache.py</code> - TTL caching for resolved secrets</li> <li><code>application/loaders.py</code> - High-level <code>load_env()</code> functionality</li> </ul> </li> <li> <p>Potential infrastructure layer: If we add adapters for external systems:</p> <ul> <li><code>infrastructure/azure_kv.py</code> - Azure Key Vault client adapter</li> <li><code>infrastructure/aws_secrets.py</code> - AWS Secrets Manager adapter</li> <li>These would be low-level I/O adapters, distinct from application coordinators</li> </ul> </li> <li> <p>Re-evaluate if library grows: If services layer grows to 10+ modules, consider:</p> <ul> <li>Domain-driven design with aggregates</li> <li>More sophisticated layering (use cases, repositories, etc.)</li> </ul> </li> </ul>"},{"location":"adr/0007-layer-separation-services-vs-application/#references","title":"References","text":"<ul> <li>Clean Architecture (Robert C. Martin): https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html</li> <li>Hexagonal Architecture (Alistair Cockburn): https://alistair.cockburn.us/hexagonal-architecture/</li> <li>Implementation: <code>src/envresolve/application/expanders.py</code>, <code>src/envresolve/services/expansion.py</code></li> <li>Issue discussion: API redesign and layer separation</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/","title":"ADR 0008: Track and Report Full Reference Chain in Circular Reference Errors","text":""},{"location":"adr/0008-circular-reference-chain-tracking/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0008-circular-reference-chain-tracking/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0008-circular-reference-chain-tracking/#context","title":"Context","text":"<p>Following ADR 0003 (Structured Exception Design), <code>CircularReferenceError</code> was designed to include structured data about the error. The initial implementation included only the variable name that caused the circular reference:</p> <pre><code>class CircularReferenceError(EnvResolveError):\n    def __init__(self, variable_name: str):\n        self.variable_name = variable_name\n        super().__init__(f\"Circular reference detected: {variable_name}\")\n</code></pre> <p>However, when debugging circular references in complex configurations, users need to see the full reference chain that led to the cycle, not just the variable where the cycle was detected.</p> <p>Example scenario:</p> <pre><code>A=${B}\nB=${C}\nC=${D}\nD=${A}  # Cycle here\n</code></pre> <p>Current error: <code>\"Circular reference detected: A\"</code></p> <ul> <li>User doesn't know which variables are involved in the cycle</li> <li>Hard to trace back through the reference chain</li> <li>Requires manual inspection of all variables to find the loop</li> </ul> <p>Desired error: <code>\"Circular reference detected: A -&gt; B -&gt; C -&gt; D -&gt; A\"</code></p> <ul> <li>Clear visualization of the complete cycle</li> <li>Easy to identify all variables involved</li> <li>Immediate understanding of the problem</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#decision","title":"Decision","text":"<p>Extend <code>CircularReferenceError</code> to track and report the full reference chain that forms the cycle:</p> <pre><code>class CircularReferenceError(EnvResolveError):\n    def __init__(self, variable_name: str, chain: list[str] | None = None):\n        self.variable_name = variable_name\n        self.chain = chain or []\n        chain_str = \" -&gt; \".join(self.chain) if self.chain else variable_name\n        msg = f\"Circular reference detected: {chain_str}\"\n        super().__init__(msg)\n</code></pre> <p>Implementation approach:</p> <ul> <li>Maintain a <code>stack: list[str]</code> during recursive expansion</li> <li>When a variable already in the stack is encountered, extract the cycle portion</li> <li>Pass the cycle chain to <code>CircularReferenceError</code> constructor</li> <li>Format chain as <code>\"A -&gt; B -&gt; C -&gt; A\"</code> in error message</li> </ul> <p>Algorithm:</p> <pre><code>def _resolve(var_name: str, env: dict[str, str], stack: list[str]) -&gt; str:\n    if var_name in stack:\n        # Found cycle - extract the cycle portion\n        cycle_start = stack.index(var_name)\n        cycle = [*stack[cycle_start:], var_name]\n        raise CircularReferenceError(var_name, cycle)\n\n    stack.append(var_name)\n    try:\n        return _expand_text(env[var_name], env, stack)\n    finally:\n        stack.pop()\n</code></pre>"},{"location":"adr/0008-circular-reference-chain-tracking/#rationale","title":"Rationale","text":"<p>Why track full chain?</p> <ul> <li>Debugging efficiency: Users immediately see the problem without manual tracing</li> <li>Error clarity: Complex cycles (<code>A -&gt; B -&gt; C -&gt; D -&gt; A</code>) are instantly visible</li> <li>Actionable information: Users know exactly which variables to fix</li> </ul> <p>Why format as \"A -&gt; B -&gt; A\"?</p> <ul> <li>Visual clarity: Arrow notation is intuitive and commonly used</li> <li>Cycle visibility: Showing start and end makes the loop obvious</li> <li>Familiarity: Matches stack trace and dependency chain conventions</li> </ul> <p>Why list of strings over single string?</p> <ul> <li>Programmatic access: Callers can analyze the chain (<code>len(exc.chain)</code> for cycle length)</li> <li>Testing: Can assert specific cycles in tests</li> <li>Future flexibility: Can format chain differently (JSON, graph, etc.)</li> <li>Consistency: Follows ADR 0003's principle of structured data over formatted strings</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#implications","title":"Implications","text":""},{"location":"adr/0008-circular-reference-chain-tracking/#positive-implications","title":"Positive Implications","text":"<ul> <li>Better user experience: Errors are immediately actionable</li> <li>Reduced debugging time: No need to manually trace through variable definitions</li> <li>Professional error messages: Clear, informative, helpful</li> <li>Testing improvement: Can verify exact cycle detection logic</li> <li>Programmatic error handling: Tools can analyze circular dependencies automatically</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#concerns","title":"Concerns","text":"<ul> <li>Memory overhead: Storing chain list for each error<ul> <li>Mitigation: Chains are typically 2-10 variables; minimal memory impact</li> <li>Errors are exceptional path, not hot path</li> </ul> </li> <li>Stack management complexity: Need to pass and maintain stack through recursion<ul> <li>Mitigation: Stack is implementation detail, not exposed in public API</li> <li>Clear with try/finally pattern</li> </ul> </li> <li>Chain extraction logic: Must correctly identify cycle portion<ul> <li>Mitigation: Simple slice operation <code>stack[cycle_start:]</code></li> <li>Well-tested in unit tests</li> </ul> </li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#alternatives","title":"Alternatives","text":""},{"location":"adr/0008-circular-reference-chain-tracking/#variable-name-only-original-design","title":"Variable Name Only (Original Design)","text":"<p>Keep only <code>variable_name</code> without chain:</p> <pre><code>class CircularReferenceError(EnvResolveError):\n    def __init__(self, variable_name: str):\n        super().__init__(f\"Circular reference detected: {variable_name}\")\n</code></pre> <ul> <li>Pros:<ul> <li>Simplest implementation</li> <li>Minimal memory usage</li> <li>No stack tracking needed</li> </ul> </li> <li>Cons:<ul> <li>Poor debugging experience</li> <li>User must manually trace references</li> <li>Hard to identify long cycles</li> </ul> </li> <li>Rejection reason: Sacrifices usability for minimal complexity reduction</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#full-stack-trace-in-error-message","title":"Full Stack Trace in Error Message","text":"<p>Include full Python stack trace showing function calls:</p> <pre><code>import traceback\nmsg = f\"Circular reference: {variable_name}\\n{traceback.format_stack()}\"\n</code></pre> <ul> <li>Pros:<ul> <li>Shows complete execution context</li> <li>Includes line numbers and file names</li> </ul> </li> <li>Cons:<ul> <li>Cluttered with implementation details (internal function names)</li> <li>Confuses users with irrelevant information</li> <li>Chain is buried in noise</li> </ul> </li> <li>Rejection reason: Too much information, not user-focused</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#lazy-chain-computation","title":"Lazy Chain Computation","text":"<p>Don't track chain during expansion; recompute if error occurs:</p> <pre><code>def find_cycle(var_name: str, env: dict[str, str]) -&gt; list[str]:\n    # Re-traverse to find cycle\n    visited = []\n    current = var_name\n    while current not in visited:\n        visited.append(current)\n        current = extract_next_var(env[current])\n    return visited[visited.index(current):]\n</code></pre> <ul> <li>Pros:<ul> <li>No overhead during normal execution</li> <li>Chain only computed when error occurs</li> </ul> </li> <li>Cons:<ul> <li>Complex re-traversal logic</li> <li>May not find exact same cycle (if nested expansion)</li> <li>Requires parsing variable references again</li> </ul> </li> <li>Rejection reason: Complexity outweighs benefits; expansion already maintains stack</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#set-based-cycle-detection-only","title":"Set-Based Cycle Detection Only","text":"<p>Use a set for fast lookup, don't track order:</p> <pre><code>visited = set()\nif var_name in visited:\n    raise CircularReferenceError(var_name, list(visited))\n</code></pre> <ul> <li>Pros:<ul> <li>Fast O(1) lookup</li> <li>Simple implementation</li> </ul> </li> <li>Cons:<ul> <li>Set is unordered; can't show reference chain in correct order</li> <li>Cycle path is lost (which variables led to which)</li> <li>Error message is confusing: \"Circular reference in {C, A, B, D}\" (no order)</li> </ul> </li> <li>Rejection reason: Order is critical for understanding the problem</li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#future-direction","title":"Future Direction","text":"<ul> <li> <p>Cycle visualization: For complex cycles, consider:</p> <ul> <li>ASCII art diagram showing the cycle</li> <li>Graphviz DOT format for automated visualization</li> <li>Suggestion of which variable to change</li> </ul> </li> <li> <p>Cycle length limits: If cycles exceed N variables, truncate display:</p> </li> </ul> <pre><code>\"Circular reference: A -&gt; B -&gt; ... -&gt; Y -&gt; Z -&gt; A (50 variables in cycle)\"\n</code></pre> <ul> <li> <p>Interactive debugging: If running in interactive environment:</p> <ul> <li>Highlight cycle variables in configuration file</li> <li>Suggest breaking the cycle with environment override</li> </ul> </li> <li> <p>Multiple cycle detection: Currently stops at first cycle found:</p> <ul> <li>Consider detecting all cycles in a configuration</li> <li>Report all cycles together for comprehensive fix</li> </ul> </li> <li> <p>Performance monitoring: Track cycle detection overhead:</p> <ul> <li>If stack management becomes bottleneck, optimize</li> <li>Consider specialized data structure for large configurations</li> </ul> </li> </ul>"},{"location":"adr/0008-circular-reference-chain-tracking/#references","title":"References","text":"<ul> <li>ADR 0003: Structured Exception Design (establishes pattern of structured data in exceptions)</li> <li>Implementation: <code>src/envresolve/exceptions.py::CircularReferenceError</code></li> <li>Implementation: <code>src/envresolve/services/expansion.py::_resolve</code></li> <li>Test cases: <code>tests/unit/test_expansion.py::test_circular_reference_raises_error</code></li> <li>Graph cycle detection algorithms: https://en.wikipedia.org/wiki/Cycle_detection</li> <li>Error message best practices: https://developers.google.com/tech-writing/error-messages</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/","title":"ADR 0009: Use Manual Provider Registration with Global Registry","text":""},{"location":"adr/0009-manual-provider-registration-pattern/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0009-manual-provider-registration-pattern/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0009-manual-provider-registration-pattern/#context","title":"Context","text":"<p>The Azure Key Vault secret resolution feature (Issue #3) required a mechanism to integrate secret providers with the resolution system. Several architectural questions arose:</p> <ol> <li>How should providers be discovered and registered?</li> <li>Should provider registration be automatic or explicit?</li> <li>How should the provider registry be structured?</li> <li>Should providers be singletons or instantiated per use?</li> </ol> <p>Key constraints:</p> <ul> <li>Users may not need all provider types (e.g., only Azure, not AWS)</li> <li>Provider initialization may require credentials or configuration</li> <li>Library should support multiple secret backends (Azure KV, AWS Secrets Manager, etc.)</li> <li>API should be simple and discoverable</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#decision","title":"Decision","text":"<p>Use manual provider registration with a global registry:</p> <ol> <li>Manual registration: Users explicitly call <code>register_azure_kv_provider()</code> before resolving secrets</li> <li>Global registry: Module-level <code>_PROVIDERS</code> dict maps URI schemes to provider instances</li> <li>Singleton providers: One provider instance per scheme, reused across all resolutions</li> <li>Explicit API: Registration functions are top-level exports (e.g., <code>envresolve.register_azure_kv_provider()</code>)</li> </ol> <p>Implementation pattern:</p> <pre><code># api.py\n_PROVIDERS: dict[str, SecretProvider] = {}\n\ndef register_azure_kv_provider() -&gt; None:\n    \"\"\"Register Azure Key Vault provider for akv:// and kv:// schemes.\"\"\"\n    provider = AzureKVProvider()\n    _PROVIDERS[\"akv\"] = provider\n    _PROVIDERS[\"kv\"] = provider  # Alias\n\ndef _get_provider(scheme: str) -&gt; SecretProvider:\n    \"\"\"Get provider for scheme, raise if not registered.\"\"\"\n    if scheme not in _PROVIDERS:\n        raise SecretResolutionError(f\"No provider registered for scheme '{scheme}'\")\n    return _PROVIDERS[scheme]\n</code></pre>"},{"location":"adr/0009-manual-provider-registration-pattern/#rationale","title":"Rationale","text":"<p>Why manual registration?</p> <ul> <li>Opt-in dependencies: Users only install and register providers they need</li> <li>Explicit control: Clear when providers are initialized (e.g., after credential setup)</li> <li>No magic: Obvious what's happening, easier to debug</li> <li>Configuration flexibility: Can pass custom credentials or config during registration</li> </ul> <p>Why global registry?</p> <ul> <li>Simplicity: No need to pass registry through call chains</li> <li>Singleton benefits: Provider instances can cache connections (e.g., Azure SecretClient per vault)</li> <li>Idempotent registration: Safe to call <code>register_*()</code> multiple times</li> <li>Thread-safe for reads: Once registered, providers are read-only</li> </ul> <p>Why singleton providers?</p> <ul> <li>Resource efficiency: Reuse authenticated clients across resolutions</li> <li>Connection pooling: Provider maintains connection cache internally</li> <li>Stateless operations: <code>resolve()</code> method is stateless, safe to share</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#implications","title":"Implications","text":""},{"location":"adr/0009-manual-provider-registration-pattern/#positive-implications","title":"Positive Implications","text":"<ul> <li>Clear API surface: <code>register_*()</code> functions are discoverable via autocomplete</li> <li>Lazy loading: Only imported providers are loaded (no startup overhead)</li> <li>Testability: Easy to mock providers by registering test implementations</li> <li>Extensibility: New providers follow same pattern (e.g., <code>register_aws_provider()</code>)</li> <li>Error messages: Clear \"provider not registered\" errors guide users</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#concerns","title":"Concerns","text":"<ul> <li> <p>Manual setup required: Users must remember to call <code>register_*()</code> before use</p> <ul> <li>Mitigation: Clear error messages with registration instructions</li> <li>Mitigation: Examples in documentation show registration as first step</li> </ul> </li> <li> <p>Global state: Module-level registry is mutable global state</p> <ul> <li>Mitigation: Registration is write-once in typical usage</li> <li>Mitigation: Tests can clear registry between test cases if needed</li> <li>Future: Consider making registry explicit parameter for advanced use cases</li> </ul> </li> <li> <p>No auto-discovery: Cannot scan for available providers automatically</p> <ul> <li>Mitigation: Explicit is better than implicit (Zen of Python)</li> <li>Future: Optional <code>register_all()</code> for convenience if many providers exist</li> </ul> </li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#alternatives","title":"Alternatives","text":""},{"location":"adr/0009-manual-provider-registration-pattern/#auto-registration-via-import","title":"Auto-Registration via Import","text":"<p>Automatically register providers when modules are imported:</p> <pre><code># providers/azure_kv.py\n# Auto-registers on import\nfrom envresolve.api import _PROVIDERS\n_PROVIDERS[\"akv\"] = AzureKVProvider()\n</code></pre> <ul> <li>Pros: No manual registration needed, automatic discovery</li> <li>Cons:<ul> <li>Imports have side effects (anti-pattern)</li> <li>Cannot control initialization timing</li> <li>Cannot pass configuration</li> <li>Harder to test (import side effects)</li> <li>Forces loading of all provider dependencies</li> </ul> </li> <li>Rejection reason: Side effects on import violate Python best practices; explicit is better</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#registry-as-explicit-parameter","title":"Registry as Explicit Parameter","text":"<p>Pass registry explicitly through function calls:</p> <pre><code>registry = ProviderRegistry()\nregistry.register(\"akv\", AzureKVProvider())\nresult = resolve_secret(\"akv://...\", registry=registry)\n</code></pre> <ul> <li>Pros:<ul> <li>No global state</li> <li>Easy to use multiple registries</li> <li>Explicit dependency injection</li> </ul> </li> <li>Cons:<ul> <li>Verbose - every call needs registry parameter</li> <li>Poor ergonomics for simple use cases</li> <li>Complicates API significantly</li> </ul> </li> <li>Rejection reason: Over-engineered for typical use; global registry is simpler</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#plugin-system-with-entry-points","title":"Plugin System with Entry Points","text":"<p>Use setuptools entry points for automatic discovery:</p> <pre><code># setup.py\nentry_points={\n    \"envresolve.providers\": [\n        \"akv = envresolve.providers.azure_kv:AzureKVProvider\"\n    ]\n}\n</code></pre> <ul> <li>Pros:<ul> <li>Standard Python plugin pattern</li> <li>Extensible by third-party packages</li> <li>Auto-discovery without imports</li> </ul> </li> <li>Cons:<ul> <li>Overkill for first-party providers</li> <li>Complexity in initialization and configuration</li> <li>Harder to debug</li> <li>Not needed until third-party provider ecosystem exists</li> </ul> </li> <li>Rejection reason: Premature optimization; manual registration is sufficient for v0.1.x</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#factory-pattern-with-builder","title":"Factory Pattern with Builder","text":"<p>Use factory pattern for provider creation:</p> <pre><code>provider = ProviderFactory.create(\"azure_kv\", vault=\"my-vault\")\nresult = resolve_secret(\"akv://...\", provider=provider)\n</code></pre> <ul> <li>Pros:<ul> <li>Flexible provider configuration</li> <li>No global state</li> </ul> </li> <li>Cons:<ul> <li>Users must manage provider lifecycle</li> <li>Verbose for simple cases</li> <li>Cannot share providers across resolutions</li> </ul> </li> <li>Rejection reason: Too much manual management; global registry with caching is better</li> </ul>"},{"location":"adr/0009-manual-provider-registration-pattern/#future-direction","title":"Future Direction","text":"<ul> <li>Optional <code>register_all()</code> convenience: If many providers exist, provide single-call registration:</li> </ul> <pre><code>envresolve.register_all()  # Registers all installed providers\n</code></pre> <ul> <li>Registry introspection: Add query functions if needed:</li> </ul> <pre><code>envresolve.list_providers()  # \u2192 [\"akv\", \"kv\", \"aws\"]\nenvresolve.is_provider_registered(\"akv\")  # \u2192 bool\n</code></pre> <ul> <li> <p>Thread-safe registry mutations: If use cases emerge for dynamic provider registration in threaded environments, add locking</p> </li> <li> <p>Custom registries for advanced use cases: Support optional explicit registry parameter:</p> </li> </ul> <pre><code>custom_registry = ProviderRegistry()\nresolve_secret(\"akv://...\", registry=custom_registry)  # Override global\n</code></pre> <ul> <li>Provider configuration API: If providers need complex configuration, add builder pattern:</li> </ul> <pre><code>register_azure_kv_provider(\n    credential=my_credential,\n    cache_ttl=600,\n    retry_policy=my_policy\n)\n</code></pre>"},{"location":"adr/0009-manual-provider-registration-pattern/#references","title":"References","text":"<ul> <li>Issue #3: Azure Key Vault secret resolution support</li> <li>Implementation: <code>src/envresolve/api.py</code> (registry and registration functions)</li> <li>Implementation: <code>src/envresolve/providers/azure_kv.py</code> (provider implementation)</li> <li>Python Zen: \"Explicit is better than implicit\"</li> <li>Python anti-patterns: Import-time side effects</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/","title":"ADR 0010: Iterative URI Resolution with Cycle Detection","text":""},{"location":"adr/0010-iterative-uri-resolution/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0010-iterative-uri-resolution/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0010-iterative-uri-resolution/#context","title":"Context","text":"<p>Secret URIs may resolve to values containing other URIs or variables requiring further expansion. This occurs in scenarios like:</p> <ul> <li>Gradual migration: <code>akv://vault/old-name</code> \u2192 <code>\"akv://vault/new-name\"</code> \u2192 actual secret</li> <li>Multi-level indirection for access control or configuration management</li> <li>Variable expansion in resolved values: <code>akv://vault/indirect</code> \u2192 <code>\"akv://vault/${KEY}\"</code> \u2192 needs expansion</li> </ul> <p>Without iterative resolution, users would need manual multi-step resolution. We need to maintain idempotency (plain strings return unchanged) while detecting circular references.</p>"},{"location":"adr/0010-iterative-uri-resolution/#decision","title":"Decision","text":"<p>Implement iterative resolution in <code>SecretResolver.resolve()</code> with cycle detection using a <code>seen</code> set:</p> <pre><code>seen = set()\ncurrent = uri\n\nwhile True:\n    if current in seen:\n        raise CircularReferenceError(variable_name=current, chain=[*list(seen), current])\n    seen.add(current)\n\n    expanded = expand_variables(current, env)\n    if not is_secret_uri(expanded):\n        return expanded  # Termination: not a URI\n\n    resolved = provider.resolve(parse_secret_uri(expanded))\n    if resolved == current:\n        return resolved  # Termination: stable value\n\n    current = resolved\n</code></pre>"},{"location":"adr/0010-iterative-uri-resolution/#rationale","title":"Rationale","text":"<ul> <li>Idempotency: Plain strings and non-target URIs return immediately without provider calls</li> <li>Flexibility: Supports arbitrary nesting depth and mixed variable/URI resolution</li> <li>Safety: <code>seen</code> set guarantees cycle detection without infinite loops</li> <li>Simplicity: Single resolution entry point handles all cases uniformly</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#implications","title":"Implications","text":""},{"location":"adr/0010-iterative-uri-resolution/#positive-implications","title":"Positive Implications","text":"<ul> <li>Users can chain URIs across vaults for access control patterns</li> <li>Variable expansion works at any nesting level</li> <li>Backward compatibility: existing single-level URIs work unchanged</li> <li>Idempotency ensures safe repeated calls</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#concerns","title":"Concerns","text":"<ul> <li>Performance: Multiple provider calls increase latency. Mitigation: Future TTL cache (ADR-pending)</li> <li>Debugging: Long resolution chains are hard to trace. Mitigation: <code>CircularReferenceError</code> includes full chain</li> <li>Complexity: Harder to reason about multi-step resolution. Mitigation: Comprehensive E2E tests (7 test cases)</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#alternatives","title":"Alternatives","text":""},{"location":"adr/0010-iterative-uri-resolution/#1-single-pass-resolution-only","title":"1. Single-pass resolution only","text":"<ul> <li>Simpler implementation</li> <li>Rejected: Users would need manual multi-step calls</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#2-recursive-resolution","title":"2. Recursive resolution","text":"<ul> <li>More functional style</li> <li>Rejected: Stack overflow risk, harder to track seen values</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#3-fixed-depth-limit-eg-max-10-iterations","title":"3. Fixed depth limit (e.g., max 10 iterations)","text":"<ul> <li>Simpler termination logic</li> <li>Rejected: Arbitrary limit; cycle detection is more robust</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#future-direction","title":"Future Direction","text":"<ul> <li>Add resolution metrics/logging for observability</li> <li>Consider optional depth limit as safety net (configurable, default disabled)</li> <li>Implement TTL cache to reduce redundant provider calls</li> <li>Evaluate async resolution for parallel multi-vault lookups</li> </ul>"},{"location":"adr/0010-iterative-uri-resolution/#references","title":"References","text":"<ul> <li>E2E tests: <code>tests/e2e/test_nested_resolution.py</code></li> <li>Unit tests: <code>tests/unit/test_resolver.py</code></li> <li>Implementation: <code>src/envresolve/application/resolver.py:34-95</code></li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/","title":"ADR 0011: Conditional Doctest Skip Based on Optional Dependencies","text":""},{"location":"adr/0011-conditional-doctest-skip/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0011-conditional-doctest-skip/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0011-conditional-doctest-skip/#context","title":"Context","text":"<p>Doctests in <code>api.py</code> demonstrate Azure Key Vault usage, but fail when <code>azure-identity</code> and <code>azure-keyvault-secrets</code> are not installed. Using <code># doctest: +SKIP</code> unconditionally skips these examples even when Azure SDK is available, preventing validation of documentation examples.</p> <p>We need doctests to:</p> <ul> <li>Run and validate when Azure SDK is installed</li> <li>Skip gracefully when Azure SDK is absent</li> <li>Work consistently across local development and CI environments</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#decision","title":"Decision","text":"<p>Implement pytest fixture-based conditional skipping in root <code>conftest.py</code>:</p> <pre><code>def _azure_sdk_available() -&gt; bool:\n    try:\n        return (\n            importlib.util.find_spec(\"azure.identity\") is not None\n            and importlib.util.find_spec(\"azure.keyvault.secrets\") is not None\n        )\n    except (ImportError, ModuleNotFoundError):\n        return False\n\n@pytest.fixture(autouse=True)\ndef _skip_azure_doctests(request: pytest.FixtureRequest) -&gt; None:\n    if not isinstance(request.node, pytest.DoctestItem):\n        return\n\n    if \"api.py\" in str(request.node.fspath):\n        azure_tests = [\"register_azure_kv_provider\", \"load_env\"]\n        is_azure = any(name in request.node.name for name in azure_tests)\n        if is_azure and not _azure_sdk_available():\n            pytest.skip(\"Azure SDK not available\")\n</code></pre> <p>Place in root <code>conftest.py</code> to apply to both <code>tests/</code> and <code>src/</code> (per <code>testpaths = [\"tests\", \"src\"]</code>).</p>"},{"location":"adr/0011-conditional-doctest-skip/#rationale","title":"Rationale","text":"<ul> <li>Environment-aware: Automatically detects Azure SDK availability</li> <li>Test coverage: Doctests run when dependencies are present</li> <li>No manual intervention: Users don't need to modify code based on their environment</li> <li>Pytest integration: Uses standard pytest skip mechanism</li> </ul> <p>Static <code># doctest: +SKIP</code> was rejected because it prevents testing when dependencies are available.</p>"},{"location":"adr/0011-conditional-doctest-skip/#implications","title":"Implications","text":""},{"location":"adr/0011-conditional-doctest-skip/#positive-implications","title":"Positive Implications","text":"<ul> <li>Doctests validate documentation accuracy when possible</li> <li>Graceful degradation without Azure SDK</li> <li>CI can test both scenarios (with/without optional deps)</li> <li>Consistent with <code>@pytest.mark.azure</code> strategy (ADR-0012)</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#concerns","title":"Concerns","text":"<ul> <li>Fixture complexity: More complex than simple <code>+SKIP</code></li> <li>Name coupling: Relies on doctest function names. Mitigation: Documented in fixture</li> <li>Maintenance: Future optional providers need fixture updates. Mitigation: Centralized in conftest.py</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#alternatives","title":"Alternatives","text":""},{"location":"adr/0011-conditional-doctest-skip/#1-unconditional-doctest-skip","title":"1. Unconditional <code># doctest: +SKIP</code>","text":"<ul> <li>Simpler</li> <li>Rejected: Never validates doctests, even when Azure SDK present</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#2-custom-doctest-directive-eg-skip_if_no_azure","title":"2. Custom doctest directive (e.g., <code>+SKIP_IF_NO_AZURE</code>)","text":"<ul> <li>More explicit in docstrings</li> <li>Rejected: Requires complex pytest doctest plugin customization</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#3-separate-doctest-files-for-optional-features","title":"3. Separate doctest files for optional features","text":"<ul> <li>Clear separation</li> <li>Rejected: Duplicates API documentation, harder to maintain</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#future-direction","title":"Future Direction","text":"<ul> <li>Extend pattern for other optional dependencies (AWS, GCP providers)</li> <li>Consider pytest plugin for cleaner syntax</li> <li>Add logging to show which doctests are skipped and why</li> </ul>"},{"location":"adr/0011-conditional-doctest-skip/#references","title":"References","text":"<ul> <li>Implementation: <code>conftest.py:17-46</code></li> <li>Related: ADR-0012 (pytest markers for test files)</li> <li>Pytest docs: https://docs.pytest.org/en/stable/how-to/skipping.html</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/","title":"ADR 0012: Use Pytest Marker to Isolate Azure-Dependent Tests","text":""},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#date","title":"Date","text":"<p>2025-10-13</p>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#context","title":"Context","text":"<p>Optional Azure integrations (<code>azure-identity</code>, <code>azure-keyvault-secrets</code>) are not installed in every development or CI environment. When those packages are missing, importing Azure-specific test modules or running doctests that touch <code>envresolve.providers.azure_kv</code> causes hard failures, even though the core library and the majority of tests do not require Azure.</p> <p>We need an approach that allows the core suite to run without the Azure SDK while retaining full coverage when the optional dependencies are present.</p>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#decision","title":"Decision","text":"<p>Introduce a dedicated pytest marker (<code>azure</code>) and a complementary Nox session that excludes Azure-only modules when that marker is filtered out.</p> <pre><code># In Azure-focused test modules\nimport pytest\n\npytestmark = pytest.mark.azure\n\n\n@pytest.mark.azure\ndef test_azure_feature() -&gt; None:\n    ...\n</code></pre> <pre><code># noxfile.py\n@nox.session(python=\"3.12\")\ndef tests_without_azure(session: nox.Session) -&gt; None:\n    session.install(\"-e\", \".\", \"--group=dev\")  # without extras\n    session.run(\n        \"pytest\",\n        \"-m\",\n        \"not azure\",\n        \"--ignore=tests/unit/test_azure_kv_provider.py\",\n        \"--ignore=tests/e2e/test_azure_kv_resolution.py\",\n        \"--ignore=src/envresolve/providers/azure_kv.py\",\n    )\n</code></pre> <p>The explicit <code>--ignore</code> directives avoid import-time failures for modules that unconditionally import the Azure SDK.</p>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#rationale","title":"Rationale","text":"<ul> <li>Fail fast with clear signal: Tests that require Azure are labelled explicitly; skipped when marker excluded, and failures clearly indicate missing registration.</li> <li>Minimal disruption: Core contributors can run <code>nox -s tests_without_azure</code> without installing Azure packages, while CI can still run the full suite via <code>nox -s tests</code>.</li> <li>Consistency with doctests: Aligns with ADR-0011, which conditionally skips Azure doctests; both mechanisms rely on the same marker vocabulary.</li> <li>Discoverability: The <code>azure</code> marker is declared in <code>pyproject.toml</code> under <code>pytest.ini_options.markers</code>, making usage visible to contributors.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#implications","title":"Implications","text":""},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#positive-implications","title":"Positive Implications","text":"<ul> <li>Core regression suite (65 tests) executes without optional dependencies.</li> <li>CI pipelines can stage jobs: lightweight core run vs. full Azure-enabled run.</li> <li>Contributors immediately see which tests rely on Azure-specific behavior via the marker.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#concerns","title":"Concerns","text":"<ul> <li>Command verbosity: The combination of <code>-m \"not azure\"</code> with multiple <code>--ignore</code> flags is easy to mistype. Mitigation: Provide the <code>tests_without_azure</code> Nox session and document it in the contributor guide.</li> <li>Synchronization: When new Azure modules or tests are added, the ignore list must be updated. Mitigation: Future: Add to code review checklist to mark Azure tests and update Nox session.</li> <li>Marker proliferation: Future cloud providers may introduce additional markers. Mitigation: Document marker naming conventions and reuse the same pattern for other optional stacks if/when they arrive.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#alternatives","title":"Alternatives","text":""},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#always-install-azure-extras-in-ci","title":"Always Install Azure Extras in CI","text":"<ul> <li>Pros: Simplifies test invocation; no markers or ignores necessary.</li> <li>Cons: Forces every developer/CI job to install heavy dependencies and Azure native libraries. Does not solve local setups without the SDK.</li> <li>Rejection reason: Conflicts with the goal of running quickly on minimal environments.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#skip-tests-via-importerror-guards-inside-modules","title":"Skip Tests via <code>ImportError</code> Guards inside Modules","text":"<ul> <li>Pros: Keeps pytest invocation simple.</li> <li>Cons: Module-level code still executes before the guard runs, leading to <code>ImportError</code>. Requires defensive code at the top of every module.</li> <li>Rejection reason: Duplicate boilerplate with fragile control flow; marker approach centralizes the policy.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#separate-test-suite-command-custom-script","title":"Separate Test Suite Command (Custom Script)","text":"<ul> <li>Pros: Hide complexity behind a bespoke runner.</li> <li>Cons: Adds tooling to maintain; contributors still need to learn marker semantics eventually.</li> <li>Rejection reason: Nox already provides a lightweight orchestration layer; no need for another script.</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#future-direction","title":"Future Direction","text":"<ul> <li>Consider refactoring Azure modules to import dependencies lazily (see ADR-0014). Once implemented, we can drop some <code>--ignore</code> flags and rely solely on markers.</li> <li>Add similar markers for other optional providers (AWS, GCP) if/when they are introduced.</li> <li>Automate marker enforcement (e.g., pytest plugin that fails if Azure SDK is missing while unmarked Azure tests are collected).</li> </ul>"},{"location":"adr/0012-pytest-markers-for-azure-dependencies/#references","title":"References","text":"<ul> <li>Implementation: <code>noxfile.py::tests_without_azure</code></li> <li>Marker declaration: <code>pyproject.toml [tool.pytest.ini_options].markers</code></li> <li>Related ADRs: 0011 (conditional doctest skip), 0014 (lazy imports for optional providers)</li> <li>Test modules: <code>tests/unit/test_azure_kv_provider.py</code>, <code>tests/e2e/test_azure_kv_resolution.py</code></li> </ul>"},{"location":"adr/0013-class-based-api-design/","title":"ADR 0013: Encapsulate Resolution State in <code>EnvResolver</code> Class with Module Facade","text":""},{"location":"adr/0013-class-based-api-design/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0013-class-based-api-design/#date","title":"Date","text":"<p>2025-10-14</p>"},{"location":"adr/0013-class-based-api-design/#context","title":"Context","text":"<p>Early iterations of the secret resolution API maintained provider registrations and resolver state in module-level globals (<code>_PROVIDERS</code>, <code>_RESOLVER</code>). Although simple, this approach leaked mutable global state, required <code>global</code> declarations when mutating, and made it difficult to instantiate isolated resolvers for tests or advanced scenarios.</p> <p>We needed a structure that:</p> <ul> <li>Removes direct <code>global</code> manipulation from public functions</li> <li>Keeps the existing top-level API (<code>envresolve.resolve_secret</code>, <code>load_env</code>) for backward compatibility</li> <li>Allows creation of multiple resolver instances for specialized use cases (e.g., custom registries in tests)</li> <li>Keeps the provider registration pattern defined in ADR-0009</li> </ul>"},{"location":"adr/0013-class-based-api-design/#decision","title":"Decision","text":"<p>Introduce an <code>EnvResolver</code> class that encapsulates provider registration and resolution logic, and expose a singleton instance through module-level facade functions.</p> <pre><code>class EnvResolver:\n    def __init__(self) -&gt; None:\n        self._providers: dict[str, SecretProvider] = {}\n        self._resolver: SecretResolver | None = None\n\n    def register_azure_kv_provider(self, **kwargs: Any) -&gt; None:\n        ...\n\n    def resolve_secret(self, uri: str) -&gt; str:\n        ...\n\n    def load_env(self, path: PathLike[str] | None = None) -&gt; dict[str, str]:\n        ...\n\n\n_DEFAULT_RESOLVER = EnvResolver()\n\n\ndef resolve_secret(uri: str) -&gt; str:\n    return _DEFAULT_RESOLVER.resolve_secret(uri)\n\n\ndef register_azure_kv_provider(**kwargs: Any) -&gt; None:\n    _DEFAULT_RESOLVER.register_azure_kv_provider(**kwargs)\n</code></pre>"},{"location":"adr/0013-class-based-api-design/#rationale","title":"Rationale","text":"<ul> <li>Encapsulation: All mutable state (providers, cached resolver) is confined to an instance, eliminating <code>global</code> mutation patterns.</li> <li>Testability: Tests can instantiate <code>EnvResolver()</code> directly, register mock providers, and assert behavior without touching the global singleton.</li> <li>Extensibility: Future features (per-resolver caches, alternative registries) can build on the class without breaking the public facade.</li> <li>Backward compatibility: Existing users continue to call module-level functions; no API breakage.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#implications","title":"Implications","text":""},{"location":"adr/0013-class-based-api-design/#positive-implications","title":"Positive Implications","text":"<ul> <li>Cleaner separation between public facade and implementation details.</li> <li>Multiple resolvers can coexist in the same process if needed (e.g., multi-tenant scenarios).</li> <li>Easier to reason about initialization order\u2014<code>EnvResolver</code> constructor localizes default setup.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#concerns","title":"Concerns","text":"<ul> <li>Slightly higher indirection: Developers must look inside the class to understand state transitions. Mitigation: Comprehensive docstrings and ADR references.</li> <li>Singleton management: The <code>_DEFAULT_RESOLVER</code> remains module-level global state. Mitigation: Singleton usage isolated to facade; alternative resolvers supported when required.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#alternatives","title":"Alternatives","text":""},{"location":"adr/0013-class-based-api-design/#keep-module-level-globals","title":"Keep Module-Level Globals","text":"<ul> <li>Pros: Minimal code; fewer indirections.</li> <li>Cons: <code>global</code> keyword required for updates; difficult to create isolated resolver instances; tightly couples API to implementation details.</li> <li>Rejection reason: Conflicts with encapsulation and testability goals.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#dependency-injection-via-function-parameters","title":"Dependency Injection via Function Parameters","text":"<ul> <li>Pros: Explicitly pass provider registry/resolver to every function.</li> <li>Cons: Verbose public API; callers must thread dependencies through each call; hurts ergonomics.</li> <li>Rejection reason: Overly burdensome for primary use cases; the facade pattern strikes a better balance.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#metaclass-based-singleton","title":"Metaclass-Based Singleton","text":"<ul> <li>Pros: Guarantees only one instance ever exists.</li> <li>Cons: Unnecessarily complex; prevents intentional multiple instances in tests.</li> <li>Rejection reason: Simpler explicit singleton (module-level instance) suffices.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#future-direction","title":"Future Direction","text":"<ul> <li>Provide factory helpers (e.g., <code>create_resolver()</code>) that pre-register common providers.</li> <li>Expose hooks for dependency injection (custom cache, custom secret resolver) during <code>EnvResolver</code> initialization.</li> <li>Evaluate whether the <code>_DEFAULT_RESOLVER</code> should be lazy-initialized to reduce import-time side effects once provider registrations grow.</li> </ul>"},{"location":"adr/0013-class-based-api-design/#references","title":"References","text":"<ul> <li>Implementation: <code>src/envresolve/api.py</code></li> <li>Tests: <code>tests/unit/test_resolver.py</code>, <code>tests/e2e/test_nested_resolution.py</code></li> <li>Related ADRs: 0009 (manual provider registration), 0010 (iterative URI resolution), 0014 (lazy imports for optional providers)</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/","title":"ADR 0014: Use <code>importlib</code> for Lazy Optional Dependency Loading with Rich Errors","text":""},{"location":"adr/0014-importlib-lazy-import/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0014-importlib-lazy-import/#date","title":"Date","text":"<p>2025-10-14</p>"},{"location":"adr/0014-importlib-lazy-import/#context","title":"Context","text":"<p>The Azure Key Vault provider depends on optional packages (<code>azure-identity</code>, <code>azure-keyvault-secrets</code>). Direct imports at module load time cause two problems:</p> <ol> <li>Importing <code>envresolve.providers.azure_kv</code> raises <code>ModuleNotFoundError</code> in environments without the Azure SDK, even if Azure functionality is never used.</li> <li>The resulting errors do not clearly instruct users which extras to install.</li> </ol> <p>We need a pattern that defers importing optional dependencies until the provider is actually requested and that explains how to resolve missing dependencies.</p>"},{"location":"adr/0014-importlib-lazy-import/#decision","title":"Decision","text":"<p>Use <code>importlib.import_module</code> inside <code>EnvResolver.register_azure_kv_provider</code> to load the provider lazily and produce a detailed error message when dependencies are missing.</p> <pre><code>import importlib\n\n\ndef register_azure_kv_provider(self, **kwargs: Any) -&gt; None:\n    try:\n        provider_module = importlib.import_module(\"envresolve.providers.azure_kv\")\n        provider_class = provider_module.AzureKVProvider\n    except ImportError as exc:  # Missing provider module or downstream deps\n        missing: list[str] = []\n        try:\n            importlib.util.find_spec(\"azure.identity\")\n        except (ImportError, ModuleNotFoundError):\n            missing.append(\"azure-identity\")\n\n        try:\n            importlib.util.find_spec(\"azure.keyvault.secrets\")\n        except (ImportError, ModuleNotFoundError):\n            missing.append(\"azure-keyvault-secrets\")\n\n        if missing:\n            hint = \", \".join(missing)\n            raise ProviderRegistrationError(\n                f\"Azure Key Vault provider requires {hint}. \"\n                \"Install with `pip install envresolve[azure]`.\",\n                original_error=exc\n            ) from exc\n\n        raise ProviderRegistrationError(\n            \"Failed to import Azure Key Vault provider; see chained exception for details.\",\n            original_error=exc\n        ) from exc\n\n    provider = provider_class(**kwargs)\n    self._providers[\"akv\"] = provider\n</code></pre>"},{"location":"adr/0014-importlib-lazy-import/#rationale","title":"Rationale","text":"<ul> <li>Lazy optional dependencies: Users without Azure extras can still import the package and use non-Azure features (aligns with ADR-0012).</li> <li>Actionable errors: When dependencies are missing, the raised message explicitly lists the missing packages and the extras command to install.</li> <li>Custom exception hierarchy: Uses <code>ProviderRegistrationError</code> instead of <code>ImportError</code> to align with ADR-0002 (custom exception hierarchy).</li> <li>Style compliance: Avoids Ruff's unused-import warnings and removes the need for <code>noqa</code> comments.</li> <li>Extensibility: Same pattern can be reused for future optional providers.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#implications","title":"Implications","text":""},{"location":"adr/0014-importlib-lazy-import/#positive-implications","title":"Positive Implications","text":"<ul> <li>Importing <code>envresolve</code> no longer requires the Azure SDK.</li> <li>Developers receive clear instructions on how to enable Azure functionality.</li> <li>Custom exception allows clients to handle provider registration errors separately from other errors (catch <code>ProviderRegistrationError</code> specifically or all envresolve errors via <code>EnvResolveError</code>).</li> <li>Unit tests can patch <code>importlib.import_module</code> to simulate missing dependencies.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#concerns","title":"Concerns","text":"<ul> <li>Slightly more boilerplate: Lazy import logic is longer than a simple <code>try/except ImportError</code>. Mitigation: Isolated inside a helper method and well-documented.</li> <li>Runtime detection cost: Uses <code>importlib.util.find_spec</code> to check dependencies. Mitigation: Called only when the provider is registered, not on every secret resolution.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#alternatives","title":"Alternatives","text":""},{"location":"adr/0014-importlib-lazy-import/#traditional-tryexcept-around-direct-import","title":"Traditional <code>try/except</code> around Direct Import","text":"<ul> <li>Pros: Very concise.</li> <li>Cons: Cannot distinguish which dependency is missing; forces import at module load time.</li> <li>Rejection reason: Fails the usability goal of actionable diagnostics and prevents import without Azure SDK.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#type_checking-guards","title":"<code>TYPE_CHECKING</code> Guards","text":"<ul> <li>Pros: Keeps type checkers aware of symbols while skipping runtime import.</li> <li>Cons: Does not help when the provider is actually used at runtime; still fails once the guarded code executes.</li> <li>Rejection reason: Insufficient for runtime optionality.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#entry-point-based-discovery","title":"Entry-Point Based Discovery","text":"<ul> <li>Pros: Can lazily load providers via plugin mechanism.</li> <li>Cons: Overkill for first-party providers and shifts complexity to packaging.</li> <li>Rejection reason: Simpler explicit import is adequate.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#future-direction","title":"Future Direction","text":"<ul> <li>Extract repeated dependency-check logic into a reusable helper once additional providers are added.</li> <li>Log missing-dependency diagnostics at DEBUG level when running in verbose mode to aid support investigations.</li> <li>Combine with ADR-0012 to remove explicit <code>--ignore</code> flags once all optional modules load lazily.</li> </ul>"},{"location":"adr/0014-importlib-lazy-import/#references","title":"References","text":"<ul> <li>Implementation: <code>src/envresolve/api.py::EnvResolver.register_azure_kv_provider</code></li> <li>Related ADRs: 0002 (custom exception hierarchy), 0009 (provider registry), 0012 (pytest markers for optional providers)</li> <li>Python docs: https://docs.python.org/3/library/importlib.html</li> <li>Issue #5: Changed from <code>ImportError</code> to <code>ProviderRegistrationError</code> to align with ADR-0002</li> </ul>"},{"location":"adr/0015-terraform-managed-live-tests/","title":"ADR 0015: Manage Azure Live Test Infrastructure with Terraform","text":""},{"location":"adr/0015-terraform-managed-live-tests/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0015-terraform-managed-live-tests/#date","title":"Date","text":"<p>2025-10-15</p>"},{"location":"adr/0015-terraform-managed-live-tests/#context","title":"Context","text":"<p>envresolve includes optional support for Azure Key Vault. Unit and end-to-end tests currently use mocks to avoid external dependencies, but they cannot guarantee the integration behaves correctly against real Azure services. We also want a reproducible way to provision the required Azure resources (resource group, Key Vault, sample secrets) for contributors and CI without manual setup.</p> <p>Key considerations:</p> <ul> <li>Ensure infra can be created and destroyed deterministically for on-demand live tests.</li> <li>Capture secrets and configuration outputs so the pytest suite can authenticate and assert on real data.</li> <li>Keep costs low (single Key Vault, sample secret) and enable quick cleanup.</li> <li>Avoid leaking credentials by relying on standard Azure service principal flows and environment variables.</li> </ul>"},{"location":"adr/0015-terraform-managed-live-tests/#decision","title":"Decision","text":"<p>Adopt Terraform to manage live-test infrastructure and introduce an <code>azure and live</code> pytest marker for the real Azure integration tests. Provisioning is documented under <code>infra/terraform</code>, including helper Nox sessions (<code>terraform_plan_live</code>, <code>terraform_apply_live</code>, <code>terraform_destroy_live</code>) that wrap common operations. Terraform outputs supply the values consumed by live tests via environment variables such as <code>ENVRESOLVE_LIVE_KEY_VAULT_NAME</code> and <code>ENVRESOLVE_LIVE_SECRET_VALUE</code>.</p> <p>Live tests are opt-in: they skip automatically when configuration variables or Azure credentials are absent. A dedicated CI workflow (manual/cron) can apply Terraform, run the live suite, and tear down the resources afterwards.</p>"},{"location":"adr/0015-terraform-managed-live-tests/#rationale","title":"Rationale","text":"<ul> <li>Repeatability: Terraform defines the full resource graph, removing ad-hoc setup steps.</li> <li>Safety: Helper sessions ensure <code>terraform destroy</code> is easy to run and can be wired into CI cleanup even on failures.</li> <li>Isolation: Live tests sit behind explicit pytest markers, so day-to-day development remains fast and free from cloud dependencies.</li> <li>Documentation: A focused user guide page explains the workflow for both local and CI executions, lowering the barrier for contributors.</li> </ul>"},{"location":"adr/0015-terraform-managed-live-tests/#consequences","title":"Consequences","text":""},{"location":"adr/0015-terraform-managed-live-tests/#positive","title":"Positive","text":"<ul> <li>Real Azure regressions are caught before release.</li> <li>All required secrets and outputs are version-controlled and discoverable.</li> <li>CI pipelines can gate live tests separately from the core suite.</li> </ul>"},{"location":"adr/0015-terraform-managed-live-tests/#negative","title":"Negative","text":"<ul> <li>Terraform and Azure CLI become prerequisites for running the live suite.</li> <li>Sensitive Terraform outputs must be handled carefully (e.g., stored in CI secrets rather than printed to logs).</li> <li>Additional maintenance is required to keep infrastructure definitions aligned with evolving test needs.</li> </ul>"},{"location":"adr/0015-terraform-managed-live-tests/#alternatives-considered","title":"Alternatives Considered","text":"<ol> <li>Manual Azure setup instructions only</li> <li> <p>Rejected: Too error-prone; contributors might misconfigure permissions or forget cleanup.</p> </li> <li> <p>Dynamic resource creation inside pytest fixtures</p> </li> <li> <p>Rejected: Implementing provisioning in Python would duplicate Terraform features, complicate teardown, and intertwine infrastructure logic with tests.</p> </li> <li> <p>Always rely on mocked tests</p> </li> <li>Rejected: Mocks cannot detect changes in Azure SDK behavior, identity requirements, or Key Vault service quirks.</li> </ol>"},{"location":"adr/0015-terraform-managed-live-tests/#follow-up-actions","title":"Follow-Up Actions","text":"<ul> <li>Wire the Terraform workflow into CI (manual dispatch or scheduled job).</li> <li>Consider adding Key Vault network ACL configuration once CI egress addresses are known.</li> <li>Expand live coverage as new Azure providers or features are added.</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/","title":"ADR 0016: Use TypeError-based Custom Exception for Mutually Exclusive Parameters","text":""},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#date","title":"Date","text":"<p>2025-10-18</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#context","title":"Context","text":"<p>The <code>resolve_os_environ()</code> API accepts two filtering parameters: <code>keys</code> (list of specific keys) and <code>prefix</code> (filter by prefix and strip). These parameters serve different use cases and are mutually exclusive by design\u2014specifying both creates ambiguous behavior.</p> <p>We need to decide:</p> <ol> <li>How to handle the case when both parameters are specified</li> <li>What exception type to use</li> <li>Whether to use built-in exceptions or custom domain exceptions</li> </ol> <p>The options are:</p> <ol> <li>Silent precedence: Let one parameter silently override the other</li> <li>Raise TypeError: Use Python's built-in TypeError</li> <li>Raise ValueError: Use Python's built-in ValueError</li> <li>Raise custom exception: Create a domain-specific exception that also inherits from TypeError</li> </ol>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#decision","title":"Decision","text":"<p>Create a custom exception <code>MutuallyExclusiveArgumentsError</code> that inherits from both <code>EnvResolveError</code> (domain base) and <code>TypeError</code> (standard library semantic), and raise it when both <code>keys</code> and <code>prefix</code> are specified.</p> <pre><code>class MutuallyExclusiveArgumentsError(EnvResolveError, TypeError):\n    \"\"\"Raised when mutually exclusive arguments are specified together.\"\"\"\n\n    def __init__(self, arg1: str, arg2: str) -&gt; None:\n        self.arg1 = arg1\n        self.arg2 = arg2\n        msg = (\n            f\"Arguments '{arg1}' and '{arg2}' are mutually exclusive. \"\n            f\"Specify either '{arg1}' or '{arg2}', but not both.\"\n        )\n        super().__init__(msg)\n</code></pre>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#rationale","title":"Rationale","text":""},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#following-industry-standards","title":"Following Industry Standards","text":"<p>Research into established Python libraries revealed that <code>TypeError</code> is the standard exception for mutually exclusive parameters:</p> <ul> <li>pandas: Uses <code>TypeError</code> with message \"Keyword arguments <code>items</code>, <code>like</code>, or <code>regex</code> are mutually exclusive\" in <code>DataFrame.filter()</code></li> <li>pandas Exception Guidelines: Explicitly states TypeError should be raised for \"wrong number of arguments, mutually exclusive arguments\"</li> <li>Python argparse: Provides <code>add_mutually_exclusive_group()</code> which raises TypeError on conflict</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#aligning-with-existing-adrs","title":"Aligning with Existing ADRs","text":"<ul> <li>ADR-0002 (Custom Exception Hierarchy): Requires all library errors to inherit from <code>EnvResolveError</code> for selective error handling</li> <li>ADR-0003 (Structured Exception Design): Requires exceptions to accept structured data (argument names) with internal message construction</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#benefits-of-multiple-inheritance","title":"Benefits of Multiple Inheritance","text":"<p>Using <code>class MutuallyExclusiveArgumentsError(EnvResolveError, TypeError)</code>:</p> <ol> <li>Standard semantics: <code>isinstance(e, TypeError)</code> returns True, aligning with Python conventions</li> <li>Domain isolation: <code>isinstance(e, EnvResolveError)</code> returns True, allowing catch-all error handling</li> <li>Programmatic access: <code>e.arg1</code> and <code>e.arg2</code> attributes enable structured error handling</li> <li>Clear user feedback: Explicit error message prevents debugging confusion</li> </ol>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#better-than-silent-precedence","title":"Better Than Silent Precedence","text":"<p>Rejecting silent precedence (keys takes priority over prefix):</p> <ul> <li>Users may not notice the bug until production</li> <li>Implicit priority rules must be documented and remembered</li> <li>No feedback when API is misused</li> <li>Harder to debug when unexpected behavior occurs</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#implications","title":"Implications","text":""},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#positive-implications","title":"Positive Implications","text":"<ul> <li>Fail-fast: Errors are caught at function call time, not through unexpected behavior</li> <li>Clear API contract: Users immediately understand the constraint</li> <li>Consistent with ecosystem: Follows patterns from pandas and argparse</li> <li>Type-safe error handling: Callers can catch either <code>TypeError</code>, <code>EnvResolveError</code>, or the specific exception</li> <li>Structured data: <code>arg1</code> and <code>arg2</code> attributes allow programmatic error handling</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#concerns","title":"Concerns","text":"<ul> <li>Slight verbosity: Requires 2-3 lines of validation code at function entry</li> <li>Breaking change: Existing code passing both parameters will now raise an exception</li> </ul> <p>Mitigation:</p> <ul> <li>The validation is minimal and centralized in one place</li> <li>No existing code should rely on this undefined behavior (it was just implemented)</li> <li>The error message clearly explains how to fix the issue</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#alternatives","title":"Alternatives","text":""},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#alternative-1-keys-takes-precedence-silent","title":"Alternative 1: Keys Takes Precedence (Silent)","text":"<pre><code>if keys is not None:\n    keys_to_process = keys  # prefix ignored\nelif prefix is not None:\n    keys_to_process = [k for k in os.environ if k.startswith(prefix)]\n</code></pre> <p>Pros: Simple implementation, no exception handling needed Cons:</p> <ul> <li>Implicit behavior must be documented</li> <li>Users may not notice their mistake</li> <li>Debugging confusion when prefix is silently ignored</li> <li>Not consistent with pandas patterns</li> </ul> <p>Rejection reason: Poor user experience and against industry best practices</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#alternative-2-built-in-typeerror-only","title":"Alternative 2: Built-in TypeError Only","text":"<pre><code>if keys is not None and prefix is not None:\n    raise TypeError(\"Arguments 'keys' and 'prefix' are mutually exclusive\")\n</code></pre> <p>Pros: Uses standard library exception Cons:</p> <ul> <li>Cannot catch all envresolve errors with <code>except EnvResolveError</code></li> <li>No structured access to which arguments conflicted</li> <li>Violates ADR-0002 (custom exception hierarchy)</li> </ul> <p>Rejection reason: Breaks the domain exception hierarchy requirement</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#alternative-3-built-in-valueerror","title":"Alternative 3: Built-in ValueError","text":"<pre><code>if keys is not None and prefix is not None:\n    raise ValueError(\"Cannot specify both 'keys' and 'prefix'\")\n</code></pre> <p>Pros: Also a built-in exception Cons:</p> <ul> <li><code>ValueError</code> semantics are for \"right type, wrong value\"</li> <li>This is a \"wrong combination of arguments\" case (TypeError semantics)</li> <li>pandas uses TypeError for this pattern, not ValueError</li> </ul> <p>Rejection reason: Wrong exception semantics for this error type</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#alternative-4-apply-both-parameters","title":"Alternative 4: Apply Both Parameters","text":"<pre><code>if keys is not None and prefix is not None:\n    # Apply both: filter keys by prefix and strip\n    keys_to_process = [k for k in keys if k.startswith(prefix)]\n    strip_prefix = True\n</code></pre> <p>Pros: Maximally flexible Cons:</p> <ul> <li>Overlapping concerns\u2014prefix filtering can be done by the caller</li> <li>Adds complexity to the API surface</li> <li>Unclear semantics (does stripping still happen?)</li> </ul> <p>Rejection reason: Unnecessary complexity; orthogonal concerns should be separated</p>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding similar validation for other potential parameter conflicts in future APIs</li> <li>If multiple functions need mutual exclusivity checks, extract a reusable validator helper</li> <li>Monitor user feedback to see if other parameter combinations need similar treatment</li> </ul>"},{"location":"adr/0016-mutually-exclusive-parameters-with-typeerror/#references","title":"References","text":"<ul> <li>pandas Exception Guidelines: https://github.com/pandas-dev/pandas/wiki/Choosing-Exceptions-to-Raise</li> <li>pandas DataFrame.filter() implementation pattern</li> <li>ADR-0002: Custom Exception Hierarchy</li> <li>ADR-0003: Structured Exception Design</li> <li>Issue #7: Add resolve_os_environ() API</li> <li>Implementation: <code>src/envresolve/exceptions.py</code>, <code>src/envresolve/api.py</code></li> </ul>"},{"location":"adr/0017-load-env-dotenv-path-parameter/","title":"ADR 0017: Align <code>load_env()</code> Parameter Signature with python-dotenv's <code>load_dotenv()</code>","text":""},{"location":"adr/0017-load-env-dotenv-path-parameter/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#date","title":"Date","text":"<p>2025-10-20</p>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#context","title":"Context","text":"<p>The original <code>load_env()</code> function signature used <code>path: str | Path = \".env\"</code> as its parameter:</p> <pre><code>def load_env(path: str | Path = \".env\", *, export: bool = True, override: bool = False):\n    ...\n</code></pre> <p>This created migration friction for users switching from python-dotenv's <code>load_dotenv()</code>, which uses <code>dotenv_path: str | Path | None = None</code>:</p> <pre><code>def load_dotenv(dotenv_path: str | Path | None = None, ...):\n    ...\n</code></pre> <p>The differences:</p> <ol> <li>Parameter name: <code>path</code> vs. <code>dotenv_path</code></li> <li>Default value: <code>.env</code> (explicit path) vs. <code>None</code> (search behavior)</li> <li>Search semantics: When <code>None</code>, python-dotenv searches for <code>.env</code> starting from the current working directory</li> </ol> <p>Users migrating from python-dotenv had to:</p> <ul> <li>Rename parameter: <code>load_dotenv()</code> \u2192 <code>load_env(path=...)</code></li> <li>Change default behavior: <code>load_dotenv()</code> \u2192 <code>load_env(path=\".env\")</code></li> </ul>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#decision","title":"Decision","text":"<p>Change <code>load_env()</code> signature to match python-dotenv's <code>load_dotenv()</code>:</p> <pre><code>def load_env(\n    dotenv_path: str | Path | None = None,\n    *,\n    export: bool = True,\n    override: bool = False,\n) -&gt; dict[str, str]:\n    \"\"\"Load environment variables from a .env file and resolve secret URIs.\n\n    Args:\n        dotenv_path: Path to .env file. If None, searches for .env in\n            current directory. Mimics python-dotenv's load_dotenv() behavior.\n            (default: None)\n    ...\n    \"\"\"\n    # When dotenv_path is None, use find_dotenv with usecwd=True\n    if dotenv_path is None:\n        dotenv_path = find_dotenv(usecwd=True)\n    env_dict = {k: v for k, v in dotenv_values(dotenv_path).items() if v is not None}\n    ...\n</code></pre>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#implementation-details","title":"Implementation Details","text":"<p>When <code>dotenv_path=None</code>, we explicitly call <code>find_dotenv(usecwd=True)</code> before passing to <code>dotenv_values()</code>. This is necessary because:</p> <ol> <li><code>dotenv_values(None)</code> internally calls <code>find_dotenv()</code> (without <code>usecwd=True</code>)</li> <li><code>find_dotenv()</code> defaults to <code>usecwd=False</code>, which searches from <code>__file__</code> location</li> <li>Since <code>api.py</code> is in <code>src/envresolve/</code>, the search would start there and walk up to project root</li> <li>This could find the wrong <code>.env</code> file (e.g., project's dev <code>.env</code> instead of application's <code>.env</code>)</li> </ol> <p>By using <code>find_dotenv(usecwd=True)</code>, we ensure the search starts from <code>os.getcwd()</code>, matching user expectations.</p>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#rationale","title":"Rationale","text":""},{"location":"adr/0017-load-env-dotenv-path-parameter/#for-users","title":"For Users","text":"<ul> <li>Zero-friction migration: Drop-in replacement for <code>load_dotenv()</code></li> <li>Intuitive behavior: <code>None</code> means \"search from current directory\" (matches shell behavior)</li> <li>Familiar API: Same parameter name as python-dotenv</li> </ul>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#for-maintainability","title":"For Maintainability","text":"<ul> <li>Explicit control: We control search behavior instead of relying on <code>dotenv_values()</code> internals</li> <li>Clear intent: <code>find_dotenv(usecwd=True)</code> explicitly documents search semantics</li> <li>Test reliability: Tests that <code>os.chdir()</code> work correctly because search happens from cwd</li> </ul>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#implications","title":"Implications","text":""},{"location":"adr/0017-load-env-dotenv-path-parameter/#positive-implications","title":"Positive Implications","text":"<ul> <li>Drop-in replacement for python-dotenv users</li> <li>More intuitive default behavior (search from cwd)</li> <li>Better aligned with shell conventions (<code>cd</code> changes where <code>.env</code> is found)</li> </ul>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#api-changes","title":"API Changes","text":"<p>The <code>load_env()</code> signature was updated for better python-dotenv compatibility:</p>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#parameter-name","title":"Parameter Name","text":"<pre><code># Before\nenvresolve.load_env(path=\".env\")\n\n# After\nenvresolve.load_env(dotenv_path=\".env\")\n</code></pre>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#default-value","title":"Default Value","text":"<pre><code># Before: Explicit path, always loads `.env` in cwd\nload_env()  # Loads ./.env\n\n# After: None triggers search, finds .env from cwd\nload_env()  # Searches for .env starting from cwd, walks up if not found\n</code></pre> <p>Most users have <code>.env</code> in the current directory, so behavior remains unchanged in practice.</p>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#search-behavior-differences-from-python-dotenv","title":"Search Behavior Differences from python-dotenv","text":"<p>Important limitation: <code>envresolve.load_env(None)</code> does not have identical search behavior to <code>python-dotenv</code>'s <code>load_dotenv(None)</code>:</p> <ul> <li>python-dotenv: <code>load_dotenv(None)</code> uses <code>find_dotenv(usecwd=False)</code>, which searches from the calling script's file location</li> <li>envresolve: <code>load_env(None)</code> uses <code>find_dotenv(usecwd=True)</code>, which searches from the current working directory</li> </ul> <p>Why the difference?</p> <p>When <code>usecwd=False</code>, <code>find_dotenv()</code> searches from the <code>__file__</code> location of the calling code. For python-dotenv (a library users import), this means the user's script location. For envresolve, it would mean the library's installed location (e.g., <code>site-packages/envresolve/api.py</code>), which is never the intended behavior.</p> <p>Using <code>usecwd=True</code> provides the most intuitive behavior: search from where the user is running their script.</p> <p>For complete python-dotenv compatibility, use this pattern:</p> <pre><code>from dotenv import load_dotenv\nimport envresolve\n\n# Use python-dotenv's search behavior\nload_dotenv()  # Searches from calling script location, loads to os.environ\n\n# Resolve secrets in os.environ\nenvresolve.register_azure_kv_provider()\nenvresolve.resolve_os_environ()  # Resolves akv:// URIs in os.environ\n</code></pre> <p>This approach:</p> <ul> <li>Preserves python-dotenv's exact search semantics</li> <li>Keeps envresolve focused on secret resolution</li> <li>Provides clear separation of concerns</li> </ul>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#alternatives","title":"Alternatives","text":""},{"location":"adr/0017-load-env-dotenv-path-parameter/#keep-path-parameter-only-change-default-to-none","title":"Keep <code>path</code> parameter, only change default to <code>None</code>","text":"<p>Pros: Smaller breaking change (only default value)</p> <p>Cons:</p> <ul> <li>Still migration friction (parameter name mismatch)</li> <li>Inconsistent with python-dotenv's established API</li> <li>Confusing documentation (\"path\" vs. \"dotenv_path\")</li> </ul> <p>Rejection reason: Partial migration creates long-term API inconsistency.</p>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#add-dotenv_path-as-alias-deprecate-path","title":"Add <code>dotenv_path</code> as alias, deprecate <code>path</code>","text":"<p>Pros: Gradual migration path</p> <p>Cons:</p> <ul> <li>Increased complexity (two parameters doing the same thing)</li> <li>Deprecation warnings add friction</li> <li>Eventually needs breaking change anyway</li> <li>envresolve is v0.x, users expect breakage</li> </ul> <p>Rejection reason: For v0.x libraries, clean break is better than deprecation cycle.</p>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#keep-original-signature-add-searchfalse-flag","title":"Keep original signature, add <code>search=False</code> flag","text":"<p>Pros: No breaking change</p> <p>Cons:</p> <ul> <li>Doesn't solve migration friction (parameter name still wrong)</li> <li>More complex API (two parameters to control one behavior)</li> <li><code>path=\".env\", search=True</code> is confusing</li> </ul> <p>Rejection reason: Adds complexity without solving the root problem.</p>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#future-direction","title":"Future Direction","text":"<ul> <li>Consider adding <code>load_env_strict(dotenv_path: str | Path)</code> that requires explicit path and never searches</li> <li>If users request it, add <code>usecwd</code> parameter to expose python-dotenv's search control: <code>load_env(dotenv_path=None, usecwd=True)</code></li> </ul>"},{"location":"adr/0017-load-env-dotenv-path-parameter/#references","title":"References","text":"<ul> <li>Issue: #13 \"Align load_env signature with load_dotenv\"</li> <li>Implementation: <code>src/envresolve/api.py:129-183</code></li> <li>Tests: <code>tests/e2e/test_load_env.py</code></li> <li>python-dotenv docs: https://saurabh-kumar.com/python-dotenv/</li> <li>Related ADRs: 0013 (class-based API design)</li> </ul>"},{"location":"adr/0018-granular-error-handling/","title":"ADR 0018: Granular Error Handling for Variable Expansion and Secret Resolution","text":""},{"location":"adr/0018-granular-error-handling/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0018-granular-error-handling/#date","title":"Date","text":"<p>2025-10-21</p>"},{"location":"adr/0018-granular-error-handling/#context","title":"Context","text":"<p>When loading environment variables from <code>.env</code> files or <code>os.environ</code>, two distinct types of errors can occur:</p> <ol> <li>Variable expansion errors: Variables referenced with <code>${VAR}</code> syntax cannot be resolved</li> <li>Secret resolution errors: Secret URIs like <code>akv://vault/secret</code> fail to fetch from providers</li> </ol> <p>The original implementation had a single <code>stop_on_error</code> flag that controlled both types of errors uniformly. However, real-world usage revealed different requirements for handling these error types.</p>"},{"location":"adr/0018-granular-error-handling/#key-insight-different-error-types-need-different-handling","title":"Key Insight: Different Error Types Need Different Handling","text":"<p>The original implementation had a single <code>stop_on_error</code> flag that controlled both types of errors uniformly. However, real-world usage revealed different requirements for handling these error types:</p> <p>Variable expansion errors can have different severities:</p> <ul> <li>Typos in <code>.env</code> files: <code>DB_URL=${DATABSE_HOST}</code> (should be <code>DATABASE_HOST</code>) - should raise error</li> <li>Optional variables: <code>LOG_LEVEL=${LOG_LEVEL:-info}</code> where <code>LOG_LEVEL</code> might not exist - could be tolerable</li> <li>System variables: <code>$PS1</code> (bash/zsh) or <code>%PROMPT%</code> (Windows) contain literal <code>$</code> characters (e.g., <code>PS1=\"\\u@\\h:\\w\\$ \"</code>) that trigger unintended expansion - could be tolerable</li> </ul> <p>Secret resolution errors are consistently critical:</p> <ul> <li>If a secret URI (<code>akv://vault/secret</code>) fails to resolve, it indicates a real problem (network, permissions, missing secret)</li> <li>Silently ignoring resolution failures would leave <code>akv://vault/secret</code> as a literal string in <code>os.environ</code></li> <li>This could cause hard-to-debug issues in application code</li> </ul>"},{"location":"adr/0018-granular-error-handling/#need-for-granular-control","title":"Need for Granular Control","text":"<p>Users need different error handling strategies:</p> <ul> <li>Default behavior (both <code>True</code>): Fail-fast for strict error detection</li> <li>Selective suppression: Users can set <code>stop_on_expansion_error=False</code> when they know certain variables might be missing (e.g., when processing <code>os.environ</code> that includes system variables)</li> <li>Always report secret failures: <code>stop_on_resolution_error=True</code> ensures intentional secret URIs are validated</li> </ul> <p>A single <code>stop_on_error</code> flag cannot serve both needs. Future enhancements (ignore patterns) will provide more granular control for the expansion error case.</p>"},{"location":"adr/0018-granular-error-handling/#decision","title":"Decision","text":"<p>Replace single <code>stop_on_error</code> parameter with two granular parameters in both <code>load_env()</code> and <code>resolve_os_environ()</code>:</p> <pre><code>def load_env(\n    dotenv_path: str | Path | None = None,\n    *,\n    export: bool = True,\n    override: bool = False,\n    stop_on_expansion_error: bool = True,\n    stop_on_resolution_error: bool = True,\n) -&gt; dict[str, str]:\n    ...\n\ndef resolve_os_environ(\n    keys: list[str] | None = None,\n    prefix: str | None = None,\n    *,\n    overwrite: bool = True,\n    stop_on_expansion_error: bool = True,\n    stop_on_resolution_error: bool = True,\n) -&gt; dict[str, str]:\n    ...\n</code></pre> <p>Error categorization:</p> <ul> <li><code>stop_on_expansion_error</code> controls: <code>VariableNotFoundError</code> only</li> <li><code>stop_on_resolution_error</code> controls: <code>SecretResolutionError</code></li> <li><code>CircularReferenceError</code> is always raised (configuration error, cannot be suppressed)</li> </ul>"},{"location":"adr/0018-granular-error-handling/#rationale","title":"Rationale","text":""},{"location":"adr/0018-granular-error-handling/#why-two-categories-instead-of-per-error-type-flags","title":"Why Two Categories Instead of Per-Error-Type Flags","text":"<p>We could have provided individual flags for each exception type (<code>stop_on_variable_not_found</code>, <code>stop_on_secret_resolution</code>, etc.), but this would:</p> <ul> <li>Complicate the API as new error types are added</li> <li>Make the mental model more complex for users</li> <li>Not align with how users think about the problem</li> </ul> <p>Instead, grouping by operation (expansion vs resolution) provides:</p> <ul> <li>Clear mental model: Users understand \"variable expansion\" vs \"secret fetching\"</li> <li>Stable API: New error types fit into existing categories</li> <li>User-centric: Matches how users describe their needs (\"I want to skip missing variables but not secret failures\")</li> </ul>"},{"location":"adr/0018-granular-error-handling/#why-circularreferenceerror-is-always-raised","title":"Why CircularReferenceError is Always Raised","text":"<p>Unlike <code>VariableNotFoundError</code>, <code>CircularReferenceError</code> represents:</p> <ul> <li>Infinite loop: <code>A=${B}, B=${A}</code> can never resolve</li> <li>Configuration mistake: Never intentional</li> <li>Safety issue: Suppressing would hide a critical problem</li> </ul> <p>Therefore, <code>CircularReferenceError</code> is excluded from <code>stop_on_expansion_error</code> control.</p>"},{"location":"adr/0018-granular-error-handling/#default-behavior","title":"Default Behavior","text":"<p>Both flags default to <code>True</code>, preserving fail-fast behavior for strict error detection. Users can selectively disable error handling by setting either flag to <code>False</code> when needed (e.g., <code>stop_on_expansion_error=False</code> to tolerate missing optional variables).</p>"},{"location":"adr/0018-granular-error-handling/#implications","title":"Implications","text":""},{"location":"adr/0018-granular-error-handling/#positive-implications","title":"Positive Implications","text":"<ol> <li>Strict by default: Both flags default to <code>True</code>, providing fail-fast behavior that catches typos and configuration errors early</li> <li>Selective tolerance: Users can set <code>stop_on_expansion_error=False</code> when processing <code>os.environ</code> with system variables like <code>$PS1</code> or <code>%PROMPT%</code> that contain <code>$</code> characters</li> <li>Flexible resilience: Applications can choose to tolerate missing optional variables while still catching secret resolution failures</li> <li>Clear error reporting: Immediate feedback on both configuration errors (by default) and secret provider issues</li> <li>Future-proof: API won't need changes if new error types are added (they'll fit into expansion or resolution categories)</li> <li>Complements ignore patterns: The default strict behavior works well with planned ignore pattern features (roadmap v0.1.x), where users can explicitly list variables to skip rather than silently ignoring all errors</li> </ol>"},{"location":"adr/0018-granular-error-handling/#concerns","title":"Concerns","text":"<ol> <li>API surface increase: Two new parameters per function</li> <li>Mitigation: Parameters are optional with sensible defaults</li> <li>Potential confusion: Users might not understand which errors belong to which category</li> <li>Mitigation: Clear documentation with examples, explicit mention in docstrings</li> <li>Asymmetry: CircularReferenceError is an expansion error but not controlled by the flag</li> <li>Mitigation: Documented explicitly; safety justifies the exception</li> </ol>"},{"location":"adr/0018-granular-error-handling/#alternatives","title":"Alternatives","text":""},{"location":"adr/0018-granular-error-handling/#alternative-1-keep-single-stop_on_error-flag","title":"Alternative 1: Keep Single <code>stop_on_error</code> Flag","text":"<p>Characteristics: Original design with uniform error handling</p> <p>Pros:</p> <ul> <li>Simpler API</li> <li>No decision needed about error categorization</li> </ul> <p>Cons:</p> <ul> <li>Cannot handle shell prompt variables (must stop on all errors or none)</li> <li>All-or-nothing approach doesn't match user needs</li> </ul> <p>Rejected because: Real-world usage (e.g., <code>$PS1</code> variables) requires different handling for expansion vs resolution errors.</p>"},{"location":"adr/0018-granular-error-handling/#alternative-2-per-exception-type-flags","title":"Alternative 2: Per-Exception-Type Flags","text":"<p>Characteristics: Individual flags like <code>stop_on_variable_not_found</code>, <code>stop_on_circular_reference</code>, <code>stop_on_secret_resolution</code></p> <p>Pros:</p> <ul> <li>Maximum flexibility</li> <li>Explicit control over each error type</li> </ul> <p>Cons:</p> <ul> <li>API grows with each new error type</li> <li>Too granular for typical use cases</li> <li>Cognitive overhead: users must understand internal exception hierarchy</li> </ul> <p>Rejected because: Over-engineered for current needs; expansion/resolution categorization is more intuitive.</p>"},{"location":"adr/0018-granular-error-handling/#alternative-3-error-callback","title":"Alternative 3: Error Callback","text":"<p>Characteristics: Allow users to provide a callback function to decide whether to suppress each error</p> <pre><code>def load_env(error_handler: Callable[[Exception, str], bool] = None):\n    ...\n</code></pre> <p>Pros:</p> <ul> <li>Maximum flexibility</li> <li>Can implement complex error handling logic</li> </ul> <p>Cons:</p> <ul> <li>Much more complex API</li> <li>Harder to use for simple cases</li> <li>Requires users to understand exception types</li> </ul> <p>Rejected because: Too complex for the common use cases; boolean flags are more Pythonic.</p>"},{"location":"adr/0018-granular-error-handling/#alternative-4-separate-functions","title":"Alternative 4: Separate Functions","text":"<p>Characteristics: Provide separate <code>load_env_strict()</code> / <code>load_env_lenient()</code> variants</p> <p>Pros:</p> <ul> <li>Clear intent from function name</li> <li>No parameter complexity</li> </ul> <p>Cons:</p> <ul> <li>Doesn't solve granular control problem (still need to specify which errors to tolerate)</li> <li>API proliferation (need variants for each function)</li> </ul> <p>Rejected because: Doesn't address the core need for separate expansion/resolution control.</p>"},{"location":"adr/0018-granular-error-handling/#future-direction","title":"Future Direction","text":""},{"location":"adr/0018-granular-error-handling/#potential-future-enhancements","title":"Potential Future Enhancements","text":"<ol> <li>Additional error categories: If new operation types are added (e.g., validation, transformation), they would get their own <code>stop_on_*</code> parameters</li> <li>Error callbacks: If users need more complex error handling logic, we could add optional callbacks while keeping the simple boolean flags for common cases</li> <li>Logging integration: Consider adding optional logging of suppressed errors for debugging</li> </ol>"},{"location":"adr/0018-granular-error-handling/#triggers-for-revisiting","title":"Triggers for Revisiting","text":"<ul> <li>User feedback indicating the two-category model is insufficient</li> <li>New error types that don't fit cleanly into expansion or resolution categories</li> <li>Performance concerns with try/except overhead (unlikely but possible)</li> </ul>"},{"location":"adr/0018-granular-error-handling/#references","title":"References","text":"<ul> <li>Issue #17: Granular Error Handling</li> <li>ADR-0002: Custom Exception Hierarchy</li> <li>Shell prompt variables (<code>$PS1</code>, <code>%PROMPT%</code>): Real-world use case that motivated this design</li> </ul>"},{"location":"adr/0019-do-not-implement-validation-helpers/","title":"ADR 0019: Do Not Implement Validation Helper Functions and Metadata Query Helpers","text":""},{"location":"adr/0019-do-not-implement-validation-helpers/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0019-do-not-implement-validation-helpers/#date","title":"Date","text":"<p>2025-11-12</p>"},{"location":"adr/0019-do-not-implement-validation-helpers/#context","title":"Context","text":"<p>The v0.1.x roadmap included two features:</p> <ul> <li>Validation helpers for string-based API (<code>is_resolved</code>, <code>needs_expansion</code>, <code>is_secret_uri</code>)</li> <li>Optional metadata/query helpers for resolved values</li> </ul> <p>These were proposed as convenience utilities to help users validate strings and query resolution metadata.</p>"},{"location":"adr/0019-do-not-implement-validation-helpers/#decision","title":"Decision","text":"<p>Do not implement these features.</p>"},{"location":"adr/0019-do-not-implement-validation-helpers/#rationale","title":"Rationale","text":""},{"location":"adr/0019-do-not-implement-validation-helpers/#validation-helpers","title":"Validation Helpers","text":"<ol> <li>Trivial pattern matching: Functions like <code>is_resolved()</code> reduce to simple checks (<code>'$' in string</code>) that users can write in one line.</li> <li>Unclear use cases: No concrete scenarios identified where pre-validation provides value over direct resolution with error handling.</li> <li>API bloat: Adding public functions increases maintenance burden, documentation overhead, and testing requirements without clear benefit.</li> <li>Premature abstraction: Exposes internal parsing logic as public API, constraining future implementation changes.</li> </ol>"},{"location":"adr/0019-do-not-implement-validation-helpers/#metadata-query-helpers","title":"Metadata Query Helpers","text":"<ol> <li>Undefined requirements: The roadmap item lacks concrete specification of what metadata would be tracked or how it would be queried.</li> <li>No identified use cases: Without specific user needs, this is speculative feature development (YAGNI principle).</li> </ol>"},{"location":"adr/0019-do-not-implement-validation-helpers/#implications","title":"Implications","text":""},{"location":"adr/0019-do-not-implement-validation-helpers/#positive-implications","title":"Positive Implications","text":"<ul> <li>Maintains focused, minimal API surface</li> <li>Reduces maintenance overhead</li> <li>Preserves implementation flexibility</li> </ul>"},{"location":"adr/0019-do-not-implement-validation-helpers/#concerns","title":"Concerns","text":"<ul> <li>If users request these features, they will need custom implementations</li> <li>Mitigation: Revisit this decision if concrete use cases emerge from user feedback</li> </ul>"},{"location":"adr/0019-do-not-implement-validation-helpers/#alternatives","title":"Alternatives","text":"<p>Provide utility functions anyway: Would offer convenience but at the cost of API complexity and maintenance burden without proven demand.</p>"},{"location":"adr/0019-do-not-implement-validation-helpers/#future-direction","title":"Future Direction","text":"<p>Reopen this decision if:</p> <ul> <li>Multiple users independently request similar validation functionality</li> <li>Specific use cases emerge that cannot be solved with existing APIs</li> <li>Internal parser complexity makes user-side validation significantly error-prone</li> </ul>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/","title":"ADR 0020: Add ignore_keys Parameter for Selective Variable Exclusion","text":""},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#date","title":"Date","text":"<p>2025-11-13</p>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#context","title":"Context","text":"<p>System environment variables (<code>$PS1</code>, <code>$PS2</code>, <code>%PROMPT%</code>) contain literal <code>$</code> characters (e.g., <code>PS1=\"${USER}@${HOST}$ \"</code>). When processing these with <code>resolve_os_environ()</code>, the <code>$</code> triggers unintended variable expansion, causing <code>VariableNotFoundError</code>.</p> <p>The existing <code>stop_on_expansion_error=False</code> suppresses all expansion errors, preventing detection of legitimate typos in configuration.</p>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#decision","title":"Decision","text":"<p>Add <code>ignore_keys</code> parameter to <code>load_env()</code> and <code>resolve_os_environ()</code>:</p> <pre><code>def load_env(..., ignore_keys: list[str] | None = None) -&gt; dict[str, str]: ...\ndef resolve_os_environ(..., ignore_keys: list[str] | None = None) -&gt; dict[str, str]: ...\n</code></pre> <p>Variables in <code>ignore_keys</code> skip expansion/resolution and are included as-is. Phase 1 uses exact string matching only.</p>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#rationale","title":"Rationale","text":""},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#phase-1-list-based-exact-matching","title":"Phase 1: List-based exact matching","text":"<ul> <li>Solves the immediate problem (system variables)</li> <li>Simple mental model</li> <li>Foundation for future pattern matching</li> </ul>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#why-not-patterns-from-the-start","title":"Why not patterns from the start","text":"<ul> <li>Increases scope and complexity</li> <li>List-based approach provides immediate value</li> <li>Patterns can be added incrementally without breaking changes</li> </ul>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#implications","title":"Implications","text":""},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#positive-implications","title":"Positive Implications","text":"<ul> <li>Selective exclusion with strict error checking for other variables</li> <li>Complements granular error handling (ADR-0018)</li> <li>Non-breaking addition (optional parameter)</li> </ul>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#concerns","title":"Concerns","text":"<ul> <li>Manual specification required for each key<ul> <li>Mitigation: Phase 2 will add glob patterns</li> </ul> </li> </ul>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#alternatives","title":"Alternatives","text":""},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#glob-patterns-immediately","title":"Glob Patterns Immediately","text":"<p>Pros: More flexible, fewer manual specifications</p> <p>Cons: More complex, increases initial scope</p> <p>Rejected: Incremental approach provides faster value</p>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#callback-function","title":"Callback Function","text":"<p>Pros: Maximum flexibility</p> <p>Cons: Overkill for typical use cases, harder to configure</p> <p>Rejected: List-based approach covers 90% of use cases</p>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#automatic-detection","title":"Automatic Detection","text":"<p>Pros: Zero configuration</p> <p>Cons: Magic behavior, platform-specific, users lose control</p> <p>Rejected: Explicit configuration is more predictable</p>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#future-direction","title":"Future Direction","text":"<ul> <li>Phase 2: <code>ignore_patterns</code> with glob matching (<code>PS*</code>, <code>PROMPT*</code>)</li> <li>Phase 3: <code>ENVRESOLVE_IGNORE</code> environment variable</li> <li>Potential: Case-insensitive matching, regex patterns, invert logic</li> </ul>"},{"location":"adr/0020-ignore-keys-for-selective-exclusion/#references","title":"References","text":"<ul> <li>Issue #20: Add ignore_keys parameter</li> <li>ADR-0018: Granular Error Handling</li> </ul>"},{"location":"adr/0021-exception-wrapping-for-context/","title":"ADR 0021: Exception Wrapping for Variable Resolution Context","text":""},{"location":"adr/0021-exception-wrapping-for-context/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0021-exception-wrapping-for-context/#date","title":"Date","text":"<p>2025-11-14</p>"},{"location":"adr/0021-exception-wrapping-for-context/#context","title":"Context","text":"<p>When <code>load_env()</code> or <code>resolve_os_environ()</code> fails to resolve a variable, the error message doesn't indicate which environment variable was being processed. For example, with <code>VAR2=${UNDEFINED}</code>, the error says \"Variable not found: UNDEFINED\" but not that the problem occurred in <code>VAR2</code>.</p> <p>This makes debugging difficult when <code>.env</code> files have many variables or multiple variables reference the same underlying variable.</p>"},{"location":"adr/0021-exception-wrapping-for-context/#decision","title":"Decision","text":"<p>Wrap <code>VariableNotFoundError</code> and <code>SecretResolutionError</code> with <code>EnvironmentVariableResolutionError</code> that includes:</p> <ul> <li><code>context_key</code>: The environment variable name being processed</li> <li><code>original_error</code>: The underlying exception</li> <li>Error message combining both pieces of information</li> </ul> <pre><code>except (VariableNotFoundError, SecretResolutionError) as e:\n    msg = f\"Failed to resolve environment variable '{key}': {e}\"\n    raise EnvironmentVariableResolutionError(msg, context_key=key, original_error=e) from e\n</code></pre> <p>Wrapping occurs in <code>load_env()</code> and <code>resolve_os_environ()</code> at the application layer. <code>CircularReferenceError</code> is NOT wrapped as it already indicates the problematic variable chain.</p>"},{"location":"adr/0021-exception-wrapping-for-context/#rationale","title":"Rationale","text":""},{"location":"adr/0021-exception-wrapping-for-context/#application-layer-wrapping","title":"Application Layer Wrapping","text":"<ul> <li>Only <code>api.py</code> has the context (<code>key</code>); service layer doesn't know which variable it's processing</li> <li>Keeps service layer generic and reusable (ADR-0007)</li> <li>Exception chain (<code>from e</code>) preserves original error location</li> </ul>"},{"location":"adr/0021-exception-wrapping-for-context/#new-exception-type","title":"New Exception Type","text":"<ul> <li>Preserves existing exception contracts (service layer doesn't need application context)</li> <li>Provides both programmatic access (<code>context_key</code>, <code>original_error</code>) and human-readable messages</li> <li>Allows catching either the wrapper or original exception types</li> </ul>"},{"location":"adr/0021-exception-wrapping-for-context/#implications","title":"Implications","text":""},{"location":"adr/0021-exception-wrapping-for-context/#positive-implications","title":"Positive Implications","text":"<ul> <li>Error messages clearly indicate which variable failed</li> <li>Programmatic error handling via attributes</li> <li>Works seamlessly with <code>stop_on_expansion_error</code> and <code>stop_on_resolution_error</code> (ADR-0018)</li> <li>Clean layer separation</li> </ul>"},{"location":"adr/0021-exception-wrapping-for-context/#concerns","title":"Concerns","text":"<ul> <li>Breaking change for exception catching<ul> <li>Mitigation: Most users don't catch these; can access <code>original_error</code> if needed</li> </ul> </li> <li>Wrapping logic duplicated in two methods<ul> <li>Mitigation: Simple pattern; extraction would add complexity</li> </ul> </li> </ul>"},{"location":"adr/0021-exception-wrapping-for-context/#alternatives","title":"Alternatives","text":""},{"location":"adr/0021-exception-wrapping-for-context/#modify-existing-exceptions","title":"Modify Existing Exceptions","text":"<p>Pros: No new exception type</p> <p>Cons: Violates layer separation, makes service layer less reusable</p> <p>Rejected: Service layer shouldn't depend on application context</p>"},{"location":"adr/0021-exception-wrapping-for-context/#add-context-to-message-only","title":"Add Context to Message Only","text":"<p>Pros: Simpler implementation</p> <p>Cons: No programmatic access, still violates layer separation</p> <p>Rejected: Doesn't enable programmatic error handling</p>"},{"location":"adr/0021-exception-wrapping-for-context/#future-direction","title":"Future Direction","text":"<ul> <li>Structured error reporting for all failed variables</li> <li>Batch error collection option</li> <li>Custom error formatters</li> </ul>"},{"location":"adr/0021-exception-wrapping-for-context/#references","title":"References","text":"<ul> <li>Issue #22: Add context to resolution errors</li> <li>ADR-0007: Layer Separation</li> <li>ADR-0018: Granular Error Handling</li> </ul>"},{"location":"adr/0022-ignore-patterns-parameter/","title":"ADR 0022: Add ignore_patterns Parameter for Pattern-Based Variable Exclusion","text":""},{"location":"adr/0022-ignore-patterns-parameter/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0022-ignore-patterns-parameter/#date","title":"Date","text":"<p>2025-11-15</p>"},{"location":"adr/0022-ignore-patterns-parameter/#context","title":"Context","text":"<p>ADR-0020 introduced <code>ignore_keys</code> parameter for exact string matching to exclude specific environment variables from expansion. However, users must list each variable individually:</p> <pre><code>load_env(ignore_keys=[\"PS1\", \"PS2\", \"PS3\", \"PS4\"])  # Verbose for related vars\n</code></pre> <p>For excluding multiple related variables (e.g., all shell prompt variables <code>PS*</code>, all Windows prompt variables <code>PROMPT*</code>), exact matching becomes verbose and error-prone. Users need pattern-based exclusion.</p> <p>This is Phase 2 of the ignore functionality roadmap outlined in ADR-0020.</p>"},{"location":"adr/0022-ignore-patterns-parameter/#decision","title":"Decision","text":"<p>Add <code>ignore_patterns</code> parameter to <code>load_env()</code> and <code>resolve_os_environ()</code> for pattern-based variable exclusion:</p> <pre><code>def load_env(..., ignore_patterns: list[str] | None = None) -&gt; dict[str, str]: ...\ndef resolve_os_environ(..., ignore_patterns: list[str] | None = None) -&gt; dict[str, str]: ...\n</code></pre> <p>Pattern format is defined in ADR-0023 (implementation choice).</p> <p>Execution order:</p> <ol> <li>Check <code>ignore_keys</code> (exact match)</li> <li>If not matched, check <code>ignore_patterns</code> (pattern match)</li> <li>If neither matched, perform resolution</li> </ol>"},{"location":"adr/0022-ignore-patterns-parameter/#rationale","title":"Rationale","text":"<p>Why separate parameter from <code>ignore_keys</code>:</p> <ul> <li>Clear intent: exact match vs. pattern match</li> <li>Avoids ambiguity (a literal key name vs. a pattern)</li> <li>Both can be used together for flexibility</li> </ul> <p>Why pattern-based approach:</p> <ul> <li>Concise for excluding related variables</li> <li>Reduces manual listing and error-proneness</li> <li>Covers real-world use cases (system variables, temporary variables, debug flags)</li> </ul>"},{"location":"adr/0022-ignore-patterns-parameter/#implications","title":"Implications","text":""},{"location":"adr/0022-ignore-patterns-parameter/#positive-implications","title":"Positive Implications","text":"<ul> <li>Concise exclusion of related variables instead of listing each one</li> <li>Flexibility: combine exact and pattern matching</li> <li>Non-breaking: optional parameter, backward compatible</li> <li>Covers real-world use cases: <code>TEMP_*</code>, <code>DEBUG_*</code>, <code>PROMPT*</code></li> </ul>"},{"location":"adr/0022-ignore-patterns-parameter/#concerns","title":"Concerns","text":"<ul> <li>Pattern complexity: Users might write overly broad patterns<ul> <li>Mitigation: Documentation with best practices and examples</li> </ul> </li> <li>Pattern format choice: Need to decide on pattern syntax<ul> <li>Addressed in ADR-0023 (implementation decision)</li> </ul> </li> </ul>"},{"location":"adr/0022-ignore-patterns-parameter/#alternatives","title":"Alternatives","text":""},{"location":"adr/0022-ignore-patterns-parameter/#callback-function","title":"Callback Function","text":"<p>Allow custom filter function:</p> <pre><code>def should_ignore(key: str) -&gt; bool:\n    return key.startswith(\"PS\") or key.startswith(\"PROMPT\")\n\nload_env(ignore_filter=should_ignore)\n</code></pre> <p>Pros: Maximum flexibility</p> <p>Cons:</p> <ul> <li>Complex for simple cases</li> <li>Cannot be serialized to config files</li> <li>Overhead for typical scenarios</li> </ul> <p>Rejected: Pattern-based approach is simpler and covers most needs. Callback can be Phase 4 if needed.</p>"},{"location":"adr/0022-ignore-patterns-parameter/#extend-ignore_keys-to-accept-patterns","title":"Extend ignore_keys to Accept Patterns","text":"<p>Modify <code>ignore_keys</code> to auto-detect and handle patterns:</p> <pre><code>load_env(ignore_keys=[\"EXACT_VAR\", \"PS*\"])  # Mixed\n</code></pre> <p>Pros: Single parameter</p> <p>Cons:</p> <ul> <li>Ambiguous: Is <code>PS*</code> literal or pattern?</li> <li>Cannot exclude a variable literally named <code>PS*</code></li> <li>Less explicit</li> </ul> <p>Rejected: Separate parameters provide clearer intent.</p>"},{"location":"adr/0022-ignore-patterns-parameter/#future-direction","title":"Future Direction","text":"<ul> <li>Phase 3: <code>ENVRESOLVE_IGNORE</code> environment variable for global configuration</li> <li>Pattern format evolution: If users need more complex matching, consider additional pattern types (see ADR-0023)</li> </ul>"},{"location":"adr/0022-ignore-patterns-parameter/#references","title":"References","text":"<ul> <li>ADR-0020: Add ignore_keys Parameter for Selective Variable Exclusion (Phase 1)</li> <li>ADR-0023: Use fnmatch (Glob Patterns) for Pattern Matching Implementation</li> <li>Issue #25: Add ignore_patterns parameter with glob matching support</li> </ul>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/","title":"ADR 0023: Use fnmatch (Glob Patterns) for Pattern Matching Implementation","text":""},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#date","title":"Date","text":"<p>2025-11-15</p>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#context","title":"Context","text":"<p>ADR-0022 introduced <code>ignore_patterns</code> parameter for pattern-based variable exclusion. This ADR addresses the implementation choice: which pattern syntax to use for matching.</p> <p>Users need to specify patterns like:</p> <ul> <li><code>PS*</code> - all shell prompt variables</li> <li><code>TEMP_*</code> - all temporary variables</li> <li><code>DEBUG_*</code> - all debug flags</li> </ul> <p>We must choose a pattern matching format that is:</p> <ul> <li>Simple and familiar to users</li> <li>Sufficient for common use cases</li> <li>Maintainable (preferably standard library)</li> </ul>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#decision","title":"Decision","text":"<p>Use Python's <code>fnmatch</code> module for glob-style pattern matching.</p> <p>Supported wildcards:</p> <ul> <li><code>*</code> - matches any characters (e.g., <code>PS*</code> matches <code>PS1</code>, <code>PS2</code>, <code>PROMPT</code>)</li> <li><code>?</code> - matches single character (e.g., <code>PS?</code> matches <code>PS1</code>, but not <code>PS10</code>)</li> <li><code>[seq]</code> - matches any character in seq (e.g., <code>PS[12]</code> matches <code>PS1</code>, <code>PS2</code>)</li> </ul> <p>Implementation:</p> <pre><code>import fnmatch\n\ndef _should_ignore_key(self, key: str, ignore_patterns: list[str] | None) -&gt; bool:\n    if ignore_patterns and any(\n        fnmatch.fnmatch(key, pattern) for pattern in ignore_patterns\n    ):\n        return True\n    return False\n</code></pre>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#rationale","title":"Rationale","text":"<p>Why glob patterns:</p> <ul> <li>Familiarity: Users know glob from <code>.gitignore</code>, shell wildcards, file patterns</li> <li>Simplicity: Simpler syntax than regex (no need to escape special chars for basic cases)</li> <li>Coverage: Covers 90% of use cases without complexity</li> <li>Low learning curve: Most developers already understand <code>*</code> and <code>?</code></li> </ul> <p>Why <code>fnmatch</code> module:</p> <ul> <li>Standard library: No external dependencies</li> <li>Well-tested: Part of Python stdlib since early versions</li> <li>Unix shell compatibility: Consistent with shell glob behavior</li> <li>Well-documented: Official Python documentation available</li> </ul> <p>Performance characteristics:</p> <ul> <li>Fast enough for typical use cases (&lt; 100 patterns, &lt; 1000 variables)</li> <li>Linear scan of patterns is acceptable for this use case</li> <li>Exact match check (<code>ignore_keys</code>) happens first as fast path</li> </ul>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#implications","title":"Implications","text":""},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#positive-implications","title":"Positive Implications","text":"<ul> <li>Users can write intuitive patterns: <code>PS*</code>, <code>TEMP_*</code>, <code>DEBUG_*</code></li> <li>No learning curve for developers familiar with shell globs</li> <li>Standard library means no dependency management</li> <li>Consistent behavior across platforms</li> </ul>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#concerns","title":"Concerns","text":"<ul> <li>Limited expressiveness: Cannot express complex patterns like \"starts with PS and ends with digit\"<ul> <li>Mitigation: Sufficient for 90% of use cases; regex can be Phase 3 if needed</li> </ul> </li> <li>Performance with many patterns: O(n*m) for n variables and m patterns<ul> <li>Mitigation: Typical use has &lt; 10 patterns; acceptable performance</li> </ul> </li> </ul>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#alternatives","title":"Alternatives","text":""},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#regex-patterns","title":"Regex Patterns","text":"<p>Use Python's <code>re</code> module for regex matching:</p> <pre><code>import re\n\npatterns = [r\"^PS\\d+$\", r\"^PROMPT.*\", r\"^TEMP_.*\"]\nif any(re.match(pattern, key) for pattern in patterns):\n    return True\n</code></pre> <p>Pros:</p> <ul> <li>More powerful and expressive</li> <li>Can express complex patterns</li> </ul> <p>Cons:</p> <ul> <li>Higher learning curve: Regex is complex for non-experts</li> <li>Overkill: Most use cases don't need regex power</li> <li>Error-prone: Easy to write incorrect regex patterns</li> <li>Less readable: <code>^PS.*$</code> vs. <code>PS*</code></li> </ul> <p>Rejected: Glob covers most use cases with simpler syntax. If complex patterns are needed, we can add regex support in Phase 3 without breaking glob patterns.</p>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#custom-pattern-language","title":"Custom Pattern Language","text":"<p>Design a custom pattern syntax:</p> <pre><code>patterns = [\"starts_with:PS\", \"ends_with:_TMP\", \"contains:DEBUG\"]\n</code></pre> <p>Pros:</p> <ul> <li>Tailored to exact needs</li> <li>Very explicit</li> </ul> <p>Cons:</p> <ul> <li>New syntax to learn: No existing familiarity</li> <li>Implementation complexity: Need to write parser</li> <li>Maintenance burden: Custom code to maintain</li> <li>Limited adoption: No ecosystem support</li> </ul> <p>Rejected: Reinventing the wheel when glob patterns work well.</p>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#simple-string-methods","title":"Simple String Methods","text":"<p>Use only string prefix/suffix matching:</p> <pre><code>if any(key.startswith(prefix) for prefix in prefixes):\n    return True\n</code></pre> <p>Pros:</p> <ul> <li>Very simple, no dependencies</li> <li>Fast</li> </ul> <p>Cons:</p> <ul> <li>Too limited: Cannot express \"ends with\" and \"contains\" patterns in one syntax</li> <li>Multiple parameters needed: <code>ignore_prefixes</code>, <code>ignore_suffixes</code>, <code>ignore_contains</code></li> <li>Less flexible: Cannot combine patterns like <code>PS[12]</code></li> </ul> <p>Rejected: Too limited compared to glob patterns. Glob provides better expressiveness without complexity.</p>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#future-direction","title":"Future Direction","text":"<ul> <li> <p>Phase 3 (if needed): Add regex pattern support via separate parameter (<code>ignore_regex</code>)</p> <ul> <li>Can coexist with glob patterns</li> <li>Users choose based on complexity needs</li> <li>Example: <code>ignore_patterns=[\"PS*\"], ignore_regex=[r\"^VAR\\d{3}$\"]</code></li> </ul> </li> <li> <p>Performance optimization: If profiling shows issues:</p> <ul> <li>Compile patterns once and cache</li> <li>Use trie-based matching for large pattern sets</li> </ul> </li> </ul>"},{"location":"adr/0023-use-fnmatch-for-pattern-matching/#references","title":"References","text":"<ul> <li>ADR-0022: Add ignore_patterns Parameter for Pattern-Based Variable Exclusion</li> <li>Python fnmatch documentation: https://docs.python.org/3/library/fnmatch.html</li> <li>Unix glob patterns: https://man7.org/linux/man-pages/man7/glob.7.html</li> <li>Issue #25: Add ignore_patterns parameter with glob matching support</li> </ul>"},{"location":"api-reference/exceptions/","title":"Exceptions","text":"<p>This section details the custom exception hierarchy used in <code>envresolve</code>.</p>"},{"location":"api-reference/exceptions/#envresolve.exceptions","title":"envresolve.exceptions","text":"<p>Custom exceptions for envresolve.</p>"},{"location":"api-reference/exceptions/#envresolve.exceptions.EnvResolveError","title":"EnvResolveError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all envresolve errors.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class EnvResolveError(Exception):\n    \"\"\"Base exception for all envresolve errors.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.CircularReferenceError","title":"CircularReferenceError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when a circular reference is detected in variable expansion.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class CircularReferenceError(EnvResolveError):\n    \"\"\"Raised when a circular reference is detected in variable expansion.\"\"\"\n\n    def __init__(self, variable_name: str, chain: list[str] | None = None) -&gt; None:\n        \"\"\"Initialize CircularReferenceError.\n\n        Args:\n            variable_name: The variable that caused the circular reference\n            chain: Optional list showing the reference chain\n        \"\"\"\n        self.variable_name = variable_name\n        self.chain = chain or []\n        chain_str = \" -&gt; \".join(self.chain) if self.chain else variable_name\n        msg = f\"Circular reference detected: {chain_str}\"\n        super().__init__(msg)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.CircularReferenceError.__init__","title":"__init__","text":"<pre><code>__init__(\n    variable_name: str, chain: list[str] | None = None\n) -&gt; None\n</code></pre> <p>Initialize CircularReferenceError.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>The variable that caused the circular reference</p> required <code>chain</code> <code>list[str] | None</code> <p>Optional list showing the reference chain</p> <code>None</code> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(self, variable_name: str, chain: list[str] | None = None) -&gt; None:\n    \"\"\"Initialize CircularReferenceError.\n\n    Args:\n        variable_name: The variable that caused the circular reference\n        chain: Optional list showing the reference chain\n    \"\"\"\n    self.variable_name = variable_name\n    self.chain = chain or []\n    chain_str = \" -&gt; \".join(self.chain) if self.chain else variable_name\n    msg = f\"Circular reference detected: {chain_str}\"\n    super().__init__(msg)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.VariableNotFoundError","title":"VariableNotFoundError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when a referenced variable is not found in the environment.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class VariableNotFoundError(EnvResolveError):\n    \"\"\"Raised when a referenced variable is not found in the environment.\"\"\"\n\n    def __init__(self, variable_name: str) -&gt; None:\n        \"\"\"Initialize VariableNotFoundError.\n\n        Args:\n            variable_name: The variable that was not found\n        \"\"\"\n        self.variable_name = variable_name\n        super().__init__(f\"Variable not found: {variable_name}\")\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.VariableNotFoundError.__init__","title":"__init__","text":"<pre><code>__init__(variable_name: str) -&gt; None\n</code></pre> <p>Initialize VariableNotFoundError.</p> <p>Parameters:</p> Name Type Description Default <code>variable_name</code> <code>str</code> <p>The variable that was not found</p> required Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(self, variable_name: str) -&gt; None:\n    \"\"\"Initialize VariableNotFoundError.\n\n    Args:\n        variable_name: The variable that was not found\n    \"\"\"\n    self.variable_name = variable_name\n    super().__init__(f\"Variable not found: {variable_name}\")\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.URIParseError","title":"URIParseError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when a secret URI cannot be parsed.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class URIParseError(EnvResolveError):\n    \"\"\"Raised when a secret URI cannot be parsed.\"\"\"\n\n    def __init__(self, message: str, uri: str | None = None) -&gt; None:\n        \"\"\"Initialize URIParseError.\n\n        Args:\n            message: Error message describing the parsing failure\n            uri: The URI that failed to parse (optional)\n        \"\"\"\n        self.uri = uri\n        full_message = f\"{message}: {uri}\" if uri else message\n        super().__init__(full_message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.URIParseError.__init__","title":"__init__","text":"<pre><code>__init__(message: str, uri: str | None = None) -&gt; None\n</code></pre> <p>Initialize URIParseError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message describing the parsing failure</p> required <code>uri</code> <code>str | None</code> <p>The URI that failed to parse (optional)</p> <code>None</code> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(self, message: str, uri: str | None = None) -&gt; None:\n    \"\"\"Initialize URIParseError.\n\n    Args:\n        message: Error message describing the parsing failure\n        uri: The URI that failed to parse (optional)\n    \"\"\"\n    self.uri = uri\n    full_message = f\"{message}: {uri}\" if uri else message\n    super().__init__(full_message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.SecretResolutionError","title":"SecretResolutionError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when a secret cannot be resolved from its provider.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class SecretResolutionError(EnvResolveError):\n    \"\"\"Raised when a secret cannot be resolved from its provider.\"\"\"\n\n    def __init__(\n        self, message: str, uri: str, original_error: Exception | None = None\n    ) -&gt; None:\n        \"\"\"Initialize SecretResolutionError.\n\n        Args:\n            message: Error message describing the resolution failure\n            uri: The URI that failed to resolve\n            original_error: The original exception that caused this error (optional)\n        \"\"\"\n        self.uri = uri\n        self.original_error = original_error\n        full_message = f\"{message}: {uri}\"\n        if original_error:\n            full_message = f\"{full_message} (caused by: {original_error})\"\n        super().__init__(full_message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.SecretResolutionError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str,\n    uri: str,\n    original_error: Exception | None = None,\n) -&gt; None\n</code></pre> <p>Initialize SecretResolutionError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message describing the resolution failure</p> required <code>uri</code> <code>str</code> <p>The URI that failed to resolve</p> required <code>original_error</code> <code>Exception | None</code> <p>The original exception that caused this error (optional)</p> <code>None</code> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(\n    self, message: str, uri: str, original_error: Exception | None = None\n) -&gt; None:\n    \"\"\"Initialize SecretResolutionError.\n\n    Args:\n        message: Error message describing the resolution failure\n        uri: The URI that failed to resolve\n        original_error: The original exception that caused this error (optional)\n    \"\"\"\n    self.uri = uri\n    self.original_error = original_error\n    full_message = f\"{message}: {uri}\"\n    if original_error:\n        full_message = f\"{full_message} (caused by: {original_error})\"\n    super().__init__(full_message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.ProviderRegistrationError","title":"ProviderRegistrationError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when a provider registration fails.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class ProviderRegistrationError(EnvResolveError):\n    \"\"\"Raised when a provider registration fails.\"\"\"\n\n    def __init__(self, message: str, original_error: Exception | None = None) -&gt; None:\n        \"\"\"Initialize ProviderRegistrationError.\n\n        Args:\n            message: Error message describing the registration failure\n            original_error: The original exception that caused this error (optional)\n        \"\"\"\n        self.original_error = original_error\n        super().__init__(message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.ProviderRegistrationError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str, original_error: Exception | None = None\n) -&gt; None\n</code></pre> <p>Initialize ProviderRegistrationError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message describing the registration failure</p> required <code>original_error</code> <code>Exception | None</code> <p>The original exception that caused this error (optional)</p> <code>None</code> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(self, message: str, original_error: Exception | None = None) -&gt; None:\n    \"\"\"Initialize ProviderRegistrationError.\n\n    Args:\n        message: Error message describing the registration failure\n        original_error: The original exception that caused this error (optional)\n    \"\"\"\n    self.original_error = original_error\n    super().__init__(message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.MutuallyExclusiveArgumentsError","title":"MutuallyExclusiveArgumentsError","text":"<p>               Bases: <code>EnvResolveError</code>, <code>TypeError</code></p> <p>Raised when mutually exclusive arguments are specified together.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class MutuallyExclusiveArgumentsError(EnvResolveError, TypeError):\n    \"\"\"Raised when mutually exclusive arguments are specified together.\"\"\"\n\n    def __init__(self, arg1: str, arg2: str) -&gt; None:\n        \"\"\"Initialize MutuallyExclusiveArgumentsError.\n\n        Args:\n            arg1: First mutually exclusive argument name\n            arg2: Second mutually exclusive argument name\n        \"\"\"\n        self.arg1 = arg1\n        self.arg2 = arg2\n        msg = (\n            f\"Arguments '{arg1}' and '{arg2}' are mutually exclusive. \"\n            f\"Specify either '{arg1}' or '{arg2}', but not both.\"\n        )\n        super().__init__(msg)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.MutuallyExclusiveArgumentsError.__init__","title":"__init__","text":"<pre><code>__init__(arg1: str, arg2: str) -&gt; None\n</code></pre> <p>Initialize MutuallyExclusiveArgumentsError.</p> <p>Parameters:</p> Name Type Description Default <code>arg1</code> <code>str</code> <p>First mutually exclusive argument name</p> required <code>arg2</code> <code>str</code> <p>Second mutually exclusive argument name</p> required Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(self, arg1: str, arg2: str) -&gt; None:\n    \"\"\"Initialize MutuallyExclusiveArgumentsError.\n\n    Args:\n        arg1: First mutually exclusive argument name\n        arg2: Second mutually exclusive argument name\n    \"\"\"\n    self.arg1 = arg1\n    self.arg2 = arg2\n    msg = (\n        f\"Arguments '{arg1}' and '{arg2}' are mutually exclusive. \"\n        f\"Specify either '{arg1}' or '{arg2}', but not both.\"\n    )\n    super().__init__(msg)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.EnvironmentVariableResolutionError","title":"EnvironmentVariableResolutionError","text":"<p>               Bases: <code>EnvResolveError</code></p> <p>Raised when an error occurs during environment variable resolution.</p> <p>This exception wraps underlying errors (VariableNotFoundError, SecretResolutionError, etc.) and provides context about which environment variable was being processed.</p> Source code in <code>src/envresolve/exceptions.py</code> <pre><code>class EnvironmentVariableResolutionError(EnvResolveError):\n    \"\"\"Raised when an error occurs during environment variable resolution.\n\n    This exception wraps underlying errors (VariableNotFoundError,\n    SecretResolutionError, etc.) and provides context about which\n    environment variable was being processed.\n    \"\"\"\n\n    def __init__(\n        self, message: str, context_key: str, original_error: Exception\n    ) -&gt; None:\n        \"\"\"Initialize EnvironmentVariableResolutionError.\n\n        Args:\n            message: Error message describing what went wrong\n            context_key: The environment variable name being processed\n            original_error: The underlying exception that caused this error\n        \"\"\"\n        self.context_key = context_key\n        self.original_error = original_error\n        super().__init__(message)\n</code></pre>"},{"location":"api-reference/exceptions/#envresolve.exceptions.EnvironmentVariableResolutionError.__init__","title":"__init__","text":"<pre><code>__init__(\n    message: str,\n    context_key: str,\n    original_error: Exception,\n) -&gt; None\n</code></pre> <p>Initialize EnvironmentVariableResolutionError.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message describing what went wrong</p> required <code>context_key</code> <code>str</code> <p>The environment variable name being processed</p> required <code>original_error</code> <code>Exception</code> <p>The underlying exception that caused this error</p> required Source code in <code>src/envresolve/exceptions.py</code> <pre><code>def __init__(\n    self, message: str, context_key: str, original_error: Exception\n) -&gt; None:\n    \"\"\"Initialize EnvironmentVariableResolutionError.\n\n    Args:\n        message: Error message describing what went wrong\n        context_key: The environment variable name being processed\n        original_error: The underlying exception that caused this error\n    \"\"\"\n    self.context_key = context_key\n    self.original_error = original_error\n    super().__init__(message)\n</code></pre>"},{"location":"api-reference/providers/","title":"Providers","text":"<p>Providers are responsible for fetching secrets from external stores. Learn how to use existing providers or create your own.</p>"},{"location":"api-reference/providers/#azure-key-vault-provider","title":"Azure Key Vault Provider","text":""},{"location":"api-reference/providers/#envresolve.providers.azure_kv","title":"envresolve.providers.azure_kv","text":"<p>Azure Key Vault provider implementation.</p>"},{"location":"api-reference/providers/#envresolve.providers.azure_kv.AzureKVProvider","title":"AzureKVProvider","text":"<p>Provider for resolving secrets from Azure Key Vault.</p> <p>Supports both akv:// and kv:// URI schemes. Uses DefaultAzureCredential for authentication. Caches SecretClient instances per vault for efficiency.</p> Source code in <code>src/envresolve/providers/azure_kv.py</code> <pre><code>class AzureKVProvider:\n    \"\"\"Provider for resolving secrets from Azure Key Vault.\n\n    Supports both akv:// and kv:// URI schemes.\n    Uses DefaultAzureCredential for authentication.\n    Caches SecretClient instances per vault for efficiency.\n    \"\"\"\n\n    def __init__(self, credential: \"TokenCredential | None\" = None) -&gt; None:\n        \"\"\"Initialize Azure Key Vault provider.\n\n        Args:\n            credential: Azure credential to use.\n                If None, DefaultAzureCredential is used.\n        \"\"\"\n        self.credential = credential or DefaultAzureCredential()\n        self._clients: dict[str, SecretClient] = {}\n\n    def _get_client(self, vault_name: str) -&gt; SecretClient:\n        \"\"\"Get or create a SecretClient for the given vault.\n\n        Args:\n            vault_name: Name of the Key Vault\n\n        Returns:\n            SecretClient instance for the vault\n        \"\"\"\n        if vault_name not in self._clients:\n            vault_url = f\"https://{vault_name}.vault.azure.net\"\n            self._clients[vault_name] = SecretClient(\n                vault_url=vault_url, credential=self.credential\n            )\n        return self._clients[vault_name]\n\n    def resolve(self, parsed_uri: ParsedURI) -&gt; str:\n        \"\"\"Resolve a secret from Azure Key Vault.\n\n        Args:\n            parsed_uri: Parsed URI dictionary containing vault, secret,\n                and optional version\n\n        Returns:\n            The secret value as a string\n\n        Raises:\n            SecretResolutionError: If the secret cannot be resolved\n        \"\"\"\n        vault_name = parsed_uri[\"vault\"]\n        secret_name = parsed_uri[\"secret\"]\n        version = parsed_uri[\"version\"]\n\n        # Reconstruct URI for error messages\n        uri = f\"{parsed_uri['scheme']}://{vault_name}/{secret_name}\"\n        if version:\n            uri = f\"{uri}?version={version}\"\n\n        try:\n            client = self._get_client(vault_name)\n            secret = client.get_secret(secret_name, version=version)\n        except AzureError as e:\n            msg = \"Failed to resolve secret from Azure Key Vault\"\n            raise SecretResolutionError(msg, uri=uri, original_error=e) from e\n        else:\n            if secret.value is None:\n                msg = \"Secret value is None\"\n                raise SecretResolutionError(msg, uri=uri)\n            return secret.value\n</code></pre>"},{"location":"api-reference/providers/#envresolve.providers.azure_kv.AzureKVProvider.__init__","title":"__init__","text":"<pre><code>__init__(credential: TokenCredential | None = None) -&gt; None\n</code></pre> <p>Initialize Azure Key Vault provider.</p> <p>Parameters:</p> Name Type Description Default <code>credential</code> <code>TokenCredential | None</code> <p>Azure credential to use. If None, DefaultAzureCredential is used.</p> <code>None</code> Source code in <code>src/envresolve/providers/azure_kv.py</code> <pre><code>def __init__(self, credential: \"TokenCredential | None\" = None) -&gt; None:\n    \"\"\"Initialize Azure Key Vault provider.\n\n    Args:\n        credential: Azure credential to use.\n            If None, DefaultAzureCredential is used.\n    \"\"\"\n    self.credential = credential or DefaultAzureCredential()\n    self._clients: dict[str, SecretClient] = {}\n</code></pre>"},{"location":"api-reference/providers/#envresolve.providers.azure_kv.AzureKVProvider.resolve","title":"resolve","text":"<pre><code>resolve(parsed_uri: ParsedURI) -&gt; str\n</code></pre> <p>Resolve a secret from Azure Key Vault.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_uri</code> <code>ParsedURI</code> <p>Parsed URI dictionary containing vault, secret, and optional version</p> required <p>Returns:</p> Type Description <code>str</code> <p>The secret value as a string</p> <p>Raises:</p> Type Description <code>SecretResolutionError</code> <p>If the secret cannot be resolved</p> Source code in <code>src/envresolve/providers/azure_kv.py</code> <pre><code>def resolve(self, parsed_uri: ParsedURI) -&gt; str:\n    \"\"\"Resolve a secret from Azure Key Vault.\n\n    Args:\n        parsed_uri: Parsed URI dictionary containing vault, secret,\n            and optional version\n\n    Returns:\n        The secret value as a string\n\n    Raises:\n        SecretResolutionError: If the secret cannot be resolved\n    \"\"\"\n    vault_name = parsed_uri[\"vault\"]\n    secret_name = parsed_uri[\"secret\"]\n    version = parsed_uri[\"version\"]\n\n    # Reconstruct URI for error messages\n    uri = f\"{parsed_uri['scheme']}://{vault_name}/{secret_name}\"\n    if version:\n        uri = f\"{uri}?version={version}\"\n\n    try:\n        client = self._get_client(vault_name)\n        secret = client.get_secret(secret_name, version=version)\n    except AzureError as e:\n        msg = \"Failed to resolve secret from Azure Key Vault\"\n        raise SecretResolutionError(msg, uri=uri, original_error=e) from e\n    else:\n        if secret.value is None:\n            msg = \"Secret value is None\"\n            raise SecretResolutionError(msg, uri=uri)\n        return secret.value\n</code></pre>"},{"location":"api-reference/providers/#base-provider-for-custom-implementations","title":"Base Provider (for custom implementations)","text":""},{"location":"api-reference/providers/#envresolve.providers.base","title":"envresolve.providers.base","text":"<p>Base provider protocol.</p>"},{"location":"api-reference/providers/#envresolve.providers.base.SecretProvider","title":"SecretProvider","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for secret providers.</p> Source code in <code>src/envresolve/providers/base.py</code> <pre><code>class SecretProvider(Protocol):\n    \"\"\"Protocol for secret providers.\"\"\"\n\n    def resolve(self, parsed_uri: ParsedURI) -&gt; str:\n        \"\"\"Resolve a secret from its provider.\n\n        Args:\n            parsed_uri: Parsed URI dictionary\n\n        Returns:\n            The secret value as a string\n\n        Raises:\n            SecretResolutionError: If the secret cannot be resolved\n        \"\"\"\n        ...\n</code></pre>"},{"location":"api-reference/providers/#envresolve.providers.base.SecretProvider.resolve","title":"resolve","text":"<pre><code>resolve(parsed_uri: ParsedURI) -&gt; str\n</code></pre> <p>Resolve a secret from its provider.</p> <p>Parameters:</p> Name Type Description Default <code>parsed_uri</code> <code>ParsedURI</code> <p>Parsed URI dictionary</p> required <p>Returns:</p> Type Description <code>str</code> <p>The secret value as a string</p> <p>Raises:</p> Type Description <code>SecretResolutionError</code> <p>If the secret cannot be resolved</p> Source code in <code>src/envresolve/providers/base.py</code> <pre><code>def resolve(self, parsed_uri: ParsedURI) -&gt; str:\n    \"\"\"Resolve a secret from its provider.\n\n    Args:\n        parsed_uri: Parsed URI dictionary\n\n    Returns:\n        The secret value as a string\n\n    Raises:\n        SecretResolutionError: If the secret cannot be resolved\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api-reference/public_api/","title":"Public API","text":"<p>This section covers the main functions intended for direct use in your applications.</p>"},{"location":"api-reference/public_api/#envresolve.api","title":"envresolve.api","text":"<p>Public API for envresolve.</p>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver","title":"EnvResolver","text":"<p>Manages provider registration and secret resolution.</p> <p>This class encapsulates the provider registry and resolver instance, eliminating the need for module-level global variables.</p> Source code in <code>src/envresolve/api.py</code> <pre><code>class EnvResolver:\n    \"\"\"Manages provider registration and secret resolution.\n\n    This class encapsulates the provider registry and resolver instance,\n    eliminating the need for module-level global variables.\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize an empty provider registry.\"\"\"\n        self._providers: dict[str, SecretProvider] = {}\n        self._resolver: SecretResolver | None = None\n\n    def _get_resolver(self) -&gt; SecretResolver:\n        \"\"\"Get or create the resolver instance.\n\n        Returns:\n            SecretResolver instance configured with registered providers\n        \"\"\"\n        if self._resolver is None:\n            self._resolver = SecretResolver(self._providers)\n        return self._resolver\n\n    def register_azure_kv_provider(\n        self, provider: \"SecretProvider | None\" = None\n    ) -&gt; None:\n        \"\"\"Register Azure Key Vault provider for akv:// scheme.\n\n        This method is safe to call multiple times (idempotent).\n\n        Args:\n            provider: Optional custom provider. If None, uses default AzureKVProvider.\n\n        Raises:\n            ProviderRegistrationError: If azure-identity or azure-keyvault-secrets\n                is not installed (only when provider is None)\n        \"\"\"\n        if provider is None:\n            try:\n                # Dynamically import the provider module\n                provider_module = importlib.import_module(\n                    \"envresolve.providers.azure_kv\"\n                )\n                provider_class = provider_module.AzureKVProvider\n            except ImportError as e:\n                # Check which dependency is missing\n                missing_deps: list[str] = []\n                try:\n                    importlib.import_module(\"azure.identity\")\n                except ImportError:\n                    missing_deps.append(\"azure-identity\")\n\n                try:\n                    importlib.import_module(\"azure.keyvault.secrets\")\n                except ImportError:\n                    missing_deps.append(\"azure-keyvault-secrets\")\n\n                if missing_deps:\n                    deps_str = \", \".join(missing_deps)\n                    msg = (\n                        f\"Azure Key Vault provider requires: {deps_str}. \"\n                        \"Install with: pip install envresolve[azure]\"\n                    )\n                else:\n                    msg = f\"Failed to import Azure Key Vault provider. Error: {e}\"\n                raise ProviderRegistrationError(msg, original_error=e) from e\n            self._providers[\"akv\"] = provider_class()\n        else:\n            self._providers[\"akv\"] = provider\n        # Reset resolver to pick up new providers\n        self._resolver = None\n\n    def resolve_secret(self, uri: str) -&gt; str:\n        \"\"\"Resolve a secret URI to its value.\n\n        This function supports:\n        - Variable expansion: ${VAR} and $VAR syntax using os.environ\n        - Secret URI resolution: akv:// scheme\n        - Idempotent resolution: Plain strings and non-target URIs pass through\n\n        Args:\n            uri: Secret URI or plain string to resolve\n\n        Returns:\n            Resolved secret value or the original string if not a secret URI\n\n        Raises:\n            URIParseError: If the URI format is invalid\n            SecretResolutionError: If secret resolution fails\n            VariableNotFoundError: If a referenced variable is not found\n            CircularReferenceError: If a circular variable reference is detected\n        \"\"\"\n        resolver = self._get_resolver()\n        return resolver.resolve(uri)\n\n    def resolve_with_env(self, value: str, env: dict[str, str]) -&gt; str:\n        \"\"\"Expand variables and resolve secret URIs with custom environment.\n\n        Args:\n            value: Value to resolve (may contain variables or be a secret URI)\n            env: Environment dict for variable expansion\n\n        Returns:\n            Resolved value\n        \"\"\"\n        resolver = self._get_resolver()\n        return resolver.resolve(value, env)\n\n    def load_env(  # noqa: PLR0913\n        self,\n        dotenv_path: str | Path | None = None,\n        *,\n        export: bool = True,\n        override: bool = False,\n        stop_on_expansion_error: bool = True,\n        stop_on_resolution_error: bool = True,\n        ignore_keys: list[str] | None = None,\n        ignore_patterns: list[str] | None = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"Load environment variables from a .env file and resolve secret URIs.\n\n        This function:\n        1. Loads variables from the .env file\n        2. Expands variable references within values\n        3. Resolves secret URIs (akv://) to actual secret values\n        4. Optionally exports to os.environ\n\n        Args:\n            dotenv_path: Path to .env file. If None, searches for .env in\n                current directory. Mimics python-dotenv's load_dotenv() behavior.\n                (default: None)\n            export: If True, export resolved variables to os.environ\n            override: If True, override existing os.environ variables\n            stop_on_expansion_error: If False, skip variables with expansion errors\n                (e.g., VariableNotFoundError). CircularReferenceError is always\n                raised as it indicates a configuration error. (default: True)\n            stop_on_resolution_error: If False, skip variables with resolution errors\n                (e.g., SecretResolutionError). Useful for resilience against transient\n                secret store failures. (default: True)\n            ignore_keys: List of keys to skip expansion for. These keys are included\n                in the result as-is without variable expansion or secret resolution.\n                (default: None)\n            ignore_patterns: List of glob patterns to match keys for skipping expansion.\n                Keys matching any pattern are included as-is without variable expansion\n                or secret resolution. Supports wildcards: *, ?, [seq]. (default: None)\n\n        Returns:\n            Dictionary of resolved environment variables\n\n        Raises:\n            EnvironmentVariableResolutionError: If a variable resolution error occurs\n                (wraps VariableNotFoundError or SecretResolutionError with context)\n            URIParseError: If a URI format is invalid\n            CircularReferenceError: If a circular variable reference is detected\n        \"\"\"\n        # Load .env file\n        # When dotenv_path is None, use find_dotenv with usecwd=True\n        if dotenv_path is None:\n            dotenv_path = find_dotenv(usecwd=True)\n        # Use interpolate=False to prevent python-dotenv from expanding variables\n        # We handle expansion ourselves in resolve_with_env\n        env_dict = {\n            k: v\n            for k, v in dotenv_values(dotenv_path, interpolate=False).items()\n            if v is not None\n        }\n\n        # Build complete environment (for variable expansion)\n        complete_env = dict(os.environ)\n        complete_env.update(env_dict)\n\n        # Resolve each variable\n        resolved: dict[str, str] = {}\n        for key, value in env_dict.items():\n            # Skip expansion for ignored keys or patterns\n            if self._should_ignore_key(key, ignore_keys, ignore_patterns):\n                resolved[key] = value\n                continue\n\n            try:\n                resolved_value = self._resolve_variable(\n                    value,\n                    complete_env,\n                    stop_on_expansion_error=stop_on_expansion_error,\n                    stop_on_resolution_error=stop_on_resolution_error,\n                )\n            except (VariableNotFoundError, SecretResolutionError) as e:\n                msg = f\"Failed to resolve environment variable '{key}': {e}\"\n                raise EnvironmentVariableResolutionError(\n                    msg,\n                    context_key=key,\n                    original_error=e,\n                ) from e\n            if resolved_value is None:\n                continue\n\n            resolved[key] = resolved_value\n\n        # Export to os.environ if requested\n        if export:\n            for key, value in resolved.items():\n                if override or key not in os.environ:\n                    os.environ[key] = value\n\n        return resolved\n\n    def _get_target_environ(\n        self, keys: list[str] | None, prefix: str | None\n    ) -&gt; dict[str, str]:\n        \"\"\"Get the target environment variables to process.\"\"\"\n        if keys is not None:\n            return {k: os.environ[k] for k in keys if k in os.environ}\n        if prefix is not None:\n            return {k: v for k, v in os.environ.items() if k.startswith(prefix)}\n        return dict(os.environ)\n\n    def _should_ignore_key(\n        self, key: str, ignore_keys: list[str] | None, ignore_patterns: list[str] | None\n    ) -&gt; bool:\n        \"\"\"Check if a key should be ignored based on exact match or pattern match.\n\n        Args:\n            key: Environment variable key to check\n            ignore_keys: List of keys for exact matching\n            ignore_patterns: List of glob patterns for pattern matching\n\n        Returns:\n            True if the key should be ignored, False otherwise\n        \"\"\"\n        # Check exact match\n        if ignore_keys and key in ignore_keys:\n            return True\n\n        # Check pattern match\n        return bool(\n            ignore_patterns\n            and any(fnmatch.fnmatch(key, pattern) for pattern in ignore_patterns)\n        )\n\n    def _resolve_variable(\n        self,\n        value: str,\n        env: dict[str, str] | None = None,\n        *,\n        stop_on_expansion_error: bool,\n        stop_on_resolution_error: bool,\n    ) -&gt; str | None:\n        \"\"\"Resolve a single variable, handling errors granularly.\n\n        Args:\n            value: Value to resolve (may contain variables or be a secret URI)\n            env: Environment dict for variable expansion. If None, uses os.environ.\n            stop_on_expansion_error: If False, return None on VariableNotFoundError\n            stop_on_resolution_error: If False, return None on SecretResolutionError\n\n        Returns:\n            Resolved value, or None if error occurred and corresponding flag is False\n        \"\"\"\n        if env is None:\n            env = dict(os.environ)\n        try:\n            return self.resolve_with_env(value, env)\n        except VariableNotFoundError:\n            if stop_on_expansion_error:\n                raise\n            return None\n        except SecretResolutionError:\n            if stop_on_resolution_error:\n                raise\n            return None\n        # CircularReferenceError is always raised as it's a configuration error.\n\n    def resolve_os_environ(  # noqa: PLR0913\n        self,\n        keys: list[str] | None = None,\n        prefix: str | None = None,\n        *,\n        overwrite: bool = True,\n        stop_on_expansion_error: bool = True,\n        stop_on_resolution_error: bool = True,\n        ignore_keys: list[str] | None = None,\n        ignore_patterns: list[str] | None = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"Resolve secret URIs in os.environ.\n\n        Raises:\n            EnvironmentVariableResolutionError: If a variable resolution error occurs\n                (wraps VariableNotFoundError or SecretResolutionError with context)\n            MutuallyExclusiveArgumentsError: If both keys and prefix are specified\n            URIParseError: If the URI format is invalid\n            CircularReferenceError: If a circular variable reference is detected\n        \"\"\"\n        if keys is not None and prefix is not None:\n            arg1 = \"keys\"\n            arg2 = \"prefix\"\n            raise MutuallyExclusiveArgumentsError(arg1, arg2)\n\n        target_env = self._get_target_environ(keys, prefix)\n        resolved: dict[str, str] = {}\n\n        for key, value in target_env.items():\n            # Skip expansion for ignored keys or patterns\n            if self._should_ignore_key(key, ignore_keys, ignore_patterns):\n                resolved[key] = value\n                if overwrite:\n                    os.environ[key] = value\n                continue\n\n            try:\n                resolved_value = self._resolve_variable(\n                    value,\n                    stop_on_expansion_error=stop_on_expansion_error,\n                    stop_on_resolution_error=stop_on_resolution_error,\n                )\n            except (VariableNotFoundError, SecretResolutionError) as e:\n                msg = f\"Failed to resolve environment variable '{key}': {e}\"\n                raise EnvironmentVariableResolutionError(\n                    msg,\n                    context_key=key,\n                    original_error=e,\n                ) from e\n            if resolved_value is None:\n                continue\n\n            output_key = (\n                key[len(prefix) :] if prefix and key.startswith(prefix) else key\n            )\n            resolved[output_key] = resolved_value\n\n            if overwrite:\n                os.environ[output_key] = resolved_value\n                if prefix and key != output_key:\n                    del os.environ[key]\n\n        return resolved\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.__init__","title":"__init__","text":"<pre><code>__init__() -&gt; None\n</code></pre> <p>Initialize an empty provider registry.</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize an empty provider registry.\"\"\"\n    self._providers: dict[str, SecretProvider] = {}\n    self._resolver: SecretResolver | None = None\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.register_azure_kv_provider","title":"register_azure_kv_provider","text":"<pre><code>register_azure_kv_provider(\n    provider: SecretProvider | None = None,\n) -&gt; None\n</code></pre> <p>Register Azure Key Vault provider for akv:// scheme.</p> <p>This method is safe to call multiple times (idempotent).</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>SecretProvider | None</code> <p>Optional custom provider. If None, uses default AzureKVProvider.</p> <code>None</code> <p>Raises:</p> Type Description <code>ProviderRegistrationError</code> <p>If azure-identity or azure-keyvault-secrets is not installed (only when provider is None)</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def register_azure_kv_provider(\n    self, provider: \"SecretProvider | None\" = None\n) -&gt; None:\n    \"\"\"Register Azure Key Vault provider for akv:// scheme.\n\n    This method is safe to call multiple times (idempotent).\n\n    Args:\n        provider: Optional custom provider. If None, uses default AzureKVProvider.\n\n    Raises:\n        ProviderRegistrationError: If azure-identity or azure-keyvault-secrets\n            is not installed (only when provider is None)\n    \"\"\"\n    if provider is None:\n        try:\n            # Dynamically import the provider module\n            provider_module = importlib.import_module(\n                \"envresolve.providers.azure_kv\"\n            )\n            provider_class = provider_module.AzureKVProvider\n        except ImportError as e:\n            # Check which dependency is missing\n            missing_deps: list[str] = []\n            try:\n                importlib.import_module(\"azure.identity\")\n            except ImportError:\n                missing_deps.append(\"azure-identity\")\n\n            try:\n                importlib.import_module(\"azure.keyvault.secrets\")\n            except ImportError:\n                missing_deps.append(\"azure-keyvault-secrets\")\n\n            if missing_deps:\n                deps_str = \", \".join(missing_deps)\n                msg = (\n                    f\"Azure Key Vault provider requires: {deps_str}. \"\n                    \"Install with: pip install envresolve[azure]\"\n                )\n            else:\n                msg = f\"Failed to import Azure Key Vault provider. Error: {e}\"\n            raise ProviderRegistrationError(msg, original_error=e) from e\n        self._providers[\"akv\"] = provider_class()\n    else:\n        self._providers[\"akv\"] = provider\n    # Reset resolver to pick up new providers\n    self._resolver = None\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.resolve_secret","title":"resolve_secret","text":"<pre><code>resolve_secret(uri: str) -&gt; str\n</code></pre> <p>Resolve a secret URI to its value.</p> <p>This function supports: - Variable expansion: ${VAR} and $VAR syntax using os.environ - Secret URI resolution: akv:// scheme - Idempotent resolution: Plain strings and non-target URIs pass through</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Secret URI or plain string to resolve</p> required <p>Returns:</p> Type Description <code>str</code> <p>Resolved secret value or the original string if not a secret URI</p> <p>Raises:</p> Type Description <code>URIParseError</code> <p>If the URI format is invalid</p> <code>SecretResolutionError</code> <p>If secret resolution fails</p> <code>VariableNotFoundError</code> <p>If a referenced variable is not found</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def resolve_secret(self, uri: str) -&gt; str:\n    \"\"\"Resolve a secret URI to its value.\n\n    This function supports:\n    - Variable expansion: ${VAR} and $VAR syntax using os.environ\n    - Secret URI resolution: akv:// scheme\n    - Idempotent resolution: Plain strings and non-target URIs pass through\n\n    Args:\n        uri: Secret URI or plain string to resolve\n\n    Returns:\n        Resolved secret value or the original string if not a secret URI\n\n    Raises:\n        URIParseError: If the URI format is invalid\n        SecretResolutionError: If secret resolution fails\n        VariableNotFoundError: If a referenced variable is not found\n        CircularReferenceError: If a circular variable reference is detected\n    \"\"\"\n    resolver = self._get_resolver()\n    return resolver.resolve(uri)\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.resolve_with_env","title":"resolve_with_env","text":"<pre><code>resolve_with_env(value: str, env: dict[str, str]) -&gt; str\n</code></pre> <p>Expand variables and resolve secret URIs with custom environment.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>str</code> <p>Value to resolve (may contain variables or be a secret URI)</p> required <code>env</code> <code>dict[str, str]</code> <p>Environment dict for variable expansion</p> required <p>Returns:</p> Type Description <code>str</code> <p>Resolved value</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def resolve_with_env(self, value: str, env: dict[str, str]) -&gt; str:\n    \"\"\"Expand variables and resolve secret URIs with custom environment.\n\n    Args:\n        value: Value to resolve (may contain variables or be a secret URI)\n        env: Environment dict for variable expansion\n\n    Returns:\n        Resolved value\n    \"\"\"\n    resolver = self._get_resolver()\n    return resolver.resolve(value, env)\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.load_env","title":"load_env","text":"<pre><code>load_env(\n    dotenv_path: str | Path | None = None,\n    *,\n    export: bool = True,\n    override: bool = False,\n    stop_on_expansion_error: bool = True,\n    stop_on_resolution_error: bool = True,\n    ignore_keys: list[str] | None = None,\n    ignore_patterns: list[str] | None = None,\n) -&gt; dict[str, str]\n</code></pre> <p>Load environment variables from a .env file and resolve secret URIs.</p> <p>This function: 1. Loads variables from the .env file 2. Expands variable references within values 3. Resolves secret URIs (akv://) to actual secret values 4. Optionally exports to os.environ</p> <p>Parameters:</p> Name Type Description Default <code>dotenv_path</code> <code>str | Path | None</code> <p>Path to .env file. If None, searches for .env in current directory. Mimics python-dotenv's load_dotenv() behavior. (default: None)</p> <code>None</code> <code>export</code> <code>bool</code> <p>If True, export resolved variables to os.environ</p> <code>True</code> <code>override</code> <code>bool</code> <p>If True, override existing os.environ variables</p> <code>False</code> <code>stop_on_expansion_error</code> <code>bool</code> <p>If False, skip variables with expansion errors (e.g., VariableNotFoundError). CircularReferenceError is always raised as it indicates a configuration error. (default: True)</p> <code>True</code> <code>stop_on_resolution_error</code> <code>bool</code> <p>If False, skip variables with resolution errors (e.g., SecretResolutionError). Useful for resilience against transient secret store failures. (default: True)</p> <code>True</code> <code>ignore_keys</code> <code>list[str] | None</code> <p>List of keys to skip expansion for. These keys are included in the result as-is without variable expansion or secret resolution. (default: None)</p> <code>None</code> <code>ignore_patterns</code> <code>list[str] | None</code> <p>List of glob patterns to match keys for skipping expansion. Keys matching any pattern are included as-is without variable expansion or secret resolution. Supports wildcards: *, ?, [seq]. (default: None)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of resolved environment variables</p> <p>Raises:</p> Type Description <code>EnvironmentVariableResolutionError</code> <p>If a variable resolution error occurs (wraps VariableNotFoundError or SecretResolutionError with context)</p> <code>URIParseError</code> <p>If a URI format is invalid</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def load_env(  # noqa: PLR0913\n    self,\n    dotenv_path: str | Path | None = None,\n    *,\n    export: bool = True,\n    override: bool = False,\n    stop_on_expansion_error: bool = True,\n    stop_on_resolution_error: bool = True,\n    ignore_keys: list[str] | None = None,\n    ignore_patterns: list[str] | None = None,\n) -&gt; dict[str, str]:\n    \"\"\"Load environment variables from a .env file and resolve secret URIs.\n\n    This function:\n    1. Loads variables from the .env file\n    2. Expands variable references within values\n    3. Resolves secret URIs (akv://) to actual secret values\n    4. Optionally exports to os.environ\n\n    Args:\n        dotenv_path: Path to .env file. If None, searches for .env in\n            current directory. Mimics python-dotenv's load_dotenv() behavior.\n            (default: None)\n        export: If True, export resolved variables to os.environ\n        override: If True, override existing os.environ variables\n        stop_on_expansion_error: If False, skip variables with expansion errors\n            (e.g., VariableNotFoundError). CircularReferenceError is always\n            raised as it indicates a configuration error. (default: True)\n        stop_on_resolution_error: If False, skip variables with resolution errors\n            (e.g., SecretResolutionError). Useful for resilience against transient\n            secret store failures. (default: True)\n        ignore_keys: List of keys to skip expansion for. These keys are included\n            in the result as-is without variable expansion or secret resolution.\n            (default: None)\n        ignore_patterns: List of glob patterns to match keys for skipping expansion.\n            Keys matching any pattern are included as-is without variable expansion\n            or secret resolution. Supports wildcards: *, ?, [seq]. (default: None)\n\n    Returns:\n        Dictionary of resolved environment variables\n\n    Raises:\n        EnvironmentVariableResolutionError: If a variable resolution error occurs\n            (wraps VariableNotFoundError or SecretResolutionError with context)\n        URIParseError: If a URI format is invalid\n        CircularReferenceError: If a circular variable reference is detected\n    \"\"\"\n    # Load .env file\n    # When dotenv_path is None, use find_dotenv with usecwd=True\n    if dotenv_path is None:\n        dotenv_path = find_dotenv(usecwd=True)\n    # Use interpolate=False to prevent python-dotenv from expanding variables\n    # We handle expansion ourselves in resolve_with_env\n    env_dict = {\n        k: v\n        for k, v in dotenv_values(dotenv_path, interpolate=False).items()\n        if v is not None\n    }\n\n    # Build complete environment (for variable expansion)\n    complete_env = dict(os.environ)\n    complete_env.update(env_dict)\n\n    # Resolve each variable\n    resolved: dict[str, str] = {}\n    for key, value in env_dict.items():\n        # Skip expansion for ignored keys or patterns\n        if self._should_ignore_key(key, ignore_keys, ignore_patterns):\n            resolved[key] = value\n            continue\n\n        try:\n            resolved_value = self._resolve_variable(\n                value,\n                complete_env,\n                stop_on_expansion_error=stop_on_expansion_error,\n                stop_on_resolution_error=stop_on_resolution_error,\n            )\n        except (VariableNotFoundError, SecretResolutionError) as e:\n            msg = f\"Failed to resolve environment variable '{key}': {e}\"\n            raise EnvironmentVariableResolutionError(\n                msg,\n                context_key=key,\n                original_error=e,\n            ) from e\n        if resolved_value is None:\n            continue\n\n        resolved[key] = resolved_value\n\n    # Export to os.environ if requested\n    if export:\n        for key, value in resolved.items():\n            if override or key not in os.environ:\n                os.environ[key] = value\n\n    return resolved\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.EnvResolver.resolve_os_environ","title":"resolve_os_environ","text":"<pre><code>resolve_os_environ(\n    keys: list[str] | None = None,\n    prefix: str | None = None,\n    *,\n    overwrite: bool = True,\n    stop_on_expansion_error: bool = True,\n    stop_on_resolution_error: bool = True,\n    ignore_keys: list[str] | None = None,\n    ignore_patterns: list[str] | None = None,\n) -&gt; dict[str, str]\n</code></pre> <p>Resolve secret URIs in os.environ.</p> <p>Raises:</p> Type Description <code>EnvironmentVariableResolutionError</code> <p>If a variable resolution error occurs (wraps VariableNotFoundError or SecretResolutionError with context)</p> <code>MutuallyExclusiveArgumentsError</code> <p>If both keys and prefix are specified</p> <code>URIParseError</code> <p>If the URI format is invalid</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> Source code in <code>src/envresolve/api.py</code> <pre><code>def resolve_os_environ(  # noqa: PLR0913\n    self,\n    keys: list[str] | None = None,\n    prefix: str | None = None,\n    *,\n    overwrite: bool = True,\n    stop_on_expansion_error: bool = True,\n    stop_on_resolution_error: bool = True,\n    ignore_keys: list[str] | None = None,\n    ignore_patterns: list[str] | None = None,\n) -&gt; dict[str, str]:\n    \"\"\"Resolve secret URIs in os.environ.\n\n    Raises:\n        EnvironmentVariableResolutionError: If a variable resolution error occurs\n            (wraps VariableNotFoundError or SecretResolutionError with context)\n        MutuallyExclusiveArgumentsError: If both keys and prefix are specified\n        URIParseError: If the URI format is invalid\n        CircularReferenceError: If a circular variable reference is detected\n    \"\"\"\n    if keys is not None and prefix is not None:\n        arg1 = \"keys\"\n        arg2 = \"prefix\"\n        raise MutuallyExclusiveArgumentsError(arg1, arg2)\n\n    target_env = self._get_target_environ(keys, prefix)\n    resolved: dict[str, str] = {}\n\n    for key, value in target_env.items():\n        # Skip expansion for ignored keys or patterns\n        if self._should_ignore_key(key, ignore_keys, ignore_patterns):\n            resolved[key] = value\n            if overwrite:\n                os.environ[key] = value\n            continue\n\n        try:\n            resolved_value = self._resolve_variable(\n                value,\n                stop_on_expansion_error=stop_on_expansion_error,\n                stop_on_resolution_error=stop_on_resolution_error,\n            )\n        except (VariableNotFoundError, SecretResolutionError) as e:\n            msg = f\"Failed to resolve environment variable '{key}': {e}\"\n            raise EnvironmentVariableResolutionError(\n                msg,\n                context_key=key,\n                original_error=e,\n            ) from e\n        if resolved_value is None:\n            continue\n\n        output_key = (\n            key[len(prefix) :] if prefix and key.startswith(prefix) else key\n        )\n        resolved[output_key] = resolved_value\n\n        if overwrite:\n            os.environ[output_key] = resolved_value\n            if prefix and key != output_key:\n                del os.environ[key]\n\n    return resolved\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.register_azure_kv_provider","title":"register_azure_kv_provider","text":"<pre><code>register_azure_kv_provider(\n    provider: SecretProvider | None = None,\n) -&gt; None\n</code></pre> <p>Register Azure Key Vault provider for akv:// scheme.</p> <p>This function should be called before attempting to resolve secrets from Azure Key Vault. It is safe to call multiple times (idempotent).</p> <p>Parameters:</p> Name Type Description Default <code>provider</code> <code>SecretProvider | None</code> <p>Optional custom provider. If None, uses default AzureKVProvider.</p> <code>None</code> <p>Raises:</p> Type Description <code>ProviderRegistrationError</code> <p>If azure-identity or azure-keyvault-secrets is not installed (only when provider is None)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import envresolve\n&gt;&gt;&gt; # Default behavior\n&gt;&gt;&gt; envresolve.register_azure_kv_provider()\n&gt;&gt;&gt; # Custom provider (requires Azure SDK imports)\n&gt;&gt;&gt; # from envresolve.providers.azure_kv import AzureKVProvider\n&gt;&gt;&gt; # from azure.identity import ManagedIdentityCredential\n&gt;&gt;&gt; # custom = AzureKVProvider(credential=ManagedIdentityCredential())\n&gt;&gt;&gt; # envresolve.register_azure_kv_provider(provider=custom)\n&gt;&gt;&gt; # Now you can resolve secrets (requires Azure authentication)\n&gt;&gt;&gt; # secret = envresolve.resolve_secret(\"akv://my-vault/db-password\")\n</code></pre> Source code in <code>src/envresolve/api.py</code> <pre><code>def register_azure_kv_provider(provider: \"SecretProvider | None\" = None) -&gt; None:\n    \"\"\"Register Azure Key Vault provider for akv:// scheme.\n\n    This function should be called before attempting to resolve secrets\n    from Azure Key Vault. It is safe to call multiple times (idempotent).\n\n    Args:\n        provider: Optional custom provider. If None, uses default AzureKVProvider.\n\n    Raises:\n        ProviderRegistrationError: If azure-identity or azure-keyvault-secrets\n            is not installed (only when provider is None)\n\n    Examples:\n        &gt;&gt;&gt; import envresolve\n        &gt;&gt;&gt; # Default behavior\n        &gt;&gt;&gt; envresolve.register_azure_kv_provider()\n        &gt;&gt;&gt; # Custom provider (requires Azure SDK imports)\n        &gt;&gt;&gt; # from envresolve.providers.azure_kv import AzureKVProvider\n        &gt;&gt;&gt; # from azure.identity import ManagedIdentityCredential\n        &gt;&gt;&gt; # custom = AzureKVProvider(credential=ManagedIdentityCredential())\n        &gt;&gt;&gt; # envresolve.register_azure_kv_provider(provider=custom)\n        &gt;&gt;&gt; # Now you can resolve secrets (requires Azure authentication)\n        &gt;&gt;&gt; # secret = envresolve.resolve_secret(\"akv://my-vault/db-password\")\n    \"\"\"\n    _default_resolver.register_azure_kv_provider(provider=provider)\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.resolve_secret","title":"resolve_secret","text":"<pre><code>resolve_secret(uri: str) -&gt; str\n</code></pre> <p>Resolve a secret URI to its value.</p> <p>This function supports: - Variable expansion: ${VAR} and $VAR syntax using os.environ - Secret URI resolution: akv:// scheme - Idempotent resolution: Plain strings and non-target URIs pass through unchanged</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>Secret URI or plain string to resolve</p> required <p>Returns:</p> Type Description <code>str</code> <p>Resolved secret value or the original string if not a secret URI</p> <p>Raises:</p> Type Description <code>URIParseError</code> <p>If the URI format is invalid</p> <code>SecretResolutionError</code> <p>If secret resolution fails</p> <code>VariableNotFoundError</code> <p>If a referenced variable is not found</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import envresolve\n&gt;&gt;&gt; # Idempotent - plain strings pass through\n&gt;&gt;&gt; value = envresolve.resolve_secret(\"just-a-string\")\n&gt;&gt;&gt; value\n'just-a-string'\n&gt;&gt;&gt; # Non-target URIs pass through unchanged\n&gt;&gt;&gt; uri = envresolve.resolve_secret(\"postgres://localhost/db\")\n&gt;&gt;&gt; uri\n'postgres://localhost/db'\n&gt;&gt;&gt; # Secret URIs require provider registration and authentication\n&gt;&gt;&gt; # envresolve.register_azure_kv_provider()\n&gt;&gt;&gt; # secret = envresolve.resolve_secret(\"akv://my-vault/db-password\")\n</code></pre> Source code in <code>src/envresolve/api.py</code> <pre><code>def resolve_secret(uri: str) -&gt; str:\n    \"\"\"Resolve a secret URI to its value.\n\n    This function supports:\n    - Variable expansion: ${VAR} and $VAR syntax using os.environ\n    - Secret URI resolution: akv:// scheme\n    - Idempotent resolution: Plain strings and non-target URIs pass through unchanged\n\n    Args:\n        uri: Secret URI or plain string to resolve\n\n    Returns:\n        Resolved secret value or the original string if not a secret URI\n\n    Raises:\n        URIParseError: If the URI format is invalid\n        SecretResolutionError: If secret resolution fails\n        VariableNotFoundError: If a referenced variable is not found\n        CircularReferenceError: If a circular variable reference is detected\n\n    Examples:\n        &gt;&gt;&gt; import envresolve\n        &gt;&gt;&gt; # Idempotent - plain strings pass through\n        &gt;&gt;&gt; value = envresolve.resolve_secret(\"just-a-string\")\n        &gt;&gt;&gt; value\n        'just-a-string'\n        &gt;&gt;&gt; # Non-target URIs pass through unchanged\n        &gt;&gt;&gt; uri = envresolve.resolve_secret(\"postgres://localhost/db\")\n        &gt;&gt;&gt; uri\n        'postgres://localhost/db'\n        &gt;&gt;&gt; # Secret URIs require provider registration and authentication\n        &gt;&gt;&gt; # envresolve.register_azure_kv_provider()\n        &gt;&gt;&gt; # secret = envresolve.resolve_secret(\"akv://my-vault/db-password\")\n    \"\"\"\n    return _default_resolver.resolve_secret(uri)\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.load_env","title":"load_env","text":"<pre><code>load_env(\n    dotenv_path: str | Path | None = None,\n    *,\n    export: bool = True,\n    override: bool = False,\n    stop_on_expansion_error: bool = True,\n    stop_on_resolution_error: bool = True,\n    ignore_keys: list[str] | None = None,\n    ignore_patterns: list[str] | None = None,\n) -&gt; dict[str, str]\n</code></pre> <p>Load environment variables from a .env file and resolve secret URIs.</p> <p>This function: 1. Loads variables from the .env file 2. Expands variable references within values 3. Resolves secret URIs (akv://) to actual secret values 4. Optionally exports to os.environ</p> <p>Parameters:</p> Name Type Description Default <code>dotenv_path</code> <code>str | Path | None</code> <p>Path to .env file. If None, searches for .env in current directory. Mimics python-dotenv's load_dotenv() behavior. (default: None)</p> <code>None</code> <code>export</code> <code>bool</code> <p>If True, export resolved variables to os.environ (default: True)</p> <code>True</code> <code>override</code> <code>bool</code> <p>If True, override existing os.environ variables (default: False)</p> <code>False</code> <code>stop_on_expansion_error</code> <code>bool</code> <p>If False, skip variables with expansion errors (e.g., VariableNotFoundError). CircularReferenceError is always raised as it indicates a configuration error. (default: True)</p> <code>True</code> <code>stop_on_resolution_error</code> <code>bool</code> <p>If False, skip variables with resolution errors (e.g., SecretResolutionError). Useful for resilience against transient secret store failures. (default: True)</p> <code>True</code> <code>ignore_keys</code> <code>list[str] | None</code> <p>List of keys to skip expansion for. These keys are included in the result as-is without variable expansion or secret resolution. (default: None)</p> <code>None</code> <code>ignore_patterns</code> <code>list[str] | None</code> <p>List of glob patterns to match keys for skipping expansion. Keys matching any pattern are included as-is without variable expansion or secret resolution. Supports wildcards: *, ?, [seq]. (default: None)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of resolved environment variables</p> <p>Raises:</p> Type Description <code>EnvironmentVariableResolutionError</code> <p>If a variable resolution error occurs (wraps VariableNotFoundError or SecretResolutionError with context)</p> <code>URIParseError</code> <p>If a URI format is invalid</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import envresolve\n&gt;&gt;&gt; envresolve.register_azure_kv_provider()\n&gt;&gt;&gt; # Load and export to os.environ (searches for .env in cwd)\n&gt;&gt;&gt; resolved = envresolve.load_env(export=True)\n&gt;&gt;&gt; # Load specific file without exporting\n&gt;&gt;&gt; resolved = envresolve.load_env(\"custom.env\", export=False)\n&gt;&gt;&gt; # Skip expansion for system variables\n&gt;&gt;&gt; resolved = envresolve.load_env(ignore_keys=[\"PS1\"])\n</code></pre> Source code in <code>src/envresolve/api.py</code> <pre><code>def load_env(  # noqa: PLR0913\n    dotenv_path: str | Path | None = None,\n    *,\n    export: bool = True,\n    override: bool = False,\n    stop_on_expansion_error: bool = True,\n    stop_on_resolution_error: bool = True,\n    ignore_keys: list[str] | None = None,\n    ignore_patterns: list[str] | None = None,\n) -&gt; dict[str, str]:\n    \"\"\"Load environment variables from a .env file and resolve secret URIs.\n\n    This function:\n    1. Loads variables from the .env file\n    2. Expands variable references within values\n    3. Resolves secret URIs (akv://) to actual secret values\n    4. Optionally exports to os.environ\n\n    Args:\n        dotenv_path: Path to .env file. If None, searches for .env in current directory.\n            Mimics python-dotenv's load_dotenv() behavior. (default: None)\n        export: If True, export resolved variables to os.environ (default: True)\n        override: If True, override existing os.environ variables (default: False)\n        stop_on_expansion_error: If False, skip variables with expansion errors\n            (e.g., VariableNotFoundError). CircularReferenceError is always\n            raised as it indicates a configuration error. (default: True)\n        stop_on_resolution_error: If False, skip variables with resolution errors\n            (e.g., SecretResolutionError). Useful for resilience against transient\n            secret store failures. (default: True)\n        ignore_keys: List of keys to skip expansion for. These keys are included\n            in the result as-is without variable expansion or secret resolution.\n            (default: None)\n        ignore_patterns: List of glob patterns to match keys for skipping expansion.\n            Keys matching any pattern are included as-is without variable expansion\n            or secret resolution. Supports wildcards: *, ?, [seq]. (default: None)\n\n    Returns:\n        Dictionary of resolved environment variables\n\n    Raises:\n        EnvironmentVariableResolutionError: If a variable resolution error occurs\n            (wraps VariableNotFoundError or SecretResolutionError with context)\n        URIParseError: If a URI format is invalid\n        CircularReferenceError: If a circular variable reference is detected\n\n    Examples:\n        &gt;&gt;&gt; import envresolve\n        &gt;&gt;&gt; envresolve.register_azure_kv_provider()\n        &gt;&gt;&gt; # Load and export to os.environ (searches for .env in cwd)\n        &gt;&gt;&gt; resolved = envresolve.load_env(export=True)  # doctest: +SKIP\n        &gt;&gt;&gt; # Load specific file without exporting\n        &gt;&gt;&gt; resolved = envresolve.load_env(\"custom.env\", export=False)  # doctest: +SKIP\n        &gt;&gt;&gt; # Skip expansion for system variables\n        &gt;&gt;&gt; resolved = envresolve.load_env(ignore_keys=[\"PS1\"])  # doctest: +SKIP\n    \"\"\"\n    return _default_resolver.load_env(\n        dotenv_path,\n        export=export,\n        override=override,\n        stop_on_expansion_error=stop_on_expansion_error,\n        stop_on_resolution_error=stop_on_resolution_error,\n        ignore_keys=ignore_keys,\n        ignore_patterns=ignore_patterns,\n    )\n</code></pre>"},{"location":"api-reference/public_api/#envresolve.api.resolve_os_environ","title":"resolve_os_environ","text":"<pre><code>resolve_os_environ(\n    keys: list[str] | None = None,\n    prefix: str | None = None,\n    *,\n    overwrite: bool = True,\n    stop_on_expansion_error: bool = True,\n    stop_on_resolution_error: bool = True,\n    ignore_keys: list[str] | None = None,\n    ignore_patterns: list[str] | None = None,\n) -&gt; dict[str, str]\n</code></pre> <p>Resolve secret URIs in os.environ.</p> <p>This function resolves secret URIs that are already set in environment variables, useful when values are passed from parent shells or container orchestrators.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>list[str] | None</code> <p>List of specific keys to resolve. If None, scan all keys. Mutually exclusive with prefix.</p> <code>None</code> <code>prefix</code> <code>str | None</code> <p>Only process keys with this prefix, strip prefix from output. Mutually exclusive with keys.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>If True, update os.environ with resolved values (default: True).</p> <code>True</code> <code>stop_on_expansion_error</code> <code>bool</code> <p>If False, skip variables with expansion errors (e.g., VariableNotFoundError). CircularReferenceError is always raised as it indicates a configuration error. (default: True)</p> <code>True</code> <code>stop_on_resolution_error</code> <code>bool</code> <p>If False, skip variables with resolution errors (e.g., SecretResolutionError). Useful for resilience against transient secret store failures. (default: True)</p> <code>True</code> <code>ignore_keys</code> <code>list[str] | None</code> <p>List of keys to skip expansion for. These keys are included in the result as-is without variable expansion or secret resolution. (default: None)</p> <code>None</code> <code>ignore_patterns</code> <code>list[str] | None</code> <p>List of glob patterns to match keys for skipping expansion. Keys matching any pattern are included as-is without variable expansion or secret resolution. Supports wildcards: *, ?, [seq]. (default: None)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of resolved values</p> <p>Raises:</p> Type Description <code>EnvironmentVariableResolutionError</code> <p>If a variable resolution error occurs (wraps VariableNotFoundError or SecretResolutionError with context)</p> <code>MutuallyExclusiveArgumentsError</code> <p>If both keys and prefix are specified</p> <code>URIParseError</code> <p>If the URI format is invalid</p> <code>CircularReferenceError</code> <p>If a circular variable reference is detected</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import envresolve\n&gt;&gt;&gt; import os\n&gt;&gt;&gt; envresolve.register_azure_kv_provider()\n&gt;&gt;&gt; # Resolve all environment variables\n&gt;&gt;&gt; resolved = envresolve.resolve_os_environ()\n&gt;&gt;&gt; # Resolve specific keys only\n&gt;&gt;&gt; resolved = envresolve.resolve_os_environ(keys=[\"API_KEY\"])\n&gt;&gt;&gt; # Skip expansion for system variables\n&gt;&gt;&gt; resolved = envresolve.resolve_os_environ(\n...     ignore_keys=[\"PS1\"]\n... )\n</code></pre> Source code in <code>src/envresolve/api.py</code> <pre><code>def resolve_os_environ(  # noqa: PLR0913\n    keys: list[str] | None = None,\n    prefix: str | None = None,\n    *,\n    overwrite: bool = True,\n    stop_on_expansion_error: bool = True,\n    stop_on_resolution_error: bool = True,\n    ignore_keys: list[str] | None = None,\n    ignore_patterns: list[str] | None = None,\n) -&gt; dict[str, str]:\n    \"\"\"Resolve secret URIs in os.environ.\n\n    This function resolves secret URIs that are already set in environment variables,\n    useful when values are passed from parent shells or container orchestrators.\n\n    Args:\n        keys: List of specific keys to resolve. If None, scan all keys.\n            Mutually exclusive with prefix.\n        prefix: Only process keys with this prefix, strip prefix from output.\n            Mutually exclusive with keys.\n        overwrite: If True, update os.environ with resolved values (default: True).\n        stop_on_expansion_error: If False, skip variables with expansion errors\n            (e.g., VariableNotFoundError). CircularReferenceError is always\n            raised as it indicates a configuration error. (default: True)\n        stop_on_resolution_error: If False, skip variables with resolution errors\n            (e.g., SecretResolutionError). Useful for resilience against transient\n            secret store failures. (default: True)\n        ignore_keys: List of keys to skip expansion for. These keys are included\n            in the result as-is without variable expansion or secret resolution.\n            (default: None)\n        ignore_patterns: List of glob patterns to match keys for skipping expansion.\n            Keys matching any pattern are included as-is without variable expansion\n            or secret resolution. Supports wildcards: *, ?, [seq]. (default: None)\n\n    Returns:\n        Dictionary of resolved values\n\n    Raises:\n        EnvironmentVariableResolutionError: If a variable resolution error occurs\n            (wraps VariableNotFoundError or SecretResolutionError with context)\n        MutuallyExclusiveArgumentsError: If both keys and prefix are specified\n        URIParseError: If the URI format is invalid\n        CircularReferenceError: If a circular variable reference is detected\n\n    Examples:\n        &gt;&gt;&gt; import envresolve\n        &gt;&gt;&gt; import os\n        &gt;&gt;&gt; envresolve.register_azure_kv_provider()\n        &gt;&gt;&gt; # Resolve all environment variables\n        &gt;&gt;&gt; resolved = envresolve.resolve_os_environ()  # doctest: +SKIP\n        &gt;&gt;&gt; # Resolve specific keys only\n        &gt;&gt;&gt; resolved = envresolve.resolve_os_environ(keys=[\"API_KEY\"])  # doctest: +SKIP\n        &gt;&gt;&gt; # Skip expansion for system variables\n        &gt;&gt;&gt; resolved = envresolve.resolve_os_environ(\n        ...     ignore_keys=[\"PS1\"]\n        ... )  # doctest: +SKIP\n    \"\"\"\n    return _default_resolver.resolve_os_environ(\n        keys=keys,\n        prefix=prefix,\n        overwrite=overwrite,\n        stop_on_expansion_error=stop_on_expansion_error,\n        stop_on_resolution_error=stop_on_resolution_error,\n        ignore_keys=ignore_keys,\n        ignore_patterns=ignore_patterns,\n    )\n</code></pre>"},{"location":"architecture/adr/","title":"Architecture Decision Records (ADRs)","text":"<p>This page provides an overview of all architectural decisions made for envresolve.</p>"},{"location":"architecture/adr/#what-are-adrs","title":"What are ADRs?","text":"<p>Architecture Decision Records document important architectural decisions along with their context and consequences. They help track the \"why\" behind design choices.</p>"},{"location":"architecture/adr/#current-adrs","title":"Current ADRs","text":""},{"location":"architecture/adr/#adr-0001-variable-expansion-with-regular-expressions","title":"ADR 0001: Variable Expansion with Regular Expressions","text":"<p>Status: Accepted Date: 2025-10-11</p> <p>Decided to use regular expressions for variable expansion instead of manual string parsing.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0002-custom-exception-hierarchy","title":"ADR 0002: Custom Exception Hierarchy","text":"<p>Status: Accepted Date: 2025-10-11</p> <p>Established a custom exception hierarchy with base exceptions for better error handling.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0003-structured-exception-design","title":"ADR 0003: Structured Exception Design","text":"<p>Status: Accepted Date: 2025-10-11</p> <p>Defined structured exception design for variable expansion errors.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0004-stateless-function-based-variable-expansion","title":"ADR 0004: Stateless Function-Based Variable Expansion","text":"<p>Status: Accepted Date: 2025-10-11</p> <p>Chose a stateless function (<code>expand_variables()</code>) as the core API instead of a stateful class.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0005-string-based-api-with-idempotent-resolution","title":"ADR 0005: String-Based API with Idempotent Resolution","text":"<p>Status: Accepted Date: 2025-10-12</p> <p>Return <code>str</code> directly instead of data models, with idempotent resolution (safe to call multiple times).</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0006-nested-variable-expansion-implementation","title":"ADR 0006: Nested Variable Expansion Implementation","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Two-phase iterative algorithm: expand innermost <code>${...}</code> first, then simple <code>$VAR</code>.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0007-layer-separation-services-vs-application","title":"ADR 0007: Layer Separation (Services vs Application)","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Separated pure business logic (services layer) from environment integration (application layer).</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0008-circular-reference-chain-tracking","title":"ADR 0008: Circular Reference Chain Tracking","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Extended <code>CircularReferenceError</code> to include full reference chain (<code>chain: list[str]</code>) for better debugging.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0009-manual-provider-registration-pattern","title":"ADR 0009: Manual Provider Registration Pattern","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Users explicitly call <code>register_azure_kv_provider()</code> before resolving secrets.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0010-iterative-uri-resolution","title":"ADR 0010: Iterative URI Resolution","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Implemented iterative resolution with cycle detection to support URI-to-URI resolution chains.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0011-conditional-doctest-skip","title":"ADR 0011: Conditional Doctest Skip","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Pytest fixture-based conditional skipping for doctests requiring optional dependencies.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0012-pytest-markers-for-azure-dependencies","title":"ADR 0012: Pytest Markers for Azure Dependencies","text":"<p>Status: Accepted Date: 2025-10-13</p> <p>Introduced <code>@pytest.mark.azure</code> to isolate tests requiring optional Azure SDK dependencies.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0013-class-based-api-design","title":"ADR 0013: Class-Based API Design","text":"<p>Status: Accepted Date: 2025-10-14</p> <p>Encapsulated resolution state in <code>EnvResolver</code> class with module-level facade for backward compatibility.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0014-importlib-lazy-import","title":"ADR 0014: Importlib Lazy Import","text":"<p>Status: Accepted Date: 2025-10-14</p> <p>Used <code>importlib.import_module</code> for lazy loading of optional Azure SDK dependencies with rich error messages.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0015-manage-azure-live-test-infrastructure-with-terraform","title":"ADR 0015: Manage Azure Live Test Infrastructure with Terraform","text":"<p>Status: Accepted Date: 2025-10-15</p> <p>Standardized live Azure Key Vault testing with Terraform-managed resources.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0016-typeerror-based-custom-exception-for-mutually-exclusive-parameters","title":"ADR 0016: TypeError-based Custom Exception for Mutually Exclusive Parameters","text":"<p>Status: Accepted Date: 2025-10-18</p> <p>Created <code>MutuallyExclusiveArgumentsError</code> inheriting from both <code>EnvResolveError</code> and <code>TypeError</code>.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0017-align-load_env-parameter-with-python-dotenv","title":"ADR 0017: Align load_env() Parameter with python-dotenv","text":"<p>Status: Accepted Date: 2025-10-20</p> <p>Changed <code>load_env()</code> signature to match python-dotenv's <code>load_dotenv()</code> for zero-friction migration.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0018-granular-error-handling-for-variable-expansion-and-secret-resolution","title":"ADR 0018: Granular Error Handling for Variable Expansion and Secret Resolution","text":"<p>Status: Accepted Date: 2025-10-21</p> <p>Split single <code>stop_on_error</code> flag into <code>stop_on_expansion_error</code> and <code>stop_on_resolution_error</code>.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0019-do-not-implement-validation-helper-functions-and-metadata-query-helpers","title":"ADR 0019: Do Not Implement Validation Helper Functions and Metadata Query Helpers","text":"<p>Status: Accepted Date: 2025-11-12</p> <p>Decided not to implement validation helpers and metadata query helpers due to lack of concrete use cases.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0020-add-ignore_keys-parameter-for-selective-variable-exclusion","title":"ADR 0020: Add ignore_keys Parameter for Selective Variable Exclusion","text":"<p>Status: Accepted Date: 2025-11-13</p> <p>Added <code>ignore_keys</code> parameter to selectively skip variable expansion for specified keys.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0021-exception-wrapping-for-variable-resolution-context","title":"ADR 0021: Exception Wrapping for Variable Resolution Context","text":"<p>Status: Accepted Date: 2025-11-14</p> <p>Wrap resolution errors with <code>EnvironmentVariableResolutionError</code> to provide context about which environment variable failed.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0022-add-ignore_patterns-parameter-for-pattern-based-variable-exclusion","title":"ADR 0022: Add ignore_patterns Parameter for Pattern-Based Variable Exclusion","text":"<p>Status: Accepted Date: 2025-11-15</p> <p>Added <code>ignore_patterns</code> parameter to selectively skip variable expansion using pattern matching.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-0023-use-fnmatch-glob-patterns-for-pattern-matching-implementation","title":"ADR 0023: Use fnmatch (Glob Patterns) for Pattern Matching Implementation","text":"<p>Status: Accepted Date: 2025-11-15</p> <p>Use Python's <code>fnmatch</code> module for glob-style pattern matching in <code>ignore_patterns</code>.</p> <p>View Full ADR</p>"},{"location":"architecture/adr/#adr-template","title":"ADR Template","text":"<p>All ADRs follow a consistent template defined in ADR 0000: ADR Template.</p>"},{"location":"architecture/adr/#contributing","title":"Contributing","text":"<p>When making significant architectural decisions, please:</p> <ol> <li>Review existing ADRs to ensure consistency</li> <li>Use the ADR template for new decisions</li> <li>Document both what you chose AND what you rejected</li> <li>Include the \"why\" behind your decision</li> </ol>"},{"location":"developer-guide/contributing/","title":"Contributing to envresolve","text":"<p>Thank you for considering contributing to envresolve!</p>"},{"location":"developer-guide/contributing/#development-setup","title":"Development Setup","text":""},{"location":"developer-guide/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.10 or higher</li> <li>uv package manager</li> <li>Git</li> </ul>"},{"location":"developer-guide/contributing/#setup","title":"Setup","text":"<ol> <li> <p>Fork the repository on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>git clone https://github.com/YOUR-USERNAME/envresolve.git\ncd envresolve\n</code></pre> </li> <li> <p>Add the upstream remote to sync with the main repository:</p> <pre><code>git remote add upstream https://github.com/osoekawaitlab/envresolve.git\n</code></pre> </li> <li> <p>Install dependencies:</p> <pre><code>uv sync\n</code></pre> </li> <li> <p>Run tests to verify setup:</p> <pre><code>nox -s tests\n</code></pre> </li> </ol>"},{"location":"developer-guide/contributing/#development-workflow","title":"Development Workflow","text":"<p>envresolve follows a strict Test-Driven Development (TDD) cycle.</p>"},{"location":"developer-guide/contributing/#running-tests","title":"Running Tests","text":"<pre><code># All tests with coverage\nnox -s tests\n\n# Unit tests only\nnox -s tests_unit\n\n# E2E tests only\nnox -s tests_e2e\n\n# All Python versions\nnox -s tests_all_versions\n</code></pre>"},{"location":"developer-guide/contributing/#code-quality","title":"Code Quality","text":"<pre><code># Type checking\nnox -s mypy\n\n# Linting\nnox -s lint\n\n# Format code\nnox -s format_code\n\n# All quality checks\nnox -s quality\n\n# Everything (tests + quality)\nnox -s check_all\n</code></pre>"},{"location":"developer-guide/contributing/#code-style","title":"Code Style","text":"<ul> <li>Type Hints: Required for all public APIs</li> <li>Docstrings: Google style, required for all public functions/classes</li> <li>Linting: Ruff with \"ALL\" rules (see <code>pyproject.toml</code>)</li> <li>Type Checking: Strict mypy configuration</li> </ul>"},{"location":"developer-guide/contributing/#pull-request-process","title":"Pull Request Process","text":"<ol> <li>Create a new branch from <code>main</code></li> <li>Make your changes following the TDD cycle</li> <li>Ensure all tests pass: <code>nox -s check_all</code></li> <li>Update documentation if needed</li> <li>Write or update ADRs for architectural decisions</li> <li>Submit a pull request with a clear description</li> </ol>"},{"location":"developer-guide/contributing/#pr-checklist","title":"PR Checklist","text":"<ul> <li>[ ] Tests added/updated and passing</li> <li>[ ] Code follows style guidelines (ruff check passes)</li> <li>[ ] Type hints added (mypy passes)</li> <li>[ ] Docstrings added/updated (Google style)</li> <li>[ ] Coverage maintained at 80%+</li> <li>[ ] ADRs written for design decisions</li> <li>[ ] Documentation updated if needed</li> </ul>"},{"location":"developer-guide/contributing/#architecture","title":"Architecture","text":"<p>envresolve follows a layered architecture:</p> <pre><code>Layer 5: api.py (Public API facade)\nLayer 4: application/ (resolver, cache)\nLayer 3: providers/ (factory, registry, implementations)\nLayer 2: services/ (reference, expansion)\nLayer 1: Domain (models, exceptions) + Infrastructure (base, logging)\nLayer 0: External dependencies\n</code></pre> <p>Key Principles:</p> <ul> <li>Higher layers depend on lower layers</li> <li>Lower layers NEVER depend on higher layers</li> <li>Domain layer has NO internal dependencies</li> </ul> <p>See Architecture ADRs for design decisions.</p>"},{"location":"developer-guide/contributing/#documentation","title":"Documentation","text":"<p>Documentation is built with MkDocs Material:</p> <pre><code># Serve documentation locally\nmkdocs serve\n\n# Build documentation\nmkdocs build\n</code></pre>"},{"location":"developer-guide/contributing/#documentation-structure","title":"Documentation Structure","text":"<ul> <li>User Guide: Installation and usage tutorials</li> <li>API Reference: Auto-generated from docstrings (mkdocstrings)</li> <li>Architecture: ADRs and design decisions</li> <li>Contributing: This file</li> </ul>"},{"location":"developer-guide/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>Use the GitHub issue tracker to report bugs or request features.</p> <p>When reporting bugs, please include:</p> <ul> <li>Python version</li> <li>envresolve version</li> <li>Minimal code to reproduce</li> <li>Expected vs actual behavior</li> <li>Error messages/stack traces</li> </ul>"},{"location":"developer-guide/contributing/#questions","title":"Questions?","text":"<ul> <li>Check the documentation</li> <li>Review existing issues</li> <li>Open a new issue for questions</li> </ul>"},{"location":"developer-guide/contributing/#license","title":"License","text":"<p>By contributing, you agree that your contributions will be licensed under the MIT License.</p>"},{"location":"developer-guide/contributing/#live-azure-tests","title":"Live Azure Tests","text":"<p>Optional integration tests against real Azure Key Vault infrastructure. Run these tests to validate changes that affect Azure SDK integration or provider implementations.</p> <p>Note: Live tests automatically skip when environment variables are not set (<code>ENVRESOLVE_LIVE_KEY_VAULT_NAME</code>, etc.), so they won't interfere with normal development.</p>"},{"location":"developer-guide/contributing/#one-time-setup","title":"One-Time Setup","text":"<pre><code># 1. Configure terraform (requires Azure subscription and az login)\ncd infra/terraform\ncp terraform.tfvars.example terraform.tfvars\n\n# 2. Edit terraform.tfvars with your values:\n#    - subscription_id, tenant_id, name_prefix\n#    - test_principal_object_id (get your object ID: az ad signed-in-user show --query id -o tsv)\n\n# 3. Create resources\nterraform init\nterraform apply\n\n# 4. Return to project root and set environment variables (per shell session)\ncd ../..\nsource scripts/setup_live_tests.sh\n</code></pre>"},{"location":"developer-guide/contributing/#running-live-tests","title":"Running Live Tests","text":"<pre><code>nox -s tests_live\n</code></pre>"},{"location":"developer-guide/contributing/#cleanup","title":"Cleanup","text":"<p>Resources can be kept for reuse. Destroy only when done:</p> <pre><code>cd infra/terraform\nterraform destroy\n</code></pre>"},{"location":"developer-guide/live-tests/","title":"Live Azure Tests","text":"<p>This project includes optional integration tests that run against a real Azure Key Vault instance. These tests are marked with the <code>live</code> and <code>azure</code> pytest markers.</p>"},{"location":"developer-guide/live-tests/#why-live-tests","title":"Why Live Tests?","text":"<p>While most of the application can be tested using mocked SDKs (E2E tests), live tests provide an extra layer of confidence by verifying the integration with the actual Azure service. This helps catch issues related to authentication, permissions, or unexpected API changes.</p>"},{"location":"developer-guide/live-tests/#setup-instructions","title":"Setup Instructions","text":"<p>Running these tests requires one-time setup using Terraform to provision the necessary Azure resources.</p>"},{"location":"developer-guide/live-tests/#1-install-tools","title":"1. Install Tools","text":"<p>Ensure you have Terraform and the Azure CLI installed.</p>"},{"location":"developer-guide/live-tests/#2-configure-terraform","title":"2. Configure Terraform","text":"<p>Navigate to the Terraform directory:</p> <pre><code>cd infra/terraform\n</code></pre> <p>Create a <code>terraform.tfvars</code> file from the example:</p> <pre><code>cp terraform.tfvars.example terraform.tfvars\n</code></pre> <p>Edit <code>terraform.tfvars</code> and fill in your Azure subscription details and desired resource names.</p>"},{"location":"developer-guide/live-tests/#3-provision-resources","title":"3. Provision Resources","text":"<p>Initialize and apply the Terraform configuration:</p> <pre><code>terraform init\nterraform apply\n</code></pre> <p>This will create an Azure Resource Group, a Key Vault, and a secret to be used for testing.</p>"},{"location":"developer-guide/live-tests/#running-the-tests","title":"Running the Tests","text":""},{"location":"developer-guide/live-tests/#1-authenticate","title":"1. Authenticate","text":"<p>Log in to Azure via the CLI:</p> <pre><code>az login\n</code></pre>"},{"location":"developer-guide/live-tests/#2-set-environment-variables","title":"2. Set Environment Variables","text":"<p>Run the setup script to export the Key Vault details as environment variables for the test runner:</p> <pre><code>source scripts/setup_live_tests.sh\n</code></pre> <p>This script reads the Terraform output and sets <code>AZURE_TENANT_ID</code>, <code>AZURE_CLIENT_ID</code>, etc.</p>"},{"location":"developer-guide/live-tests/#3-execute-tests","title":"3. Execute Tests","text":"<p>Finally, run the live tests using <code>nox</code>:</p> <pre><code>nox -s tests_live\n</code></pre>"},{"location":"developer-guide/live-tests/#cleaning-up","title":"Cleaning Up","text":"<p>To avoid incurring costs, destroy the Azure resources when you are done testing:</p> <pre><code>cd infra/terraform\nterraform destroy\n</code></pre>"},{"location":"user-guide/basic-usage/","title":"Basic Usage","text":""},{"location":"user-guide/basic-usage/#variable-expansion","title":"Variable Expansion","text":"<p>envresolve supports variable expansion using <code>${VAR}</code> and <code>$VAR</code> syntax.</p>"},{"location":"user-guide/basic-usage/#simple-variable-expansion","title":"Simple Variable Expansion","text":"${VAR} syntax$VAR syntax <pre><code>from envresolve import expand_variables\n\nenv = {\"VAULT_NAME\": \"my-vault\"}\nresult = expand_variables(\"${VAULT_NAME}\", env)\n\nprint(result)  # Output: my-vault\n</code></pre> <pre><code>from envresolve import expand_variables\n\nenv = {\"VAULT_NAME\": \"my-vault\"}\nresult = expand_variables(\"$VAULT_NAME\", env)\n\nprint(result)  # Output: my-vault\n</code></pre>"},{"location":"user-guide/basic-usage/#multiple-variables","title":"Multiple Variables","text":"<p>You can reference multiple variables in a single string:</p> <pre><code>from envresolve import expand_variables\n\nenv = {\n    \"VAULT_NAME\": \"my-vault\",\n    \"SECRET_NAME\": \"db-password\"\n}\nresult = expand_variables(\"akv://${VAULT_NAME}/${SECRET_NAME}\", env)\n\nprint(result)  # Output: akv://my-vault/db-password\n</code></pre>"},{"location":"user-guide/basic-usage/#nested-variable-expansion","title":"Nested Variable Expansion","text":"<p>Variables can reference other variables:</p> <pre><code>from envresolve import expand_variables\n\nenv = {\n    \"ENVIRONMENT\": \"prod\",\n    \"VAULT_NAME\": \"${ENVIRONMENT}-vault\",\n    \"SECRET_URI\": \"akv://${VAULT_NAME}/api-key\"\n}\nresult = expand_variables(env[\"SECRET_URI\"], env)\n\nprint(result)  # Output: akv://prod-vault/api-key\n</code></pre>"},{"location":"user-guide/basic-usage/#using-environment-variables","title":"Using Environment Variables","text":""},{"location":"user-guide/basic-usage/#with-osenviron","title":"With os.environ","text":"<p>Use <code>EnvExpander</code> to expand variables from the current environment:</p> <pre><code>import os\nfrom envresolve import EnvExpander\n\n# Set environment variable\nos.environ[\"VAULT_NAME\"] = \"production-vault\"\n\nexpander = EnvExpander()\nresult = expander.expand(\"akv://${VAULT_NAME}/secret\")\n\nprint(result)  # Output: akv://production-vault/secret\n</code></pre> <p>Snapshot Behavior</p> <p><code>EnvExpander</code> takes a snapshot of <code>os.environ</code> at initialization time. Changes to environment variables after initialization won't be reflected.</p>"},{"location":"user-guide/basic-usage/#with-env-files","title":"With .env Files","text":"<p>Use <code>DotEnvExpander</code> to expand variables from a <code>.env</code> file:</p> <pre><code>from envresolve import DotEnvExpander\n\n# Contents of .env:\n# VAULT_NAME=my-company-vault\n# DB_PASSWORD=akv://${VAULT_NAME}/db-password\n# API_KEY=akv://${VAULT_NAME}/api-key\n\nexpander = DotEnvExpander(\".env\")\ndb_password_uri = expander.expand(\"${DB_PASSWORD}\")\napi_key_uri = expander.expand(\"${API_KEY}\")\n\nprint(db_password_uri)  # Output: akv://my-company-vault/db-password\nprint(api_key_uri)      # Output: akv://my-company-vault/api-key\n</code></pre>"},{"location":"user-guide/basic-usage/#secret-resolution","title":"Secret Resolution","text":"<p>envresolve can resolve secrets referenced with <code>akv://</code> URIs. Provider registration is explicit so you only pay the dependency cost when you opt in.</p>"},{"location":"user-guide/basic-usage/#1-install-the-azure-extra-once-per-environment","title":"1. Install the Azure extra (once per environment)","text":"<pre><code>pip install envresolve[azure]\n</code></pre>"},{"location":"user-guide/basic-usage/#2-register-the-provider","title":"2. Register the provider","text":"<pre><code>import envresolve\n\nenvresolve.register_azure_kv_provider()\n</code></pre> <p><code>register_azure_kv_provider()</code> is idempotent\u2014you can call it during application startup without worrying about duplicate work.</p>"},{"location":"user-guide/basic-usage/#3-resolve-a-secret-uri","title":"3. Resolve a secret URI","text":"<pre><code>import envresolve\n\nenvresolve.register_azure_kv_provider()\n\n# Plain strings are returned unchanged (idempotent behaviour)\nprint(envresolve.resolve_secret(\"db-password\"))  # db-password\n\n# Secret URIs fetch values from Azure Key Vault\npassword = envresolve.resolve_secret(\"akv://corp-vault/db-password\")\nprint(password)\n</code></pre>"},{"location":"user-guide/basic-usage/#custom-provider-configuration","title":"Custom Provider Configuration","text":"<p>For advanced scenarios like testing or custom authentication, you can inject a custom provider instance:</p> <pre><code>import envresolve\nfrom envresolve.providers.azure_kv import AzureKVProvider\nfrom azure.identity import ManagedIdentityCredential\n\n# Create custom provider with specific credential\ncustom_provider = AzureKVProvider(\n    credential=ManagedIdentityCredential(client_id=\"your-client-id\")\n)\n\n# Register the custom provider\nenvresolve.register_azure_kv_provider(provider=custom_provider)\n\n# Now use envresolve as normal\nsecret = envresolve.resolve_secret(\"akv://vault/secret\")\n</code></pre> <p>This is particularly useful for:</p> <ul> <li>Testing: Inject mock providers without patching internal implementation details</li> <li>Custom authentication: Use specific Azure credentials (service principal, managed identity with client ID, etc.)</li> <li>Provider configuration: Pre-configure providers with custom settings before registration</li> </ul>"},{"location":"user-guide/basic-usage/#iterative-resolution","title":"Iterative resolution","text":"<p><code>resolve_secret()</code> keeps resolving until the returned value is stable. This lets you chain indirections or mix URI results with variable expansion:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\nos.environ[\"ENVIRONMENT\"] = \"prod\"\n\n# akv://config/service \u2192 \"akv://vault-${ENVIRONMENT}/service\"\nsecret = envresolve.resolve_secret(\"akv://config/service\")\nprint(secret)  # Resolved value from akv://vault-prod/service\n</code></pre>"},{"location":"user-guide/basic-usage/#loading-and-exporting-from-env","title":"Loading and exporting from <code>.env</code>","text":"<pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\n# .env may contain plain values, variable references, and akv:// URIs\n# By default, searches for .env in current directory and exports to os.environ\nresolved = envresolve.load_env()\n\nprint(resolved[\"DB_PASSWORD\"])\nprint(os.environ[\"DB_PASSWORD\"])  # Exported unless override=False and already set\n</code></pre> <p>Use <code>export=False</code> when you only need the resolved dictionary, or set <code>override=True</code> if you want to intentionally replace existing <code>os.environ</code> values.</p> <p>Complete python-dotenv compatibility</p> <p>For exact python-dotenv search behavior (searching from calling script location instead of current working directory), use this pattern:</p> <pre><code>from dotenv import load_dotenv\nimport envresolve\n\n# Use python-dotenv's search behavior\nload_dotenv()\n\n# Resolve secrets in os.environ\nenvresolve.register_azure_kv_provider()\nenvresolve.resolve_os_environ()\n</code></pre> <p>This preserves python-dotenv's exact search semantics while adding secret resolution capabilities.</p>"},{"location":"user-guide/basic-usage/#resolving-existing-environment-variables","title":"Resolving Existing Environment Variables","text":"<p>Use <code>resolve_os_environ()</code> to resolve secret URIs that are already set in <code>os.environ</code>. This is useful when environment variables are passed from parent shells or container orchestrators:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\n# Environment variables set by parent process or container\nos.environ[\"API_KEY\"] = \"akv://prod-vault/api-key\"\nos.environ[\"DB_PASSWORD\"] = \"akv://prod-vault/db-password\"\n\n# Resolve all environment variables containing secret URIs\nresolved = envresolve.resolve_os_environ()\n\nprint(resolved[\"API_KEY\"])      # Resolved secret value\nprint(os.environ[\"API_KEY\"])    # os.environ is updated by default\n</code></pre>"},{"location":"user-guide/basic-usage/#filtering-by-specific-keys","title":"Filtering by Specific Keys","text":"<p>Resolve only specific environment variables:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\nos.environ[\"API_KEY\"] = \"akv://prod-vault/api-key\"\nos.environ[\"DB_PASSWORD\"] = \"akv://prod-vault/db-password\"\nos.environ[\"PLAIN_CONFIG\"] = \"some-value\"\n\n# Resolve only API_KEY and DB_PASSWORD\nresolved = envresolve.resolve_os_environ(keys=[\"API_KEY\", \"DB_PASSWORD\"])\n\n# PLAIN_CONFIG is not processed\nassert \"PLAIN_CONFIG\" not in resolved\n</code></pre>"},{"location":"user-guide/basic-usage/#filtering-by-prefix","title":"Filtering by Prefix","text":"<p>Resolve variables with a specific prefix and strip the prefix from output:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\n# Different environments using prefixes\nos.environ[\"DEV_API_KEY\"] = \"akv://dev-vault/api-key\"\nos.environ[\"DEV_DB_URL\"] = \"akv://dev-vault/db-url\"\nos.environ[\"PROD_API_KEY\"] = \"akv://prod-vault/api-key\"\nos.environ[\"PROD_DB_URL\"] = \"akv://prod-vault/db-url\"\n\n# Resolve only DEV_ variables and strip the prefix\nresolved = envresolve.resolve_os_environ(prefix=\"DEV_\")\n\n# Results have prefix stripped\nprint(resolved[\"API_KEY\"])      # Resolved from DEV_API_KEY\nprint(resolved[\"DB_URL\"])       # Resolved from DEV_DB_URL\n\n# os.environ is updated with stripped keys\nprint(os.environ[\"API_KEY\"])    # Resolved value\nassert \"DEV_API_KEY\" not in os.environ  # Old key removed\n</code></pre> <p>Prefix Stripping Behavior</p> <p>When using <code>prefix</code>, the resolved values are stored in <code>os.environ</code> with the prefix stripped, and the original prefixed keys are removed.</p>"},{"location":"user-guide/basic-usage/#without-updating-osenviron","title":"Without Updating os.environ","text":"<p>Use <code>overwrite=False</code> to get resolved values without modifying <code>os.environ</code>:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\nos.environ[\"API_KEY\"] = \"akv://prod-vault/api-key\"\n\n# Get resolved values without updating os.environ\nresolved = envresolve.resolve_os_environ(overwrite=False)\n\nprint(resolved[\"API_KEY\"])              # Resolved secret value\nprint(os.environ[\"API_KEY\"])            # Still the original URI\nassert os.environ[\"API_KEY\"] == \"akv://prod-vault/api-key\"\n</code></pre>"},{"location":"user-guide/basic-usage/#continuing-on-errors","title":"Continuing on Errors","text":"<p>Use <code>stop_on_expansion_error=False</code> and <code>stop_on_resolution_error=False</code> to control error handling granularly:</p> <pre><code>import os\nimport envresolve\n\nenvresolve.register_azure_kv_provider()\n\nos.environ[\"GOOD_KEY\"] = \"akv://prod-vault/valid-secret\"\nos.environ[\"BAD_KEY\"] = \"akv://prod-vault/missing-secret\"  # Doesn't exist\nos.environ[\"MISSING_VAR\"] = \"${UNDEFINED}\"\nos.environ[\"PLAIN\"] = \"plain-value\"\n\n# Skip variables with missing references, but still raise on secret resolution errors\nresolved = envresolve.resolve_os_environ(stop_on_expansion_error=False)\n\n# Skip variables with secret resolution errors, but still raise on undefined variables\nresolved = envresolve.resolve_os_environ(stop_on_resolution_error=False)\n\n# Skip both types of errors\nresolved = envresolve.resolve_os_environ(\n    stop_on_expansion_error=False,\n    stop_on_resolution_error=False\n)\n\n# Successfully resolved variables are in the result\nprint(resolved[\"GOOD_KEY\"])    # Resolved value\nprint(resolved[\"PLAIN\"])       # plain-value\nassert \"BAD_KEY\" not in resolved  # Skipped due to secret resolution error\nassert \"MISSING_VAR\" not in resolved  # Skipped due to expansion error\n</code></pre> <p>CircularReferenceError is always raised</p> <p><code>CircularReferenceError</code> is always raised regardless of these flags, as it indicates a configuration error that cannot be resolved.</p>"},{"location":"user-guide/basic-usage/#ignoring-specific-variables","title":"Ignoring Specific Variables","text":"<p>Use <code>ignore_keys</code> to skip variable expansion and secret resolution for specific keys. This is useful when certain variables should be preserved as-is:</p> <pre><code>import os\nimport envresolve\n\nos.environ[\"PS1\"] = \"${USER}@${HOST}$ \"  # Shell prompt template\nos.environ[\"API_KEY\"] = \"akv://vault/api-key\"\n\n# Skip expansion for PS1\nresolved = envresolve.resolve_os_environ(ignore_keys=[\"PS1\"])\n\nprint(resolved[\"PS1\"])        # Output: ${USER}@${HOST}$  (unchanged)\nprint(resolved[\"API_KEY\"])    # Resolved secret value\n</code></pre> <p>Ignored variables are included in the result as-is without any processing.</p> <p>When to use <code>ignore_keys</code>:</p> <ul> <li>Skip specific variables while maintaining strict error checking for others</li> <li>Preserve variables containing literal <code>$</code> characters that shouldn't be expanded</li> <li>Temporarily exclude problematic variables during debugging</li> </ul> <p>Difference from <code>stop_on_expansion_error=False</code>:</p> <ul> <li><code>ignore_keys</code>: Selectively excludes specific variables by name</li> <li><code>stop_on_expansion_error=False</code>: Suppresses all expansion errors globally</li> </ul> <p>Use <code>ignore_keys</code> when you know exactly which variables to skip, and <code>stop_on_expansion_error=False</code> when you want lenient error handling across all variables.</p>"},{"location":"user-guide/basic-usage/#ignoring-variables-by-pattern","title":"Ignoring Variables by Pattern","text":"<p>Use <code>ignore_patterns</code> to skip variables using glob-style pattern matching. This is useful when you want to exclude groups of related variables:</p> <pre><code>import os\nimport envresolve\n\n# Shell prompt variables\nos.environ[\"PS1\"] = \"${USER}@${HOST}$ \"\nos.environ[\"PS2\"] = \"&gt; \"\nos.environ[\"PS4\"] = \"+ \"\nos.environ[\"PROMPT\"] = \"${PWD}$ \"\nos.environ[\"API_KEY\"] = \"akv://vault/api-key\"\n\n# Ignore all prompt-related variables using patterns\nresolved = envresolve.resolve_os_environ(ignore_patterns=[\"PS*\", \"PROMPT*\"])\n\nprint(resolved[\"PS1\"])        # Output: ${USER}@${HOST}$  (unchanged)\nprint(resolved[\"PS2\"])        # Output: &gt;  (unchanged)\nprint(resolved[\"PROMPT\"])     # Output: ${PWD}$  (unchanged)\nprint(resolved[\"API_KEY\"])    # Resolved secret value\n</code></pre> <p>Supported wildcards:</p> <ul> <li><code>*</code> - matches any characters (e.g., <code>PS*</code> matches <code>PS1</code>, <code>PS2</code>, <code>PROMPT</code>)</li> <li><code>?</code> - matches single character (e.g., <code>PS?</code> matches <code>PS1</code>, but not <code>PS10</code>)</li> <li><code>[seq]</code> - matches any character in seq (e.g., <code>PS[12]</code> matches <code>PS1</code>, <code>PS2</code>)</li> </ul> <p>Common use cases:</p> <pre><code># System shell variables\nignore_patterns=[\"PS*\", \"PROMPT*\", \"BASH_*\"]\n\n# Temporary variables\nignore_patterns=[\"TEMP_*\", \"TMP_*\"]\n\n# Debug flags\nignore_patterns=[\"DEBUG_*\", \"TRACE_*\"]\n</code></pre> <p>Best practices:</p> <p>Avoid overly broad patterns</p> <p>Be specific with your patterns to avoid accidentally excluding variables you need:</p> <pre><code># \u274c Too broad - excludes everything starting with 'A'\nignore_patterns=[\"A*\"]\n\n# \u2705 Specific - only excludes AWS temporary credentials\nignore_patterns=[\"AWS_SESSION_*\"]\n</code></pre> <p>Combining exact match and patterns</p> <p>Use both <code>ignore_keys</code> and <code>ignore_patterns</code> for maximum flexibility:</p> <pre><code>resolved = envresolve.resolve_os_environ(\n    ignore_keys=[\"SPECIFIC_VAR\"],        # Exact match\n    ignore_patterns=[\"TEMP_*\", \"DEBUG_*\"]  # Pattern match\n)\n</code></pre> <p>Execution order:</p> <ol> <li>Check <code>ignore_keys</code> (exact match - fast path)</li> <li>If not matched, check <code>ignore_patterns</code> (pattern match)</li> <li>If neither matched, perform resolution</li> </ol> <p>When to use <code>ignore_patterns</code> vs <code>ignore_keys</code>:</p> <ul> <li><code>ignore_patterns</code>: Exclude groups of related variables (e.g., all <code>PS*</code> shell prompts)</li> <li><code>ignore_keys</code>: Exclude specific individual variables by exact name</li> </ul>"},{"location":"user-guide/basic-usage/#error-handling","title":"Error Handling","text":"<p>When working with external services, it's important to handle potential errors like missing dependencies, incorrect configuration, or network issues.</p>"},{"location":"user-guide/basic-usage/#provider-and-resolution-errors","title":"Provider and Resolution Errors","text":"<p>Here is a robust example of how to handle errors during provider registration and secret resolution:</p> <pre><code>import envresolve\nfrom envresolve.exceptions import ProviderRegistrationError, SecretResolutionError\n\ntry:\n    # This might fail if 'envresolve[azure]' is not installed\n    envresolve.register_azure_kv_provider()\n\n    # This might fail due to permissions, network issues, or if the secret doesn't exist\n    secret_value = envresolve.resolve_secret(\"akv://corp-vault/db-password\")\n    print(secret_value)\n\nexcept ProviderRegistrationError as e:\n    print(f\"Provider setup failed: {e}\")\n    # Example: Provider setup failed: Azure Key Vault provider requires: azure-identity, azure-keyvault-secrets. Install with: pip install envresolve[azure]\n\nexcept SecretResolutionError as e:\n    print(f\"Failed to fetch secret: {e}\")\n</code></pre> <p>This pattern ensures that your application can gracefully handle both setup-time (missing dependencies) and run-time (secret access) errors.</p>"},{"location":"user-guide/basic-usage/#environment-variable-resolution-errors","title":"Environment Variable Resolution Errors","text":"<p>When <code>load_env()</code> or <code>resolve_os_environ()</code> fails, <code>EnvironmentVariableResolutionError</code> indicates which variable was being processed:</p> <pre><code>import envresolve\n\ntry:\n    envresolve.load_env(dotenv_path=\".env\", export=False)\nexcept envresolve.EnvironmentVariableResolutionError as e:\n    print(f\"Failed variable: {e.context_key}\")\n    print(f\"Cause: {e.original_error}\")\n\n    # Access original error details\n    if isinstance(e.original_error, envresolve.VariableNotFoundError):\n        print(f\"Missing: {e.original_error.variable_name}\")\n    elif isinstance(e.original_error, envresolve.SecretResolutionError):\n        print(f\"Failed URI: {e.original_error.uri}\")\n</code></pre> <p>The exception has two attributes: <code>context_key</code> (variable name) and <code>original_error</code> (underlying exception). <code>CircularReferenceError</code> is not wrapped</p>"},{"location":"user-guide/basic-usage/#circular-reference-detection","title":"Circular Reference Detection","text":"<p>envresolve automatically detects circular references and raises a clear error:</p> <pre><code>from envresolve import expand_variables\nfrom envresolve.exceptions import CircularReferenceError\n\nenv = {\n    \"A\": \"${B}\",\n    \"B\": \"${A}\"\n}\n\ntry:\n    result = expand_variables(env[\"A\"], env)\nexcept CircularReferenceError as e:\n    print(f\"Error: {e}\")\n    # Error: Circular reference detected: B -&gt; A -&gt; B\n\n    # Inspect the exact cycle if you need more detail\n    print(e.chain)  # ['B', 'A', 'B']\n</code></pre>"},{"location":"user-guide/basic-usage/#missing-variable-error","title":"Missing Variable Error","text":"<p>If a referenced variable doesn't exist, <code>VariableNotFoundError</code> is raised:</p> <pre><code>from envresolve import expand_variables\nfrom envresolve.exceptions import VariableNotFoundError\n\nenv = {\"A\": \"value\"}\n\ntry:\n    result = expand_variables(\"${MISSING}\", env)\nexcept VariableNotFoundError as e:\n    print(f\"Error: {e}\")\n    # Error: Variable 'MISSING' not found\n</code></pre>"},{"location":"user-guide/basic-usage/#mutually-exclusive-arguments","title":"Mutually Exclusive Arguments","text":"<p>Some API functions have mutually exclusive parameters. For example, <code>resolve_os_environ()</code> cannot accept both <code>keys</code> and <code>prefix</code> parameters:</p> <pre><code>import envresolve\nfrom envresolve.exceptions import MutuallyExclusiveArgumentsError\n\nenvresolve.register_azure_kv_provider()\n\ntry:\n    # This will raise an error - cannot specify both\n    envresolve.resolve_os_environ(\n        keys=[\"API_KEY\"],\n        prefix=\"DEV_\"\n    )\nexcept MutuallyExclusiveArgumentsError as e:\n    print(f\"Error: {e}\")\n    # Error: Arguments 'keys' and 'prefix' are mutually exclusive.\n    #        Specify either 'keys' or 'prefix', but not both.\n\n    # Access argument names programmatically\n    print(f\"Conflicting arguments: {e.arg1} and {e.arg2}\")\n    # Conflicting arguments: keys and prefix\n</code></pre> <p>TypeError Compatibility</p> <p><code>MutuallyExclusiveArgumentsError</code> also inherits from <code>TypeError</code>, so you can catch it with standard exception handling:</p> <pre><code>try:\n    envresolve.resolve_os_environ(keys=[\"API_KEY\"], prefix=\"DEV_\")\nexcept TypeError as e:\n    print(f\"Invalid argument combination: {e}\")\n</code></pre>"},{"location":"user-guide/basic-usage/#advanced-use-cases","title":"Advanced Use Cases","text":""},{"location":"user-guide/basic-usage/#building-secret-uris-dynamically","title":"Building Secret URIs Dynamically","text":"<pre><code>from envresolve import expand_variables\n\n# Define vault and environment once\nenv = {\n    \"ENVIRONMENT\": \"production\",\n    \"VAULT\": \"${ENVIRONMENT}-keyvault\",\n\n    # Define all secrets using the vault\n    \"DB_HOST_URI\": \"akv://${VAULT}/db-host\",\n    \"DB_USER_URI\": \"akv://${VAULT}/db-user\",\n    \"DB_PASS_URI\": \"akv://${VAULT}/db-password\",\n    \"API_KEY_URI\": \"akv://${VAULT}/api-key\",\n}\n\n# Expand each URI\nfor key in [\"DB_HOST_URI\", \"DB_USER_URI\", \"DB_PASS_URI\", \"API_KEY_URI\"]:\n    expanded = expand_variables(env[key], env)\n    print(f\"{key}: {expanded}\")\n\n# Output:\n# DB_HOST_URI: akv://production-keyvault/db-host\n# DB_USER_URI: akv://production-keyvault/db-user\n# DB_PASS_URI: akv://production-keyvault/db-password\n# API_KEY_URI: akv://production-keyvault/api-key\n</code></pre>"},{"location":"user-guide/basic-usage/#plain-text-pass-through","title":"Plain Text Pass-Through","text":"<p>Text without variable references is returned unchanged:</p> <pre><code>from envresolve import expand_variables\n\nresult = expand_variables(\"plain text with $100 price\", {\"VAR\": \"value\"})\nprint(result)  # Output: plain text with $100 price\n</code></pre> <p>Note: A lone <code>$</code> followed by non-variable characters (like digits) is preserved.</p>"},{"location":"user-guide/basic-usage/#secret-resolution-errors","title":"Secret Resolution Errors","text":"<p>Azure-specific failures (missing vaults, permission issues, network errors) raise <code>SecretResolutionError</code>. The exception carries the failing URI, making it easy to log or surface to users:</p> <pre><code>import envresolve\nfrom envresolve.exceptions import SecretResolutionError\n\nenvresolve.register_azure_kv_provider()\n\ntry:\n    envresolve.resolve_secret(\"akv://missing-vault/api-key\")\nexcept SecretResolutionError as exc:\n    print(exc)              # Human-readable message\n    print(exc.uri)          # akv://missing-vault/api-key\n    print(exc.original_error)  # Underlying Azure exception (if available)\n</code></pre>"},{"location":"user-guide/installation/","title":"Installation","text":""},{"location":"user-guide/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or higher</li> </ul>"},{"location":"user-guide/installation/#install-from-pypi","title":"Install from PyPI","text":"<pre><code>pip install envresolve\n</code></pre>"},{"location":"user-guide/installation/#install-with-uv","title":"Install with uv","text":"<pre><code>uv pip install envresolve\n</code></pre>"},{"location":"user-guide/installation/#install-for-development","title":"Install for Development","text":"<p>To install envresolve for development with all dependencies:</p> <pre><code># Clone the repository\ngit clone https://github.com/osoekawaitlab/envresolve.git\ncd envresolve\n\n# Install with development dependencies\nuv sync\n\n# Run tests\nnox -s tests\n\n# Run all quality checks\nnox -s check_all\n</code></pre>"},{"location":"user-guide/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"user-guide/installation/#azure-key-vault-support","title":"Azure Key Vault Support","text":"<p>Install the Azure extra when you need <code>akv://</code> resolution:</p> <pre><code>pip install envresolve[azure]\n</code></pre> <p>This pulls in:</p> <ul> <li><code>azure-identity</code></li> <li><code>azure-keyvault-secrets</code></li> </ul> <p>After installation, register the provider before resolving secrets:</p> <pre><code>import envresolve\n\nenvresolve.register_azure_kv_provider()\n</code></pre>"}]}